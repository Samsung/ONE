/*
 * Copyright (c) 2024 Samsung Electronics Co., Ltd. All Rights Reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// automatically generated by the FlatBuffers compiler, do not modify
// command: externals/FLATBUFFER-2.0/build/flatc -c ../circle_traininfo.fbs

#ifndef FLATBUFFERS_GENERATED_CIRCLETRAINING_CIRCLE_H_
#define FLATBUFFERS_GENERATED_CIRCLETRAINING_CIRCLE_H_

#include "flatbuffers/flatbuffers.h"

namespace circle
{

struct SGDOptions;
struct SGDOptionsBuilder;

struct AdamOptions;
struct AdamOptionsBuilder;

struct SparseCategoricalCrossentropyOptions;
struct SparseCategoricalCrossentropyOptionsBuilder;

struct CategoricalCrossentropyOptions;
struct CategoricalCrossentropyOptionsBuilder;

struct MeanSquaredErrorOptions;
struct MeanSquaredErrorOptionsBuilder;

struct ModelTraining;
struct ModelTrainingBuilder;

enum Optimizer : int8_t
{
  Optimizer_SGD = 0,
  Optimizer_ADAM = 1,
  Optimizer_MIN = Optimizer_SGD,
  Optimizer_MAX = Optimizer_ADAM
};

inline const Optimizer (&EnumValuesOptimizer())[2]
{
  static const Optimizer values[] = {Optimizer_SGD, Optimizer_ADAM};
  return values;
}

inline const char *const *EnumNamesOptimizer()
{
  static const char *const names[3] = {"SGD", "ADAM", nullptr};
  return names;
}

inline const char *EnumNameOptimizer(Optimizer e)
{
  if (flatbuffers::IsOutRange(e, Optimizer_SGD, Optimizer_ADAM))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOptimizer()[index];
}

enum OptimizerOptions : uint8_t
{
  OptimizerOptions_NONE = 0,
  OptimizerOptions_SGDOptions = 1,
  OptimizerOptions_AdamOptions = 2,
  OptimizerOptions_MIN = OptimizerOptions_NONE,
  OptimizerOptions_MAX = OptimizerOptions_AdamOptions
};

inline const OptimizerOptions (&EnumValuesOptimizerOptions())[3]
{
  static const OptimizerOptions values[] = {OptimizerOptions_NONE, OptimizerOptions_SGDOptions,
                                            OptimizerOptions_AdamOptions};
  return values;
}

inline const char *const *EnumNamesOptimizerOptions()
{
  static const char *const names[4] = {"NONE", "SGDOptions", "AdamOptions", nullptr};
  return names;
}

inline const char *EnumNameOptimizerOptions(OptimizerOptions e)
{
  if (flatbuffers::IsOutRange(e, OptimizerOptions_NONE, OptimizerOptions_AdamOptions))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOptimizerOptions()[index];
}

template <typename T> struct OptimizerOptionsTraits
{
  static const OptimizerOptions enum_value = OptimizerOptions_NONE;
};

template <> struct OptimizerOptionsTraits<circle::SGDOptions>
{
  static const OptimizerOptions enum_value = OptimizerOptions_SGDOptions;
};

template <> struct OptimizerOptionsTraits<circle::AdamOptions>
{
  static const OptimizerOptions enum_value = OptimizerOptions_AdamOptions;
};

bool VerifyOptimizerOptions(flatbuffers::Verifier &verifier, const void *obj,
                            OptimizerOptions type);
bool VerifyOptimizerOptionsVector(flatbuffers::Verifier &verifier,
                                  const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                  const flatbuffers::Vector<uint8_t> *types);

enum LossFn : int8_t
{
  LossFn_SPARSE_CATEGORICAL_CROSSENTROPY = 0,
  LossFn_CATEGORICAL_CROSSENTROPY = 1,
  LossFn_MEAN_SQUARED_ERROR = 2,
  LossFn_MIN = LossFn_SPARSE_CATEGORICAL_CROSSENTROPY,
  LossFn_MAX = LossFn_MEAN_SQUARED_ERROR
};

inline const LossFn (&EnumValuesLossFn())[3]
{
  static const LossFn values[] = {LossFn_SPARSE_CATEGORICAL_CROSSENTROPY,
                                  LossFn_CATEGORICAL_CROSSENTROPY, LossFn_MEAN_SQUARED_ERROR};
  return values;
}

inline const char *const *EnumNamesLossFn()
{
  static const char *const names[4] = {"SPARSE_CATEGORICAL_CROSSENTROPY",
                                       "CATEGORICAL_CROSSENTROPY", "MEAN_SQUARED_ERROR", nullptr};
  return names;
}

inline const char *EnumNameLossFn(LossFn e)
{
  if (flatbuffers::IsOutRange(e, LossFn_SPARSE_CATEGORICAL_CROSSENTROPY, LossFn_MEAN_SQUARED_ERROR))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLossFn()[index];
}

enum LossFnOptions : uint8_t
{
  LossFnOptions_NONE = 0,
  LossFnOptions_SparseCategoricalCrossentropyOptions = 1,
  LossFnOptions_CategoricalCrossentropyOptions = 2,
  LossFnOptions_MeanSquaredErrorOptions = 3,
  LossFnOptions_MIN = LossFnOptions_NONE,
  LossFnOptions_MAX = LossFnOptions_MeanSquaredErrorOptions
};

inline const LossFnOptions (&EnumValuesLossFnOptions())[4]
{
  static const LossFnOptions values[] = {
    LossFnOptions_NONE, LossFnOptions_SparseCategoricalCrossentropyOptions,
    LossFnOptions_CategoricalCrossentropyOptions, LossFnOptions_MeanSquaredErrorOptions};
  return values;
}

inline const char *const *EnumNamesLossFnOptions()
{
  static const char *const names[5] = {"NONE", "SparseCategoricalCrossentropyOptions",
                                       "CategoricalCrossentropyOptions", "MeanSquaredErrorOptions",
                                       nullptr};
  return names;
}

inline const char *EnumNameLossFnOptions(LossFnOptions e)
{
  if (flatbuffers::IsOutRange(e, LossFnOptions_NONE, LossFnOptions_MeanSquaredErrorOptions))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLossFnOptions()[index];
}

template <typename T> struct LossFnOptionsTraits
{
  static const LossFnOptions enum_value = LossFnOptions_NONE;
};

template <> struct LossFnOptionsTraits<circle::SparseCategoricalCrossentropyOptions>
{
  static const LossFnOptions enum_value = LossFnOptions_SparseCategoricalCrossentropyOptions;
};

template <> struct LossFnOptionsTraits<circle::CategoricalCrossentropyOptions>
{
  static const LossFnOptions enum_value = LossFnOptions_CategoricalCrossentropyOptions;
};

template <> struct LossFnOptionsTraits<circle::MeanSquaredErrorOptions>
{
  static const LossFnOptions enum_value = LossFnOptions_MeanSquaredErrorOptions;
};

bool VerifyLossFnOptions(flatbuffers::Verifier &verifier, const void *obj, LossFnOptions type);
bool VerifyLossFnOptionsVector(flatbuffers::Verifier &verifier,
                               const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                               const flatbuffers::Vector<uint8_t> *types);

enum LossReductionType : int8_t
{
  LossReductionType_SumOverBatchSize = 0,
  LossReductionType_Sum = 1,
  LossReductionType_MIN = LossReductionType_SumOverBatchSize,
  LossReductionType_MAX = LossReductionType_Sum
};

inline const LossReductionType (&EnumValuesLossReductionType())[2]
{
  static const LossReductionType values[] = {LossReductionType_SumOverBatchSize,
                                             LossReductionType_Sum};
  return values;
}

inline const char *const *EnumNamesLossReductionType()
{
  static const char *const names[3] = {"SumOverBatchSize", "Sum", nullptr};
  return names;
}

inline const char *EnumNameLossReductionType(LossReductionType e)
{
  if (flatbuffers::IsOutRange(e, LossReductionType_SumOverBatchSize, LossReductionType_Sum))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLossReductionType()[index];
}

struct SGDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SGDOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_LEARNING_RATE = 4
  };
  float learning_rate() const { return GetField<float>(VT_LEARNING_RATE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_LEARNING_RATE) &&
           verifier.EndTable();
  }
};

struct SGDOptionsBuilder
{
  typedef SGDOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_learning_rate(float learning_rate)
  {
    fbb_.AddElement<float>(SGDOptions::VT_LEARNING_RATE, learning_rate, 0.0f);
  }
  explicit SGDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SGDOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SGDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SGDOptions> CreateSGDOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                        float learning_rate = 0.0f)
{
  SGDOptionsBuilder builder_(_fbb);
  builder_.add_learning_rate(learning_rate);
  return builder_.Finish();
}

struct AdamOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef AdamOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_LEARNING_RATE = 4,
    VT_BETA_1 = 6,
    VT_BETA_2 = 8,
    VT_EPSILON = 10
  };
  float learning_rate() const { return GetField<float>(VT_LEARNING_RATE, 0.0f); }
  float beta_1() const { return GetField<float>(VT_BETA_1, 0.0f); }
  float beta_2() const { return GetField<float>(VT_BETA_2, 0.0f); }
  float epsilon() const { return GetField<float>(VT_EPSILON, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_LEARNING_RATE) &&
           VerifyField<float>(verifier, VT_BETA_1) && VerifyField<float>(verifier, VT_BETA_2) &&
           VerifyField<float>(verifier, VT_EPSILON) && verifier.EndTable();
  }
};

struct AdamOptionsBuilder
{
  typedef AdamOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_learning_rate(float learning_rate)
  {
    fbb_.AddElement<float>(AdamOptions::VT_LEARNING_RATE, learning_rate, 0.0f);
  }
  void add_beta_1(float beta_1) { fbb_.AddElement<float>(AdamOptions::VT_BETA_1, beta_1, 0.0f); }
  void add_beta_2(float beta_2) { fbb_.AddElement<float>(AdamOptions::VT_BETA_2, beta_2, 0.0f); }
  void add_epsilon(float epsilon)
  {
    fbb_.AddElement<float>(AdamOptions::VT_EPSILON, epsilon, 0.0f);
  }
  explicit AdamOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AdamOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AdamOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AdamOptions> CreateAdamOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                          float learning_rate = 0.0f,
                                                          float beta_1 = 0.0f, float beta_2 = 0.0f,
                                                          float epsilon = 0.0f)
{
  AdamOptionsBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_beta_2(beta_2);
  builder_.add_beta_1(beta_1);
  builder_.add_learning_rate(learning_rate);
  return builder_.Finish();
}

struct SparseCategoricalCrossentropyOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SparseCategoricalCrossentropyOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FROM_LOGITS = 4
  };
  bool from_logits() const { return GetField<uint8_t>(VT_FROM_LOGITS, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_FROM_LOGITS) &&
           verifier.EndTable();
  }
};

struct SparseCategoricalCrossentropyOptionsBuilder
{
  typedef SparseCategoricalCrossentropyOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_from_logits(bool from_logits)
  {
    fbb_.AddElement<uint8_t>(SparseCategoricalCrossentropyOptions::VT_FROM_LOGITS,
                             static_cast<uint8_t>(from_logits), 0);
  }
  explicit SparseCategoricalCrossentropyOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
    : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SparseCategoricalCrossentropyOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseCategoricalCrossentropyOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseCategoricalCrossentropyOptions>
CreateSparseCategoricalCrossentropyOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                           bool from_logits = false)
{
  SparseCategoricalCrossentropyOptionsBuilder builder_(_fbb);
  builder_.add_from_logits(from_logits);
  return builder_.Finish();
}

struct CategoricalCrossentropyOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef CategoricalCrossentropyOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FROM_LOGITS = 4
  };
  bool from_logits() const { return GetField<uint8_t>(VT_FROM_LOGITS, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_FROM_LOGITS) &&
           verifier.EndTable();
  }
};

struct CategoricalCrossentropyOptionsBuilder
{
  typedef CategoricalCrossentropyOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_from_logits(bool from_logits)
  {
    fbb_.AddElement<uint8_t>(CategoricalCrossentropyOptions::VT_FROM_LOGITS,
                             static_cast<uint8_t>(from_logits), 0);
  }
  explicit CategoricalCrossentropyOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CategoricalCrossentropyOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CategoricalCrossentropyOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CategoricalCrossentropyOptions>
CreateCategoricalCrossentropyOptions(flatbuffers::FlatBufferBuilder &_fbb, bool from_logits = false)
{
  CategoricalCrossentropyOptionsBuilder builder_(_fbb);
  builder_.add_from_logits(from_logits);
  return builder_.Finish();
}

struct MeanSquaredErrorOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef MeanSquaredErrorOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct MeanSquaredErrorOptionsBuilder
{
  typedef MeanSquaredErrorOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MeanSquaredErrorOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MeanSquaredErrorOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeanSquaredErrorOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeanSquaredErrorOptions>
CreateMeanSquaredErrorOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  MeanSquaredErrorOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ModelTraining FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ModelTrainingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VERSION = 4,
    VT_OPTIMIZER = 6,
    VT_OPTIMIZER_OPT_TYPE = 8,
    VT_OPTIMIZER_OPT = 10,
    VT_LOSSFN = 12,
    VT_LOSSFN_OPT_TYPE = 14,
    VT_LOSSFN_OPT = 16,
    VT_EPOCHS = 18,
    VT_BATCH_SIZE = 20,
    VT_LOSS_REDUCTION_TYPE = 22
  };
  uint32_t version() const { return GetField<uint32_t>(VT_VERSION, 0); }
  circle::Optimizer optimizer() const
  {
    return static_cast<circle::Optimizer>(GetField<int8_t>(VT_OPTIMIZER, 0));
  }
  circle::OptimizerOptions optimizer_opt_type() const
  {
    return static_cast<circle::OptimizerOptions>(GetField<uint8_t>(VT_OPTIMIZER_OPT_TYPE, 0));
  }
  const void *optimizer_opt() const { return GetPointer<const void *>(VT_OPTIMIZER_OPT); }
  template <typename T> const T *optimizer_opt_as() const;
  const circle::SGDOptions *optimizer_opt_as_SGDOptions() const
  {
    return optimizer_opt_type() == circle::OptimizerOptions_SGDOptions
             ? static_cast<const circle::SGDOptions *>(optimizer_opt())
             : nullptr;
  }
  const circle::AdamOptions *optimizer_opt_as_AdamOptions() const
  {
    return optimizer_opt_type() == circle::OptimizerOptions_AdamOptions
             ? static_cast<const circle::AdamOptions *>(optimizer_opt())
             : nullptr;
  }
  circle::LossFn lossfn() const
  {
    return static_cast<circle::LossFn>(GetField<int8_t>(VT_LOSSFN, 0));
  }
  circle::LossFnOptions lossfn_opt_type() const
  {
    return static_cast<circle::LossFnOptions>(GetField<uint8_t>(VT_LOSSFN_OPT_TYPE, 0));
  }
  const void *lossfn_opt() const { return GetPointer<const void *>(VT_LOSSFN_OPT); }
  template <typename T> const T *lossfn_opt_as() const;
  const circle::SparseCategoricalCrossentropyOptions *
  lossfn_opt_as_SparseCategoricalCrossentropyOptions() const
  {
    return lossfn_opt_type() == circle::LossFnOptions_SparseCategoricalCrossentropyOptions
             ? static_cast<const circle::SparseCategoricalCrossentropyOptions *>(lossfn_opt())
             : nullptr;
  }
  const circle::CategoricalCrossentropyOptions *lossfn_opt_as_CategoricalCrossentropyOptions() const
  {
    return lossfn_opt_type() == circle::LossFnOptions_CategoricalCrossentropyOptions
             ? static_cast<const circle::CategoricalCrossentropyOptions *>(lossfn_opt())
             : nullptr;
  }
  const circle::MeanSquaredErrorOptions *lossfn_opt_as_MeanSquaredErrorOptions() const
  {
    return lossfn_opt_type() == circle::LossFnOptions_MeanSquaredErrorOptions
             ? static_cast<const circle::MeanSquaredErrorOptions *>(lossfn_opt())
             : nullptr;
  }
  int32_t epochs() const { return GetField<int32_t>(VT_EPOCHS, 0); }
  int32_t batch_size() const { return GetField<int32_t>(VT_BATCH_SIZE, 0); }
  circle::LossReductionType loss_reduction_type() const
  {
    return static_cast<circle::LossReductionType>(GetField<int8_t>(VT_LOSS_REDUCTION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<int8_t>(verifier, VT_OPTIMIZER) &&
           VerifyField<uint8_t>(verifier, VT_OPTIMIZER_OPT_TYPE) &&
           VerifyOffset(verifier, VT_OPTIMIZER_OPT) &&
           VerifyOptimizerOptions(verifier, optimizer_opt(), optimizer_opt_type()) &&
           VerifyField<int8_t>(verifier, VT_LOSSFN) &&
           VerifyField<uint8_t>(verifier, VT_LOSSFN_OPT_TYPE) &&
           VerifyOffset(verifier, VT_LOSSFN_OPT) &&
           VerifyLossFnOptions(verifier, lossfn_opt(), lossfn_opt_type()) &&
           VerifyField<int32_t>(verifier, VT_EPOCHS) &&
           VerifyField<int32_t>(verifier, VT_BATCH_SIZE) &&
           VerifyField<int8_t>(verifier, VT_LOSS_REDUCTION_TYPE) && verifier.EndTable();
  }
};

template <>
inline const circle::SGDOptions *ModelTraining::optimizer_opt_as<circle::SGDOptions>() const
{
  return optimizer_opt_as_SGDOptions();
}

template <>
inline const circle::AdamOptions *ModelTraining::optimizer_opt_as<circle::AdamOptions>() const
{
  return optimizer_opt_as_AdamOptions();
}

template <>
inline const circle::SparseCategoricalCrossentropyOptions *
ModelTraining::lossfn_opt_as<circle::SparseCategoricalCrossentropyOptions>() const
{
  return lossfn_opt_as_SparseCategoricalCrossentropyOptions();
}

template <>
inline const circle::CategoricalCrossentropyOptions *
ModelTraining::lossfn_opt_as<circle::CategoricalCrossentropyOptions>() const
{
  return lossfn_opt_as_CategoricalCrossentropyOptions();
}

template <>
inline const circle::MeanSquaredErrorOptions *
ModelTraining::lossfn_opt_as<circle::MeanSquaredErrorOptions>() const
{
  return lossfn_opt_as_MeanSquaredErrorOptions();
}

struct ModelTrainingBuilder
{
  typedef ModelTraining Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version)
  {
    fbb_.AddElement<uint32_t>(ModelTraining::VT_VERSION, version, 0);
  }
  void add_optimizer(circle::Optimizer optimizer)
  {
    fbb_.AddElement<int8_t>(ModelTraining::VT_OPTIMIZER, static_cast<int8_t>(optimizer), 0);
  }
  void add_optimizer_opt_type(circle::OptimizerOptions optimizer_opt_type)
  {
    fbb_.AddElement<uint8_t>(ModelTraining::VT_OPTIMIZER_OPT_TYPE,
                             static_cast<uint8_t>(optimizer_opt_type), 0);
  }
  void add_optimizer_opt(flatbuffers::Offset<void> optimizer_opt)
  {
    fbb_.AddOffset(ModelTraining::VT_OPTIMIZER_OPT, optimizer_opt);
  }
  void add_lossfn(circle::LossFn lossfn)
  {
    fbb_.AddElement<int8_t>(ModelTraining::VT_LOSSFN, static_cast<int8_t>(lossfn), 0);
  }
  void add_lossfn_opt_type(circle::LossFnOptions lossfn_opt_type)
  {
    fbb_.AddElement<uint8_t>(ModelTraining::VT_LOSSFN_OPT_TYPE,
                             static_cast<uint8_t>(lossfn_opt_type), 0);
  }
  void add_lossfn_opt(flatbuffers::Offset<void> lossfn_opt)
  {
    fbb_.AddOffset(ModelTraining::VT_LOSSFN_OPT, lossfn_opt);
  }
  void add_epochs(int32_t epochs) { fbb_.AddElement<int32_t>(ModelTraining::VT_EPOCHS, epochs, 0); }
  void add_batch_size(int32_t batch_size)
  {
    fbb_.AddElement<int32_t>(ModelTraining::VT_BATCH_SIZE, batch_size, 0);
  }
  void add_loss_reduction_type(circle::LossReductionType loss_reduction_type)
  {
    fbb_.AddElement<int8_t>(ModelTraining::VT_LOSS_REDUCTION_TYPE,
                            static_cast<int8_t>(loss_reduction_type), 0);
  }
  explicit ModelTrainingBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelTraining> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelTraining>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelTraining> CreateModelTraining(
  flatbuffers::FlatBufferBuilder &_fbb, uint32_t version = 0,
  circle::Optimizer optimizer = circle::Optimizer_SGD,
  circle::OptimizerOptions optimizer_opt_type = circle::OptimizerOptions_NONE,
  flatbuffers::Offset<void> optimizer_opt = 0,
  circle::LossFn lossfn = circle::LossFn_SPARSE_CATEGORICAL_CROSSENTROPY,
  circle::LossFnOptions lossfn_opt_type = circle::LossFnOptions_NONE,
  flatbuffers::Offset<void> lossfn_opt = 0, int32_t epochs = 0, int32_t batch_size = 0,
  circle::LossReductionType loss_reduction_type = circle::LossReductionType_SumOverBatchSize)
{
  ModelTrainingBuilder builder_(_fbb);
  builder_.add_batch_size(batch_size);
  builder_.add_epochs(epochs);
  builder_.add_lossfn_opt(lossfn_opt);
  builder_.add_optimizer_opt(optimizer_opt);
  builder_.add_version(version);
  builder_.add_loss_reduction_type(loss_reduction_type);
  builder_.add_lossfn_opt_type(lossfn_opt_type);
  builder_.add_lossfn(lossfn);
  builder_.add_optimizer_opt_type(optimizer_opt_type);
  builder_.add_optimizer(optimizer);
  return builder_.Finish();
}

inline bool VerifyOptimizerOptions(flatbuffers::Verifier &verifier, const void *obj,
                                   OptimizerOptions type)
{
  switch (type)
  {
    case OptimizerOptions_NONE:
    {
      return true;
    }
    case OptimizerOptions_SGDOptions:
    {
      auto ptr = reinterpret_cast<const circle::SGDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OptimizerOptions_AdamOptions:
    {
      auto ptr = reinterpret_cast<const circle::AdamOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool
VerifyOptimizerOptionsVector(flatbuffers::Verifier &verifier,
                             const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                             const flatbuffers::Vector<uint8_t> *types)
{
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
  {
    if (!VerifyOptimizerOptions(verifier, values->Get(i), types->GetEnum<OptimizerOptions>(i)))
    {
      return false;
    }
  }
  return true;
}

inline bool VerifyLossFnOptions(flatbuffers::Verifier &verifier, const void *obj,
                                LossFnOptions type)
{
  switch (type)
  {
    case LossFnOptions_NONE:
    {
      return true;
    }
    case LossFnOptions_SparseCategoricalCrossentropyOptions:
    {
      auto ptr = reinterpret_cast<const circle::SparseCategoricalCrossentropyOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LossFnOptions_CategoricalCrossentropyOptions:
    {
      auto ptr = reinterpret_cast<const circle::CategoricalCrossentropyOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LossFnOptions_MeanSquaredErrorOptions:
    {
      auto ptr = reinterpret_cast<const circle::MeanSquaredErrorOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool VerifyLossFnOptionsVector(flatbuffers::Verifier &verifier,
                                      const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                      const flatbuffers::Vector<uint8_t> *types)
{
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
  {
    if (!VerifyLossFnOptions(verifier, values->Get(i), types->GetEnum<LossFnOptions>(i)))
    {
      return false;
    }
  }
  return true;
}

inline const circle::ModelTraining *GetModelTraining(const void *buf)
{
  return flatbuffers::GetRoot<circle::ModelTraining>(buf);
}

inline const circle::ModelTraining *GetSizePrefixedModelTraining(const void *buf)
{
  return flatbuffers::GetSizePrefixedRoot<circle::ModelTraining>(buf);
}

inline const char *ModelTrainingIdentifier() { return "CTR1"; }

inline bool ModelTrainingBufferHasIdentifier(const void *buf)
{
  return flatbuffers::BufferHasIdentifier(buf, ModelTrainingIdentifier());
}

inline bool VerifyModelTrainingBuffer(flatbuffers::Verifier &verifier)
{
  return verifier.VerifyBuffer<circle::ModelTraining>(ModelTrainingIdentifier());
}

inline bool VerifySizePrefixedModelTrainingBuffer(flatbuffers::Verifier &verifier)
{
  return verifier.VerifySizePrefixedBuffer<circle::ModelTraining>(ModelTrainingIdentifier());
}

inline const char *ModelTrainingExtension() { return "circletr"; }

inline void FinishModelTrainingBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                      flatbuffers::Offset<circle::ModelTraining> root)
{
  fbb.Finish(root, ModelTrainingIdentifier());
}

inline void FinishSizePrefixedModelTrainingBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                                  flatbuffers::Offset<circle::ModelTraining> root)
{
  fbb.FinishSizePrefixed(root, ModelTrainingIdentifier());
}

} // namespace circle

#endif // FLATBUFFERS_GENERATED_CIRCLETRAINING_CIRCLE_H_
