/*
 * Copyright (c) 2019-2024 Samsung Electronics Co., Ltd. All Rights Reserved
 * Copyright 2018 The TensorFlow Authors. All Rights Reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CIRCLESCHEMA_CIRCLE_H_
#define FLATBUFFERS_GENERATED_CIRCLESCHEMA_CIRCLE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 && FLATBUFFERS_VERSION_MINOR == 5 &&
                FLATBUFFERS_VERSION_REVISION == 26,
              "Non-compatible flatbuffers version included");

namespace circle
{

struct CustomQuantization;
struct CustomQuantizationBuilder;

struct QuantizationParameters;
struct QuantizationParametersBuilder;

struct Int32Vector;
struct Int32VectorBuilder;

struct Uint16Vector;
struct Uint16VectorBuilder;

struct Uint8Vector;
struct Uint8VectorBuilder;

struct DimensionMetadata;
struct DimensionMetadataBuilder;

struct SparsityParameters;
struct SparsityParametersBuilder;

struct VariantSubType;
struct VariantSubTypeBuilder;

struct Tensor;
struct TensorBuilder;

struct StablehloGatherOptions;
struct StablehloGatherOptionsBuilder;

struct StablehloTransposeOptions;
struct StablehloTransposeOptionsBuilder;

struct StablehloDotGeneralOptions;
struct StablehloDotGeneralOptionsBuilder;

struct StablehloReduceWindowOptions;
struct StablehloReduceWindowOptionsBuilder;

struct StablehloWhileOptions;
struct StablehloWhileOptionsBuilder;

struct StablehloSortOptions;
struct StablehloSortOptionsBuilder;

struct StablehloConcatenateOptions;
struct StablehloConcatenateOptionsBuilder;

struct StablehloBroadcastInDimOptions;
struct StablehloBroadcastInDimOptionsBuilder;

struct StablehloCompareOptions;
struct StablehloCompareOptionsBuilder;

struct StablehloDynamicSliceOptions;
struct StablehloDynamicSliceOptionsBuilder;

struct StablehloPadOptions;
struct StablehloPadOptionsBuilder;

struct StablehloIotaOptions;
struct StablehloIotaOptionsBuilder;

struct StablehloCustomCallOptions;
struct StablehloCustomCallOptionsBuilder;

struct StablehloReduceOptions;
struct StablehloReduceOptionsBuilder;

struct StablehloSliceOptions;
struct StablehloSliceOptionsBuilder;

struct StablehloConvolutionOptions;
struct StablehloConvolutionOptionsBuilder;

struct StablehloScatterOptions;
struct StablehloScatterOptionsBuilder;

struct StablehloRngBitGeneratorOptions;
struct StablehloRngBitGeneratorOptionsBuilder;

struct Conv2DOptions;
struct Conv2DOptionsBuilder;

struct Conv3DOptions;
struct Conv3DOptionsBuilder;

struct Pool2DOptions;
struct Pool2DOptionsBuilder;

struct DepthwiseConv2DOptions;
struct DepthwiseConv2DOptionsBuilder;

struct ConcatEmbeddingsOptions;
struct ConcatEmbeddingsOptionsBuilder;

struct LSHProjectionOptions;
struct LSHProjectionOptionsBuilder;

struct SVDFOptions;
struct SVDFOptionsBuilder;

struct RNNOptions;
struct RNNOptionsBuilder;

struct SequenceRNNOptions;
struct SequenceRNNOptionsBuilder;

struct BidirectionalSequenceRNNOptions;
struct BidirectionalSequenceRNNOptionsBuilder;

struct FullyConnectedOptions;
struct FullyConnectedOptionsBuilder;

struct SoftmaxOptions;
struct SoftmaxOptionsBuilder;

struct ConcatenationOptions;
struct ConcatenationOptionsBuilder;

struct AddOptions;
struct AddOptionsBuilder;

struct MulOptions;
struct MulOptionsBuilder;

struct L2NormOptions;
struct L2NormOptionsBuilder;

struct LocalResponseNormalizationOptions;
struct LocalResponseNormalizationOptionsBuilder;

struct LSTMOptions;
struct LSTMOptionsBuilder;

struct UnidirectionalSequenceLSTMOptions;
struct UnidirectionalSequenceLSTMOptionsBuilder;

struct BidirectionalSequenceLSTMOptions;
struct BidirectionalSequenceLSTMOptionsBuilder;

struct ResizeBilinearOptions;
struct ResizeBilinearOptionsBuilder;

struct ResizeNearestNeighborOptions;
struct ResizeNearestNeighborOptionsBuilder;

struct CallOptions;
struct CallOptionsBuilder;

struct PadOptions;
struct PadOptionsBuilder;

struct PadV2Options;
struct PadV2OptionsBuilder;

struct ReshapeOptions;
struct ReshapeOptionsBuilder;

struct SpaceToBatchNDOptions;
struct SpaceToBatchNDOptionsBuilder;

struct BatchToSpaceNDOptions;
struct BatchToSpaceNDOptionsBuilder;

struct SkipGramOptions;
struct SkipGramOptionsBuilder;

struct SpaceToDepthOptions;
struct SpaceToDepthOptionsBuilder;

struct DepthToSpaceOptions;
struct DepthToSpaceOptionsBuilder;

struct SubOptions;
struct SubOptionsBuilder;

struct DivOptions;
struct DivOptionsBuilder;

struct TopKV2Options;
struct TopKV2OptionsBuilder;

struct EmbeddingLookupSparseOptions;
struct EmbeddingLookupSparseOptionsBuilder;

struct GatherOptions;
struct GatherOptionsBuilder;

struct TransposeOptions;
struct TransposeOptionsBuilder;

struct ExpOptions;
struct ExpOptionsBuilder;

struct CosOptions;
struct CosOptionsBuilder;

struct ReducerOptions;
struct ReducerOptionsBuilder;

struct SqueezeOptions;
struct SqueezeOptionsBuilder;

struct SplitOptions;
struct SplitOptionsBuilder;

struct SplitVOptions;
struct SplitVOptionsBuilder;

struct StridedSliceOptions;
struct StridedSliceOptionsBuilder;

struct LogSoftmaxOptions;
struct LogSoftmaxOptionsBuilder;

struct CastOptions;
struct CastOptionsBuilder;

struct DequantizeOptions;
struct DequantizeOptionsBuilder;

struct MaximumMinimumOptions;
struct MaximumMinimumOptionsBuilder;

struct TileOptions;
struct TileOptionsBuilder;

struct ArgMaxOptions;
struct ArgMaxOptionsBuilder;

struct ArgMinOptions;
struct ArgMinOptionsBuilder;

struct GreaterOptions;
struct GreaterOptionsBuilder;

struct GreaterEqualOptions;
struct GreaterEqualOptionsBuilder;

struct LessOptions;
struct LessOptionsBuilder;

struct LessEqualOptions;
struct LessEqualOptionsBuilder;

struct NegOptions;
struct NegOptionsBuilder;

struct SelectOptions;
struct SelectOptionsBuilder;

struct SliceOptions;
struct SliceOptionsBuilder;

struct TransposeConvOptions;
struct TransposeConvOptionsBuilder;

struct ExpandDimsOptions;
struct ExpandDimsOptionsBuilder;

struct SparseToDenseOptions;
struct SparseToDenseOptionsBuilder;

struct EqualOptions;
struct EqualOptionsBuilder;

struct NotEqualOptions;
struct NotEqualOptionsBuilder;

struct ShapeOptions;
struct ShapeOptionsBuilder;

struct RankOptions;
struct RankOptionsBuilder;

struct PowOptions;
struct PowOptionsBuilder;

struct FakeQuantOptions;
struct FakeQuantOptionsBuilder;

struct PackOptions;
struct PackOptionsBuilder;

struct LogicalOrOptions;
struct LogicalOrOptionsBuilder;

struct OneHotOptions;
struct OneHotOptionsBuilder;

struct AbsOptions;
struct AbsOptionsBuilder;

struct HardSwishOptions;
struct HardSwishOptionsBuilder;

struct LogicalAndOptions;
struct LogicalAndOptionsBuilder;

struct LogicalNotOptions;
struct LogicalNotOptionsBuilder;

struct UnpackOptions;
struct UnpackOptionsBuilder;

struct FloorDivOptions;
struct FloorDivOptionsBuilder;

struct SquareOptions;
struct SquareOptionsBuilder;

struct ZerosLikeOptions;
struct ZerosLikeOptionsBuilder;

struct FillOptions;
struct FillOptionsBuilder;

struct FloorModOptions;
struct FloorModOptionsBuilder;

struct RangeOptions;
struct RangeOptionsBuilder;

struct LeakyReluOptions;
struct LeakyReluOptionsBuilder;

struct SquaredDifferenceOptions;
struct SquaredDifferenceOptionsBuilder;

struct MirrorPadOptions;
struct MirrorPadOptionsBuilder;

struct UniqueOptions;
struct UniqueOptionsBuilder;

struct ReverseV2Options;
struct ReverseV2OptionsBuilder;

struct AddNOptions;
struct AddNOptionsBuilder;

struct GatherNdOptions;
struct GatherNdOptionsBuilder;

struct WhereOptions;
struct WhereOptionsBuilder;

struct ReverseSequenceOptions;
struct ReverseSequenceOptionsBuilder;

struct MatrixDiagOptions;
struct MatrixDiagOptionsBuilder;

struct QuantizeOptions;
struct QuantizeOptionsBuilder;

struct MatrixSetDiagOptions;
struct MatrixSetDiagOptionsBuilder;

struct IfOptions;
struct IfOptionsBuilder;

struct CallOnceOptions;
struct CallOnceOptionsBuilder;

struct WhileOptions;
struct WhileOptionsBuilder;

struct NonMaxSuppressionV4Options;
struct NonMaxSuppressionV4OptionsBuilder;

struct NonMaxSuppressionV5Options;
struct NonMaxSuppressionV5OptionsBuilder;

struct ScatterNdOptions;
struct ScatterNdOptionsBuilder;

struct SelectV2Options;
struct SelectV2OptionsBuilder;

struct DensifyOptions;
struct DensifyOptionsBuilder;

struct SegmentSumOptions;
struct SegmentSumOptionsBuilder;

struct BatchMatMulOptions;
struct BatchMatMulOptionsBuilder;

struct CumsumOptions;
struct CumsumOptionsBuilder;

struct BroadcastToOptions;
struct BroadcastToOptionsBuilder;

struct Rfft2dOptions;
struct Rfft2dOptionsBuilder;

struct HashtableOptions;
struct HashtableOptionsBuilder;

struct HashtableFindOptions;
struct HashtableFindOptionsBuilder;

struct HashtableImportOptions;
struct HashtableImportOptionsBuilder;

struct HashtableSizeOptions;
struct HashtableSizeOptionsBuilder;

struct VarHandleOptions;
struct VarHandleOptionsBuilder;

struct ReadVariableOptions;
struct ReadVariableOptionsBuilder;

struct AssignVariableOptions;
struct AssignVariableOptionsBuilder;

struct RandomOptions;
struct RandomOptionsBuilder;

struct BucketizeOptions;
struct BucketizeOptionsBuilder;

struct GeluOptions;
struct GeluOptionsBuilder;

struct DynamicUpdateSliceOptions;
struct DynamicUpdateSliceOptionsBuilder;

struct UnsortedSegmentProdOptions;
struct UnsortedSegmentProdOptionsBuilder;

struct UnsortedSegmentMaxOptions;
struct UnsortedSegmentMaxOptionsBuilder;

struct UnsortedSegmentSumOptions;
struct UnsortedSegmentSumOptionsBuilder;

struct ATan2Options;
struct ATan2OptionsBuilder;

struct UnsortedSegmentMinOptions;
struct UnsortedSegmentMinOptionsBuilder;

struct SignOptions;
struct SignOptionsBuilder;

struct BitcastOptions;
struct BitcastOptionsBuilder;

struct BitwiseXorOptions;
struct BitwiseXorOptionsBuilder;

struct RightShiftOptions;
struct RightShiftOptionsBuilder;

struct DilateOptions;
struct DilateOptionsBuilder;

struct ReduceWindowOptions;
struct ReduceWindowOptionsBuilder;

struct GRUOptions;
struct GRUOptionsBuilder;

struct BCQGatherOptions;
struct BCQGatherOptionsBuilder;

struct BCQFullyConnectedOptions;
struct BCQFullyConnectedOptionsBuilder;

struct InstanceNormOptions;
struct InstanceNormOptionsBuilder;

struct OperatorCode;
struct OperatorCodeBuilder;

struct Operator;
struct OperatorBuilder;

struct SubGraph;
struct SubGraphBuilder;

struct Buffer;
struct BufferBuilder;

struct Metadata;
struct MetadataBuilder;

struct TensorMap;
struct TensorMapBuilder;

struct SignatureDef;
struct SignatureDefBuilder;

struct Model;
struct ModelBuilder;

enum TensorType : int8_t
{
  TensorType_UINT4 = -1,
  TensorType_FLOAT32 = 0,
  TensorType_FLOAT16 = 1,
  TensorType_INT32 = 2,
  TensorType_UINT8 = 3,
  TensorType_INT64 = 4,
  TensorType_STRING = 5,
  TensorType_BOOL = 6,
  TensorType_INT16 = 7,
  TensorType_COMPLEX64 = 8,
  TensorType_INT8 = 9,
  TensorType_FLOAT64 = 10,
  TensorType_COMPLEX128 = 11,
  TensorType_UINT64 = 12,
  TensorType_RESOURCE = 13,
  TensorType_VARIANT = 14,
  TensorType_UINT32 = 15,
  TensorType_UINT16 = 16,
  TensorType_INT4 = 17,
  TensorType_MIN = TensorType_UINT4,
  TensorType_MAX = TensorType_INT4
};

inline const TensorType (&EnumValuesTensorType())[19]
{
  static const TensorType values[] = {
    TensorType_UINT4,      TensorType_FLOAT32,   TensorType_FLOAT16,  TensorType_INT32,
    TensorType_UINT8,      TensorType_INT64,     TensorType_STRING,   TensorType_BOOL,
    TensorType_INT16,      TensorType_COMPLEX64, TensorType_INT8,     TensorType_FLOAT64,
    TensorType_COMPLEX128, TensorType_UINT64,    TensorType_RESOURCE, TensorType_VARIANT,
    TensorType_UINT32,     TensorType_UINT16,    TensorType_INT4};
  return values;
}

inline const char *const *EnumNamesTensorType()
{
  static const char *const names[20] = {"UINT4",   "FLOAT32", "FLOAT16",    "INT32",  "UINT8",
                                        "INT64",   "STRING",  "BOOL",       "INT16",  "COMPLEX64",
                                        "INT8",    "FLOAT64", "COMPLEX128", "UINT64", "RESOURCE",
                                        "VARIANT", "UINT32",  "UINT16",     "INT4",   nullptr};
  return names;
}

inline const char *EnumNameTensorType(TensorType e)
{
  if (::flatbuffers::IsOutRange(e, TensorType_UINT4, TensorType_INT4))
    return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(TensorType_UINT4);
  return EnumNamesTensorType()[index];
}

enum QuantizationDetails : uint8_t
{
  QuantizationDetails_NONE = 0,
  QuantizationDetails_CustomQuantization = 1,
  QuantizationDetails_MIN = QuantizationDetails_NONE,
  QuantizationDetails_MAX = QuantizationDetails_CustomQuantization
};

inline const QuantizationDetails (&EnumValuesQuantizationDetails())[2]
{
  static const QuantizationDetails values[] = {QuantizationDetails_NONE,
                                               QuantizationDetails_CustomQuantization};
  return values;
}

inline const char *const *EnumNamesQuantizationDetails()
{
  static const char *const names[3] = {"NONE", "CustomQuantization", nullptr};
  return names;
}

inline const char *EnumNameQuantizationDetails(QuantizationDetails e)
{
  if (::flatbuffers::IsOutRange(e, QuantizationDetails_NONE,
                                QuantizationDetails_CustomQuantization))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizationDetails()[index];
}

template <typename T> struct QuantizationDetailsTraits
{
  static const QuantizationDetails enum_value = QuantizationDetails_NONE;
};

template <> struct QuantizationDetailsTraits<circle::CustomQuantization>
{
  static const QuantizationDetails enum_value = QuantizationDetails_CustomQuantization;
};

bool VerifyQuantizationDetails(::flatbuffers::Verifier &verifier, const void *obj,
                               QuantizationDetails type);
bool VerifyQuantizationDetailsVector(
  ::flatbuffers::Verifier &verifier,
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
  const ::flatbuffers::Vector<uint8_t> *types);

enum DimensionType : int8_t
{
  DimensionType_DENSE = 0,
  DimensionType_SPARSE_CSR = 1,
  DimensionType_MIN = DimensionType_DENSE,
  DimensionType_MAX = DimensionType_SPARSE_CSR
};

inline const DimensionType (&EnumValuesDimensionType())[2]
{
  static const DimensionType values[] = {DimensionType_DENSE, DimensionType_SPARSE_CSR};
  return values;
}

inline const char *const *EnumNamesDimensionType()
{
  static const char *const names[3] = {"DENSE", "SPARSE_CSR", nullptr};
  return names;
}

inline const char *EnumNameDimensionType(DimensionType e)
{
  if (::flatbuffers::IsOutRange(e, DimensionType_DENSE, DimensionType_SPARSE_CSR))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDimensionType()[index];
}

enum SparseIndexVector : uint8_t
{
  SparseIndexVector_NONE = 0,
  SparseIndexVector_Int32Vector = 1,
  SparseIndexVector_Uint16Vector = 2,
  SparseIndexVector_Uint8Vector = 3,
  SparseIndexVector_MIN = SparseIndexVector_NONE,
  SparseIndexVector_MAX = SparseIndexVector_Uint8Vector
};

inline const SparseIndexVector (&EnumValuesSparseIndexVector())[4]
{
  static const SparseIndexVector values[] = {SparseIndexVector_NONE, SparseIndexVector_Int32Vector,
                                             SparseIndexVector_Uint16Vector,
                                             SparseIndexVector_Uint8Vector};
  return values;
}

inline const char *const *EnumNamesSparseIndexVector()
{
  static const char *const names[5] = {"NONE", "Int32Vector", "Uint16Vector", "Uint8Vector",
                                       nullptr};
  return names;
}

inline const char *EnumNameSparseIndexVector(SparseIndexVector e)
{
  if (::flatbuffers::IsOutRange(e, SparseIndexVector_NONE, SparseIndexVector_Uint8Vector))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSparseIndexVector()[index];
}

template <typename T> struct SparseIndexVectorTraits
{
  static const SparseIndexVector enum_value = SparseIndexVector_NONE;
};

template <> struct SparseIndexVectorTraits<circle::Int32Vector>
{
  static const SparseIndexVector enum_value = SparseIndexVector_Int32Vector;
};

template <> struct SparseIndexVectorTraits<circle::Uint16Vector>
{
  static const SparseIndexVector enum_value = SparseIndexVector_Uint16Vector;
};

template <> struct SparseIndexVectorTraits<circle::Uint8Vector>
{
  static const SparseIndexVector enum_value = SparseIndexVector_Uint8Vector;
};

bool VerifySparseIndexVector(::flatbuffers::Verifier &verifier, const void *obj,
                             SparseIndexVector type);
bool VerifySparseIndexVectorVector(::flatbuffers::Verifier &verifier,
                                   const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
                                   const ::flatbuffers::Vector<uint8_t> *types);

enum BuiltinOperator : int32_t
{
  BuiltinOperator_GRU = -5,
  BuiltinOperator_BCQ_GATHER = -4,
  BuiltinOperator_BCQ_FULLY_CONNECTED = -3,
  BuiltinOperator_INSTANCE_NORM = -2,
  BuiltinOperator_ADD = 0,
  BuiltinOperator_AVERAGE_POOL_2D = 1,
  BuiltinOperator_CONCATENATION = 2,
  BuiltinOperator_CONV_2D = 3,
  BuiltinOperator_DEPTHWISE_CONV_2D = 4,
  BuiltinOperator_DEPTH_TO_SPACE = 5,
  BuiltinOperator_DEQUANTIZE = 6,
  BuiltinOperator_EMBEDDING_LOOKUP = 7,
  BuiltinOperator_FLOOR = 8,
  BuiltinOperator_FULLY_CONNECTED = 9,
  BuiltinOperator_HASHTABLE_LOOKUP = 10,
  BuiltinOperator_L2_NORMALIZATION = 11,
  BuiltinOperator_L2_POOL_2D = 12,
  BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
  BuiltinOperator_LOGISTIC = 14,
  BuiltinOperator_LSH_PROJECTION = 15,
  BuiltinOperator_LSTM = 16,
  BuiltinOperator_MAX_POOL_2D = 17,
  BuiltinOperator_MUL = 18,
  BuiltinOperator_RELU = 19,
  BuiltinOperator_RELU_N1_TO_1 = 20,
  BuiltinOperator_RELU6 = 21,
  BuiltinOperator_RESHAPE = 22,
  BuiltinOperator_RESIZE_BILINEAR = 23,
  BuiltinOperator_RNN = 24,
  BuiltinOperator_SOFTMAX = 25,
  BuiltinOperator_SPACE_TO_DEPTH = 26,
  BuiltinOperator_SVDF = 27,
  BuiltinOperator_TANH = 28,
  BuiltinOperator_CONCAT_EMBEDDINGS = 29,
  BuiltinOperator_SKIP_GRAM = 30,
  BuiltinOperator_CALL = 31,
  BuiltinOperator_CUSTOM = 32,
  BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
  BuiltinOperator_PAD = 34,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
  BuiltinOperator_GATHER = 36,
  BuiltinOperator_BATCH_TO_SPACE_ND = 37,
  BuiltinOperator_SPACE_TO_BATCH_ND = 38,
  BuiltinOperator_TRANSPOSE = 39,
  BuiltinOperator_MEAN = 40,
  BuiltinOperator_SUB = 41,
  BuiltinOperator_DIV = 42,
  BuiltinOperator_SQUEEZE = 43,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
  BuiltinOperator_STRIDED_SLICE = 45,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
  BuiltinOperator_EXP = 47,
  BuiltinOperator_TOPK_V2 = 48,
  BuiltinOperator_SPLIT = 49,
  BuiltinOperator_LOG_SOFTMAX = 50,
  BuiltinOperator_DELEGATE = 51,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
  BuiltinOperator_CAST = 53,
  BuiltinOperator_PRELU = 54,
  BuiltinOperator_MAXIMUM = 55,
  BuiltinOperator_ARG_MAX = 56,
  BuiltinOperator_MINIMUM = 57,
  BuiltinOperator_LESS = 58,
  BuiltinOperator_NEG = 59,
  BuiltinOperator_PADV2 = 60,
  BuiltinOperator_GREATER = 61,
  BuiltinOperator_GREATER_EQUAL = 62,
  BuiltinOperator_LESS_EQUAL = 63,
  BuiltinOperator_SELECT = 64,
  BuiltinOperator_SLICE = 65,
  BuiltinOperator_SIN = 66,
  BuiltinOperator_TRANSPOSE_CONV = 67,
  BuiltinOperator_SPARSE_TO_DENSE = 68,
  BuiltinOperator_TILE = 69,
  BuiltinOperator_EXPAND_DIMS = 70,
  BuiltinOperator_EQUAL = 71,
  BuiltinOperator_NOT_EQUAL = 72,
  BuiltinOperator_LOG = 73,
  BuiltinOperator_SUM = 74,
  BuiltinOperator_SQRT = 75,
  BuiltinOperator_RSQRT = 76,
  BuiltinOperator_SHAPE = 77,
  BuiltinOperator_POW = 78,
  BuiltinOperator_ARG_MIN = 79,
  BuiltinOperator_FAKE_QUANT = 80,
  BuiltinOperator_REDUCE_PROD = 81,
  BuiltinOperator_REDUCE_MAX = 82,
  BuiltinOperator_PACK = 83,
  BuiltinOperator_LOGICAL_OR = 84,
  BuiltinOperator_ONE_HOT = 85,
  BuiltinOperator_LOGICAL_AND = 86,
  BuiltinOperator_LOGICAL_NOT = 87,
  BuiltinOperator_UNPACK = 88,
  BuiltinOperator_REDUCE_MIN = 89,
  BuiltinOperator_FLOOR_DIV = 90,
  BuiltinOperator_REDUCE_ANY = 91,
  BuiltinOperator_SQUARE = 92,
  BuiltinOperator_ZEROS_LIKE = 93,
  BuiltinOperator_FILL = 94,
  BuiltinOperator_FLOOR_MOD = 95,
  BuiltinOperator_RANGE = 96,
  BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
  BuiltinOperator_LEAKY_RELU = 98,
  BuiltinOperator_SQUARED_DIFFERENCE = 99,
  BuiltinOperator_MIRROR_PAD = 100,
  BuiltinOperator_ABS = 101,
  BuiltinOperator_SPLIT_V = 102,
  BuiltinOperator_UNIQUE = 103,
  BuiltinOperator_CEIL = 104,
  BuiltinOperator_REVERSE_V2 = 105,
  BuiltinOperator_ADD_N = 106,
  BuiltinOperator_GATHER_ND = 107,
  BuiltinOperator_COS = 108,
  BuiltinOperator_WHERE = 109,
  BuiltinOperator_RANK = 110,
  BuiltinOperator_ELU = 111,
  BuiltinOperator_REVERSE_SEQUENCE = 112,
  BuiltinOperator_MATRIX_DIAG = 113,
  BuiltinOperator_QUANTIZE = 114,
  BuiltinOperator_MATRIX_SET_DIAG = 115,
  BuiltinOperator_ROUND = 116,
  BuiltinOperator_HARD_SWISH = 117,
  BuiltinOperator_IF = 118,
  BuiltinOperator_WHILE = 119,
  BuiltinOperator_NON_MAX_SUPPRESSION_V4 = 120,
  BuiltinOperator_NON_MAX_SUPPRESSION_V5 = 121,
  BuiltinOperator_SCATTER_ND = 122,
  BuiltinOperator_SELECT_V2 = 123,
  BuiltinOperator_DENSIFY = 124,
  BuiltinOperator_SEGMENT_SUM = 125,
  BuiltinOperator_BATCH_MATMUL = 126,
  BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES = 127,
  BuiltinOperator_CUMSUM = 128,
  BuiltinOperator_CALL_ONCE = 129,
  BuiltinOperator_BROADCAST_TO = 130,
  BuiltinOperator_RFFT2D = 131,
  BuiltinOperator_CONV_3D = 132,
  BuiltinOperator_IMAG = 133,
  BuiltinOperator_REAL = 134,
  BuiltinOperator_COMPLEX_ABS = 135,
  BuiltinOperator_HASHTABLE = 136,
  BuiltinOperator_HASHTABLE_FIND = 137,
  BuiltinOperator_HASHTABLE_IMPORT = 138,
  BuiltinOperator_HASHTABLE_SIZE = 139,
  BuiltinOperator_REDUCE_ALL = 140,
  BuiltinOperator_CONV_3D_TRANSPOSE = 141,
  BuiltinOperator_VAR_HANDLE = 142,
  BuiltinOperator_READ_VARIABLE = 143,
  BuiltinOperator_ASSIGN_VARIABLE = 144,
  BuiltinOperator_BROADCAST_ARGS = 145,
  BuiltinOperator_RANDOM_STANDARD_NORMAL = 146,
  BuiltinOperator_BUCKETIZE = 147,
  BuiltinOperator_RANDOM_UNIFORM = 148,
  BuiltinOperator_MULTINOMIAL = 149,
  BuiltinOperator_GELU = 150,
  BuiltinOperator_DYNAMIC_UPDATE_SLICE = 151,
  BuiltinOperator_RELU_0_TO_1 = 152,
  BuiltinOperator_UNSORTED_SEGMENT_PROD = 153,
  BuiltinOperator_UNSORTED_SEGMENT_MAX = 154,
  BuiltinOperator_UNSORTED_SEGMENT_SUM = 155,
  BuiltinOperator_ATAN2 = 156,
  BuiltinOperator_UNSORTED_SEGMENT_MIN = 157,
  BuiltinOperator_SIGN = 158,
  BuiltinOperator_BITCAST = 159,
  BuiltinOperator_BITWISE_XOR = 160,
  BuiltinOperator_RIGHT_SHIFT = 161,
  BuiltinOperator_STABLEHLO_LOGISTIC = 162,
  BuiltinOperator_STABLEHLO_ADD = 163,
  BuiltinOperator_STABLEHLO_DIVIDE = 164,
  BuiltinOperator_STABLEHLO_MULTIPLY = 165,
  BuiltinOperator_STABLEHLO_MAXIMUM = 166,
  BuiltinOperator_STABLEHLO_RESHAPE = 167,
  BuiltinOperator_STABLEHLO_CLAMP = 168,
  BuiltinOperator_STABLEHLO_CONCATENATE = 169,
  BuiltinOperator_STABLEHLO_BROADCAST_IN_DIM = 170,
  BuiltinOperator_STABLEHLO_CONVOLUTION = 171,
  BuiltinOperator_STABLEHLO_SLICE = 172,
  BuiltinOperator_STABLEHLO_CUSTOM_CALL = 173,
  BuiltinOperator_STABLEHLO_REDUCE = 174,
  BuiltinOperator_STABLEHLO_ABS = 175,
  BuiltinOperator_STABLEHLO_AND = 176,
  BuiltinOperator_STABLEHLO_COSINE = 177,
  BuiltinOperator_STABLEHLO_EXPONENTIAL = 178,
  BuiltinOperator_STABLEHLO_FLOOR = 179,
  BuiltinOperator_STABLEHLO_LOG = 180,
  BuiltinOperator_STABLEHLO_MINIMUM = 181,
  BuiltinOperator_STABLEHLO_NEGATE = 182,
  BuiltinOperator_STABLEHLO_OR = 183,
  BuiltinOperator_STABLEHLO_POWER = 184,
  BuiltinOperator_STABLEHLO_REMAINDER = 185,
  BuiltinOperator_STABLEHLO_RSQRT = 186,
  BuiltinOperator_STABLEHLO_SELECT = 187,
  BuiltinOperator_STABLEHLO_SUBTRACT = 188,
  BuiltinOperator_STABLEHLO_TANH = 189,
  BuiltinOperator_STABLEHLO_SCATTER = 190,
  BuiltinOperator_STABLEHLO_COMPARE = 191,
  BuiltinOperator_STABLEHLO_CONVERT = 192,
  BuiltinOperator_STABLEHLO_DYNAMIC_SLICE = 193,
  BuiltinOperator_STABLEHLO_DYNAMIC_UPDATE_SLICE = 194,
  BuiltinOperator_STABLEHLO_PAD = 195,
  BuiltinOperator_STABLEHLO_IOTA = 196,
  BuiltinOperator_STABLEHLO_DOT_GENERAL = 197,
  BuiltinOperator_STABLEHLO_REDUCE_WINDOW = 198,
  BuiltinOperator_STABLEHLO_SORT = 199,
  BuiltinOperator_STABLEHLO_WHILE = 200,
  BuiltinOperator_STABLEHLO_GATHER = 201,
  BuiltinOperator_STABLEHLO_TRANSPOSE = 202,
  BuiltinOperator_DILATE = 203,
  BuiltinOperator_STABLEHLO_RNG_BIT_GENERATOR = 204,
  BuiltinOperator_REDUCE_WINDOW = 205,
  BuiltinOperator_MIN = BuiltinOperator_GRU,
  BuiltinOperator_MAX = BuiltinOperator_REDUCE_WINDOW
};

inline const BuiltinOperator (&EnumValuesBuiltinOperator())[210]
{
  static const BuiltinOperator values[] = {BuiltinOperator_GRU,
                                           BuiltinOperator_BCQ_GATHER,
                                           BuiltinOperator_BCQ_FULLY_CONNECTED,
                                           BuiltinOperator_INSTANCE_NORM,
                                           BuiltinOperator_ADD,
                                           BuiltinOperator_AVERAGE_POOL_2D,
                                           BuiltinOperator_CONCATENATION,
                                           BuiltinOperator_CONV_2D,
                                           BuiltinOperator_DEPTHWISE_CONV_2D,
                                           BuiltinOperator_DEPTH_TO_SPACE,
                                           BuiltinOperator_DEQUANTIZE,
                                           BuiltinOperator_EMBEDDING_LOOKUP,
                                           BuiltinOperator_FLOOR,
                                           BuiltinOperator_FULLY_CONNECTED,
                                           BuiltinOperator_HASHTABLE_LOOKUP,
                                           BuiltinOperator_L2_NORMALIZATION,
                                           BuiltinOperator_L2_POOL_2D,
                                           BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION,
                                           BuiltinOperator_LOGISTIC,
                                           BuiltinOperator_LSH_PROJECTION,
                                           BuiltinOperator_LSTM,
                                           BuiltinOperator_MAX_POOL_2D,
                                           BuiltinOperator_MUL,
                                           BuiltinOperator_RELU,
                                           BuiltinOperator_RELU_N1_TO_1,
                                           BuiltinOperator_RELU6,
                                           BuiltinOperator_RESHAPE,
                                           BuiltinOperator_RESIZE_BILINEAR,
                                           BuiltinOperator_RNN,
                                           BuiltinOperator_SOFTMAX,
                                           BuiltinOperator_SPACE_TO_DEPTH,
                                           BuiltinOperator_SVDF,
                                           BuiltinOperator_TANH,
                                           BuiltinOperator_CONCAT_EMBEDDINGS,
                                           BuiltinOperator_SKIP_GRAM,
                                           BuiltinOperator_CALL,
                                           BuiltinOperator_CUSTOM,
                                           BuiltinOperator_EMBEDDING_LOOKUP_SPARSE,
                                           BuiltinOperator_PAD,
                                           BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN,
                                           BuiltinOperator_GATHER,
                                           BuiltinOperator_BATCH_TO_SPACE_ND,
                                           BuiltinOperator_SPACE_TO_BATCH_ND,
                                           BuiltinOperator_TRANSPOSE,
                                           BuiltinOperator_MEAN,
                                           BuiltinOperator_SUB,
                                           BuiltinOperator_DIV,
                                           BuiltinOperator_SQUEEZE,
                                           BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
                                           BuiltinOperator_STRIDED_SLICE,
                                           BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN,
                                           BuiltinOperator_EXP,
                                           BuiltinOperator_TOPK_V2,
                                           BuiltinOperator_SPLIT,
                                           BuiltinOperator_LOG_SOFTMAX,
                                           BuiltinOperator_DELEGATE,
                                           BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM,
                                           BuiltinOperator_CAST,
                                           BuiltinOperator_PRELU,
                                           BuiltinOperator_MAXIMUM,
                                           BuiltinOperator_ARG_MAX,
                                           BuiltinOperator_MINIMUM,
                                           BuiltinOperator_LESS,
                                           BuiltinOperator_NEG,
                                           BuiltinOperator_PADV2,
                                           BuiltinOperator_GREATER,
                                           BuiltinOperator_GREATER_EQUAL,
                                           BuiltinOperator_LESS_EQUAL,
                                           BuiltinOperator_SELECT,
                                           BuiltinOperator_SLICE,
                                           BuiltinOperator_SIN,
                                           BuiltinOperator_TRANSPOSE_CONV,
                                           BuiltinOperator_SPARSE_TO_DENSE,
                                           BuiltinOperator_TILE,
                                           BuiltinOperator_EXPAND_DIMS,
                                           BuiltinOperator_EQUAL,
                                           BuiltinOperator_NOT_EQUAL,
                                           BuiltinOperator_LOG,
                                           BuiltinOperator_SUM,
                                           BuiltinOperator_SQRT,
                                           BuiltinOperator_RSQRT,
                                           BuiltinOperator_SHAPE,
                                           BuiltinOperator_POW,
                                           BuiltinOperator_ARG_MIN,
                                           BuiltinOperator_FAKE_QUANT,
                                           BuiltinOperator_REDUCE_PROD,
                                           BuiltinOperator_REDUCE_MAX,
                                           BuiltinOperator_PACK,
                                           BuiltinOperator_LOGICAL_OR,
                                           BuiltinOperator_ONE_HOT,
                                           BuiltinOperator_LOGICAL_AND,
                                           BuiltinOperator_LOGICAL_NOT,
                                           BuiltinOperator_UNPACK,
                                           BuiltinOperator_REDUCE_MIN,
                                           BuiltinOperator_FLOOR_DIV,
                                           BuiltinOperator_REDUCE_ANY,
                                           BuiltinOperator_SQUARE,
                                           BuiltinOperator_ZEROS_LIKE,
                                           BuiltinOperator_FILL,
                                           BuiltinOperator_FLOOR_MOD,
                                           BuiltinOperator_RANGE,
                                           BuiltinOperator_RESIZE_NEAREST_NEIGHBOR,
                                           BuiltinOperator_LEAKY_RELU,
                                           BuiltinOperator_SQUARED_DIFFERENCE,
                                           BuiltinOperator_MIRROR_PAD,
                                           BuiltinOperator_ABS,
                                           BuiltinOperator_SPLIT_V,
                                           BuiltinOperator_UNIQUE,
                                           BuiltinOperator_CEIL,
                                           BuiltinOperator_REVERSE_V2,
                                           BuiltinOperator_ADD_N,
                                           BuiltinOperator_GATHER_ND,
                                           BuiltinOperator_COS,
                                           BuiltinOperator_WHERE,
                                           BuiltinOperator_RANK,
                                           BuiltinOperator_ELU,
                                           BuiltinOperator_REVERSE_SEQUENCE,
                                           BuiltinOperator_MATRIX_DIAG,
                                           BuiltinOperator_QUANTIZE,
                                           BuiltinOperator_MATRIX_SET_DIAG,
                                           BuiltinOperator_ROUND,
                                           BuiltinOperator_HARD_SWISH,
                                           BuiltinOperator_IF,
                                           BuiltinOperator_WHILE,
                                           BuiltinOperator_NON_MAX_SUPPRESSION_V4,
                                           BuiltinOperator_NON_MAX_SUPPRESSION_V5,
                                           BuiltinOperator_SCATTER_ND,
                                           BuiltinOperator_SELECT_V2,
                                           BuiltinOperator_DENSIFY,
                                           BuiltinOperator_SEGMENT_SUM,
                                           BuiltinOperator_BATCH_MATMUL,
                                           BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES,
                                           BuiltinOperator_CUMSUM,
                                           BuiltinOperator_CALL_ONCE,
                                           BuiltinOperator_BROADCAST_TO,
                                           BuiltinOperator_RFFT2D,
                                           BuiltinOperator_CONV_3D,
                                           BuiltinOperator_IMAG,
                                           BuiltinOperator_REAL,
                                           BuiltinOperator_COMPLEX_ABS,
                                           BuiltinOperator_HASHTABLE,
                                           BuiltinOperator_HASHTABLE_FIND,
                                           BuiltinOperator_HASHTABLE_IMPORT,
                                           BuiltinOperator_HASHTABLE_SIZE,
                                           BuiltinOperator_REDUCE_ALL,
                                           BuiltinOperator_CONV_3D_TRANSPOSE,
                                           BuiltinOperator_VAR_HANDLE,
                                           BuiltinOperator_READ_VARIABLE,
                                           BuiltinOperator_ASSIGN_VARIABLE,
                                           BuiltinOperator_BROADCAST_ARGS,
                                           BuiltinOperator_RANDOM_STANDARD_NORMAL,
                                           BuiltinOperator_BUCKETIZE,
                                           BuiltinOperator_RANDOM_UNIFORM,
                                           BuiltinOperator_MULTINOMIAL,
                                           BuiltinOperator_GELU,
                                           BuiltinOperator_DYNAMIC_UPDATE_SLICE,
                                           BuiltinOperator_RELU_0_TO_1,
                                           BuiltinOperator_UNSORTED_SEGMENT_PROD,
                                           BuiltinOperator_UNSORTED_SEGMENT_MAX,
                                           BuiltinOperator_UNSORTED_SEGMENT_SUM,
                                           BuiltinOperator_ATAN2,
                                           BuiltinOperator_UNSORTED_SEGMENT_MIN,
                                           BuiltinOperator_SIGN,
                                           BuiltinOperator_BITCAST,
                                           BuiltinOperator_BITWISE_XOR,
                                           BuiltinOperator_RIGHT_SHIFT,
                                           BuiltinOperator_STABLEHLO_LOGISTIC,
                                           BuiltinOperator_STABLEHLO_ADD,
                                           BuiltinOperator_STABLEHLO_DIVIDE,
                                           BuiltinOperator_STABLEHLO_MULTIPLY,
                                           BuiltinOperator_STABLEHLO_MAXIMUM,
                                           BuiltinOperator_STABLEHLO_RESHAPE,
                                           BuiltinOperator_STABLEHLO_CLAMP,
                                           BuiltinOperator_STABLEHLO_CONCATENATE,
                                           BuiltinOperator_STABLEHLO_BROADCAST_IN_DIM,
                                           BuiltinOperator_STABLEHLO_CONVOLUTION,
                                           BuiltinOperator_STABLEHLO_SLICE,
                                           BuiltinOperator_STABLEHLO_CUSTOM_CALL,
                                           BuiltinOperator_STABLEHLO_REDUCE,
                                           BuiltinOperator_STABLEHLO_ABS,
                                           BuiltinOperator_STABLEHLO_AND,
                                           BuiltinOperator_STABLEHLO_COSINE,
                                           BuiltinOperator_STABLEHLO_EXPONENTIAL,
                                           BuiltinOperator_STABLEHLO_FLOOR,
                                           BuiltinOperator_STABLEHLO_LOG,
                                           BuiltinOperator_STABLEHLO_MINIMUM,
                                           BuiltinOperator_STABLEHLO_NEGATE,
                                           BuiltinOperator_STABLEHLO_OR,
                                           BuiltinOperator_STABLEHLO_POWER,
                                           BuiltinOperator_STABLEHLO_REMAINDER,
                                           BuiltinOperator_STABLEHLO_RSQRT,
                                           BuiltinOperator_STABLEHLO_SELECT,
                                           BuiltinOperator_STABLEHLO_SUBTRACT,
                                           BuiltinOperator_STABLEHLO_TANH,
                                           BuiltinOperator_STABLEHLO_SCATTER,
                                           BuiltinOperator_STABLEHLO_COMPARE,
                                           BuiltinOperator_STABLEHLO_CONVERT,
                                           BuiltinOperator_STABLEHLO_DYNAMIC_SLICE,
                                           BuiltinOperator_STABLEHLO_DYNAMIC_UPDATE_SLICE,
                                           BuiltinOperator_STABLEHLO_PAD,
                                           BuiltinOperator_STABLEHLO_IOTA,
                                           BuiltinOperator_STABLEHLO_DOT_GENERAL,
                                           BuiltinOperator_STABLEHLO_REDUCE_WINDOW,
                                           BuiltinOperator_STABLEHLO_SORT,
                                           BuiltinOperator_STABLEHLO_WHILE,
                                           BuiltinOperator_STABLEHLO_GATHER,
                                           BuiltinOperator_STABLEHLO_TRANSPOSE,
                                           BuiltinOperator_DILATE,
                                           BuiltinOperator_STABLEHLO_RNG_BIT_GENERATOR,
                                           BuiltinOperator_REDUCE_WINDOW};
  return values;
}

inline const char *const *EnumNamesBuiltinOperator()
{
  static const char *const names[212] = {"GRU",
                                         "BCQ_GATHER",
                                         "BCQ_FULLY_CONNECTED",
                                         "INSTANCE_NORM",
                                         "",
                                         "ADD",
                                         "AVERAGE_POOL_2D",
                                         "CONCATENATION",
                                         "CONV_2D",
                                         "DEPTHWISE_CONV_2D",
                                         "DEPTH_TO_SPACE",
                                         "DEQUANTIZE",
                                         "EMBEDDING_LOOKUP",
                                         "FLOOR",
                                         "FULLY_CONNECTED",
                                         "HASHTABLE_LOOKUP",
                                         "L2_NORMALIZATION",
                                         "L2_POOL_2D",
                                         "LOCAL_RESPONSE_NORMALIZATION",
                                         "LOGISTIC",
                                         "LSH_PROJECTION",
                                         "LSTM",
                                         "MAX_POOL_2D",
                                         "MUL",
                                         "RELU",
                                         "RELU_N1_TO_1",
                                         "RELU6",
                                         "RESHAPE",
                                         "RESIZE_BILINEAR",
                                         "RNN",
                                         "SOFTMAX",
                                         "SPACE_TO_DEPTH",
                                         "SVDF",
                                         "TANH",
                                         "CONCAT_EMBEDDINGS",
                                         "SKIP_GRAM",
                                         "CALL",
                                         "CUSTOM",
                                         "EMBEDDING_LOOKUP_SPARSE",
                                         "PAD",
                                         "UNIDIRECTIONAL_SEQUENCE_RNN",
                                         "GATHER",
                                         "BATCH_TO_SPACE_ND",
                                         "SPACE_TO_BATCH_ND",
                                         "TRANSPOSE",
                                         "MEAN",
                                         "SUB",
                                         "DIV",
                                         "SQUEEZE",
                                         "UNIDIRECTIONAL_SEQUENCE_LSTM",
                                         "STRIDED_SLICE",
                                         "BIDIRECTIONAL_SEQUENCE_RNN",
                                         "EXP",
                                         "TOPK_V2",
                                         "SPLIT",
                                         "LOG_SOFTMAX",
                                         "DELEGATE",
                                         "BIDIRECTIONAL_SEQUENCE_LSTM",
                                         "CAST",
                                         "PRELU",
                                         "MAXIMUM",
                                         "ARG_MAX",
                                         "MINIMUM",
                                         "LESS",
                                         "NEG",
                                         "PADV2",
                                         "GREATER",
                                         "GREATER_EQUAL",
                                         "LESS_EQUAL",
                                         "SELECT",
                                         "SLICE",
                                         "SIN",
                                         "TRANSPOSE_CONV",
                                         "SPARSE_TO_DENSE",
                                         "TILE",
                                         "EXPAND_DIMS",
                                         "EQUAL",
                                         "NOT_EQUAL",
                                         "LOG",
                                         "SUM",
                                         "SQRT",
                                         "RSQRT",
                                         "SHAPE",
                                         "POW",
                                         "ARG_MIN",
                                         "FAKE_QUANT",
                                         "REDUCE_PROD",
                                         "REDUCE_MAX",
                                         "PACK",
                                         "LOGICAL_OR",
                                         "ONE_HOT",
                                         "LOGICAL_AND",
                                         "LOGICAL_NOT",
                                         "UNPACK",
                                         "REDUCE_MIN",
                                         "FLOOR_DIV",
                                         "REDUCE_ANY",
                                         "SQUARE",
                                         "ZEROS_LIKE",
                                         "FILL",
                                         "FLOOR_MOD",
                                         "RANGE",
                                         "RESIZE_NEAREST_NEIGHBOR",
                                         "LEAKY_RELU",
                                         "SQUARED_DIFFERENCE",
                                         "MIRROR_PAD",
                                         "ABS",
                                         "SPLIT_V",
                                         "UNIQUE",
                                         "CEIL",
                                         "REVERSE_V2",
                                         "ADD_N",
                                         "GATHER_ND",
                                         "COS",
                                         "WHERE",
                                         "RANK",
                                         "ELU",
                                         "REVERSE_SEQUENCE",
                                         "MATRIX_DIAG",
                                         "QUANTIZE",
                                         "MATRIX_SET_DIAG",
                                         "ROUND",
                                         "HARD_SWISH",
                                         "IF",
                                         "WHILE",
                                         "NON_MAX_SUPPRESSION_V4",
                                         "NON_MAX_SUPPRESSION_V5",
                                         "SCATTER_ND",
                                         "SELECT_V2",
                                         "DENSIFY",
                                         "SEGMENT_SUM",
                                         "BATCH_MATMUL",
                                         "PLACEHOLDER_FOR_GREATER_OP_CODES",
                                         "CUMSUM",
                                         "CALL_ONCE",
                                         "BROADCAST_TO",
                                         "RFFT2D",
                                         "CONV_3D",
                                         "IMAG",
                                         "REAL",
                                         "COMPLEX_ABS",
                                         "HASHTABLE",
                                         "HASHTABLE_FIND",
                                         "HASHTABLE_IMPORT",
                                         "HASHTABLE_SIZE",
                                         "REDUCE_ALL",
                                         "CONV_3D_TRANSPOSE",
                                         "VAR_HANDLE",
                                         "READ_VARIABLE",
                                         "ASSIGN_VARIABLE",
                                         "BROADCAST_ARGS",
                                         "RANDOM_STANDARD_NORMAL",
                                         "BUCKETIZE",
                                         "RANDOM_UNIFORM",
                                         "MULTINOMIAL",
                                         "GELU",
                                         "DYNAMIC_UPDATE_SLICE",
                                         "RELU_0_TO_1",
                                         "UNSORTED_SEGMENT_PROD",
                                         "UNSORTED_SEGMENT_MAX",
                                         "UNSORTED_SEGMENT_SUM",
                                         "ATAN2",
                                         "UNSORTED_SEGMENT_MIN",
                                         "SIGN",
                                         "BITCAST",
                                         "BITWISE_XOR",
                                         "RIGHT_SHIFT",
                                         "STABLEHLO_LOGISTIC",
                                         "STABLEHLO_ADD",
                                         "STABLEHLO_DIVIDE",
                                         "STABLEHLO_MULTIPLY",
                                         "STABLEHLO_MAXIMUM",
                                         "STABLEHLO_RESHAPE",
                                         "STABLEHLO_CLAMP",
                                         "STABLEHLO_CONCATENATE",
                                         "STABLEHLO_BROADCAST_IN_DIM",
                                         "STABLEHLO_CONVOLUTION",
                                         "STABLEHLO_SLICE",
                                         "STABLEHLO_CUSTOM_CALL",
                                         "STABLEHLO_REDUCE",
                                         "STABLEHLO_ABS",
                                         "STABLEHLO_AND",
                                         "STABLEHLO_COSINE",
                                         "STABLEHLO_EXPONENTIAL",
                                         "STABLEHLO_FLOOR",
                                         "STABLEHLO_LOG",
                                         "STABLEHLO_MINIMUM",
                                         "STABLEHLO_NEGATE",
                                         "STABLEHLO_OR",
                                         "STABLEHLO_POWER",
                                         "STABLEHLO_REMAINDER",
                                         "STABLEHLO_RSQRT",
                                         "STABLEHLO_SELECT",
                                         "STABLEHLO_SUBTRACT",
                                         "STABLEHLO_TANH",
                                         "STABLEHLO_SCATTER",
                                         "STABLEHLO_COMPARE",
                                         "STABLEHLO_CONVERT",
                                         "STABLEHLO_DYNAMIC_SLICE",
                                         "STABLEHLO_DYNAMIC_UPDATE_SLICE",
                                         "STABLEHLO_PAD",
                                         "STABLEHLO_IOTA",
                                         "STABLEHLO_DOT_GENERAL",
                                         "STABLEHLO_REDUCE_WINDOW",
                                         "STABLEHLO_SORT",
                                         "STABLEHLO_WHILE",
                                         "STABLEHLO_GATHER",
                                         "STABLEHLO_TRANSPOSE",
                                         "DILATE",
                                         "STABLEHLO_RNG_BIT_GENERATOR",
                                         "REDUCE_WINDOW",
                                         nullptr};
  return names;
}

inline const char *EnumNameBuiltinOperator(BuiltinOperator e)
{
  if (::flatbuffers::IsOutRange(e, BuiltinOperator_GRU, BuiltinOperator_REDUCE_WINDOW))
    return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(BuiltinOperator_GRU);
  return EnumNamesBuiltinOperator()[index];
}

enum BuiltinOptions : uint8_t
{
  BuiltinOptions_NONE = 0,
  BuiltinOptions_Conv2DOptions = 1,
  BuiltinOptions_DepthwiseConv2DOptions = 2,
  BuiltinOptions_ConcatEmbeddingsOptions = 3,
  BuiltinOptions_LSHProjectionOptions = 4,
  BuiltinOptions_Pool2DOptions = 5,
  BuiltinOptions_SVDFOptions = 6,
  BuiltinOptions_RNNOptions = 7,
  BuiltinOptions_FullyConnectedOptions = 8,
  BuiltinOptions_SoftmaxOptions = 9,
  BuiltinOptions_ConcatenationOptions = 10,
  BuiltinOptions_AddOptions = 11,
  BuiltinOptions_L2NormOptions = 12,
  BuiltinOptions_LocalResponseNormalizationOptions = 13,
  BuiltinOptions_LSTMOptions = 14,
  BuiltinOptions_ResizeBilinearOptions = 15,
  BuiltinOptions_CallOptions = 16,
  BuiltinOptions_ReshapeOptions = 17,
  BuiltinOptions_SkipGramOptions = 18,
  BuiltinOptions_SpaceToDepthOptions = 19,
  BuiltinOptions_EmbeddingLookupSparseOptions = 20,
  BuiltinOptions_MulOptions = 21,
  BuiltinOptions_PadOptions = 22,
  BuiltinOptions_GatherOptions = 23,
  BuiltinOptions_BatchToSpaceNDOptions = 24,
  BuiltinOptions_SpaceToBatchNDOptions = 25,
  BuiltinOptions_TransposeOptions = 26,
  BuiltinOptions_ReducerOptions = 27,
  BuiltinOptions_SubOptions = 28,
  BuiltinOptions_DivOptions = 29,
  BuiltinOptions_SqueezeOptions = 30,
  BuiltinOptions_SequenceRNNOptions = 31,
  BuiltinOptions_StridedSliceOptions = 32,
  BuiltinOptions_ExpOptions = 33,
  BuiltinOptions_TopKV2Options = 34,
  BuiltinOptions_SplitOptions = 35,
  BuiltinOptions_LogSoftmaxOptions = 36,
  BuiltinOptions_CastOptions = 37,
  BuiltinOptions_DequantizeOptions = 38,
  BuiltinOptions_MaximumMinimumOptions = 39,
  BuiltinOptions_ArgMaxOptions = 40,
  BuiltinOptions_LessOptions = 41,
  BuiltinOptions_NegOptions = 42,
  BuiltinOptions_PadV2Options = 43,
  BuiltinOptions_GreaterOptions = 44,
  BuiltinOptions_GreaterEqualOptions = 45,
  BuiltinOptions_LessEqualOptions = 46,
  BuiltinOptions_SelectOptions = 47,
  BuiltinOptions_SliceOptions = 48,
  BuiltinOptions_TransposeConvOptions = 49,
  BuiltinOptions_SparseToDenseOptions = 50,
  BuiltinOptions_TileOptions = 51,
  BuiltinOptions_ExpandDimsOptions = 52,
  BuiltinOptions_EqualOptions = 53,
  BuiltinOptions_NotEqualOptions = 54,
  BuiltinOptions_ShapeOptions = 55,
  BuiltinOptions_PowOptions = 56,
  BuiltinOptions_ArgMinOptions = 57,
  BuiltinOptions_FakeQuantOptions = 58,
  BuiltinOptions_PackOptions = 59,
  BuiltinOptions_LogicalOrOptions = 60,
  BuiltinOptions_OneHotOptions = 61,
  BuiltinOptions_LogicalAndOptions = 62,
  BuiltinOptions_LogicalNotOptions = 63,
  BuiltinOptions_UnpackOptions = 64,
  BuiltinOptions_FloorDivOptions = 65,
  BuiltinOptions_SquareOptions = 66,
  BuiltinOptions_ZerosLikeOptions = 67,
  BuiltinOptions_FillOptions = 68,
  BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
  BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
  BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
  BuiltinOptions_FloorModOptions = 72,
  BuiltinOptions_RangeOptions = 73,
  BuiltinOptions_ResizeNearestNeighborOptions = 74,
  BuiltinOptions_LeakyReluOptions = 75,
  BuiltinOptions_SquaredDifferenceOptions = 76,
  BuiltinOptions_MirrorPadOptions = 77,
  BuiltinOptions_AbsOptions = 78,
  BuiltinOptions_SplitVOptions = 79,
  BuiltinOptions_UniqueOptions = 80,
  BuiltinOptions_ReverseV2Options = 81,
  BuiltinOptions_AddNOptions = 82,
  BuiltinOptions_GatherNdOptions = 83,
  BuiltinOptions_CosOptions = 84,
  BuiltinOptions_WhereOptions = 85,
  BuiltinOptions_RankOptions = 86,
  BuiltinOptions_ReverseSequenceOptions = 87,
  BuiltinOptions_MatrixDiagOptions = 88,
  BuiltinOptions_QuantizeOptions = 89,
  BuiltinOptions_MatrixSetDiagOptions = 90,
  BuiltinOptions_HardSwishOptions = 91,
  BuiltinOptions_IfOptions = 92,
  BuiltinOptions_WhileOptions = 93,
  BuiltinOptions_DepthToSpaceOptions = 94,
  BuiltinOptions_NonMaxSuppressionV4Options = 95,
  BuiltinOptions_NonMaxSuppressionV5Options = 96,
  BuiltinOptions_ScatterNdOptions = 97,
  BuiltinOptions_SelectV2Options = 98,
  BuiltinOptions_DensifyOptions = 99,
  BuiltinOptions_SegmentSumOptions = 100,
  BuiltinOptions_BatchMatMulOptions = 101,
  BuiltinOptions_CumsumOptions = 102,
  BuiltinOptions_CallOnceOptions = 103,
  BuiltinOptions_BroadcastToOptions = 104,
  BuiltinOptions_Rfft2dOptions = 105,
  BuiltinOptions_Conv3DOptions = 106,
  BuiltinOptions_HashtableOptions = 107,
  BuiltinOptions_HashtableFindOptions = 108,
  BuiltinOptions_HashtableImportOptions = 109,
  BuiltinOptions_HashtableSizeOptions = 110,
  BuiltinOptions_VarHandleOptions = 111,
  BuiltinOptions_ReadVariableOptions = 112,
  BuiltinOptions_AssignVariableOptions = 113,
  BuiltinOptions_RandomOptions = 114,
  BuiltinOptions_BucketizeOptions = 115,
  BuiltinOptions_GeluOptions = 116,
  BuiltinOptions_DynamicUpdateSliceOptions = 117,
  BuiltinOptions_UnsortedSegmentProdOptions = 118,
  BuiltinOptions_UnsortedSegmentMaxOptions = 119,
  BuiltinOptions_UnsortedSegmentMinOptions = 120,
  BuiltinOptions_UnsortedSegmentSumOptions = 121,
  BuiltinOptions_ATan2Options = 122,
  BuiltinOptions_SignOptions = 123,
  BuiltinOptions_BitcastOptions = 124,
  BuiltinOptions_BitwiseXorOptions = 125,
  BuiltinOptions_RightShiftOptions = 126,
  BuiltinOptions_GRUOptions = 251,
  BuiltinOptions_BCQGatherOptions = 252,
  BuiltinOptions_BCQFullyConnectedOptions = 253,
  BuiltinOptions_InstanceNormOptions = 254,
  BuiltinOptions_MIN = BuiltinOptions_NONE,
  BuiltinOptions_MAX = BuiltinOptions_InstanceNormOptions
};

inline const BuiltinOptions (&EnumValuesBuiltinOptions())[131]
{
  static const BuiltinOptions values[] = {BuiltinOptions_NONE,
                                          BuiltinOptions_Conv2DOptions,
                                          BuiltinOptions_DepthwiseConv2DOptions,
                                          BuiltinOptions_ConcatEmbeddingsOptions,
                                          BuiltinOptions_LSHProjectionOptions,
                                          BuiltinOptions_Pool2DOptions,
                                          BuiltinOptions_SVDFOptions,
                                          BuiltinOptions_RNNOptions,
                                          BuiltinOptions_FullyConnectedOptions,
                                          BuiltinOptions_SoftmaxOptions,
                                          BuiltinOptions_ConcatenationOptions,
                                          BuiltinOptions_AddOptions,
                                          BuiltinOptions_L2NormOptions,
                                          BuiltinOptions_LocalResponseNormalizationOptions,
                                          BuiltinOptions_LSTMOptions,
                                          BuiltinOptions_ResizeBilinearOptions,
                                          BuiltinOptions_CallOptions,
                                          BuiltinOptions_ReshapeOptions,
                                          BuiltinOptions_SkipGramOptions,
                                          BuiltinOptions_SpaceToDepthOptions,
                                          BuiltinOptions_EmbeddingLookupSparseOptions,
                                          BuiltinOptions_MulOptions,
                                          BuiltinOptions_PadOptions,
                                          BuiltinOptions_GatherOptions,
                                          BuiltinOptions_BatchToSpaceNDOptions,
                                          BuiltinOptions_SpaceToBatchNDOptions,
                                          BuiltinOptions_TransposeOptions,
                                          BuiltinOptions_ReducerOptions,
                                          BuiltinOptions_SubOptions,
                                          BuiltinOptions_DivOptions,
                                          BuiltinOptions_SqueezeOptions,
                                          BuiltinOptions_SequenceRNNOptions,
                                          BuiltinOptions_StridedSliceOptions,
                                          BuiltinOptions_ExpOptions,
                                          BuiltinOptions_TopKV2Options,
                                          BuiltinOptions_SplitOptions,
                                          BuiltinOptions_LogSoftmaxOptions,
                                          BuiltinOptions_CastOptions,
                                          BuiltinOptions_DequantizeOptions,
                                          BuiltinOptions_MaximumMinimumOptions,
                                          BuiltinOptions_ArgMaxOptions,
                                          BuiltinOptions_LessOptions,
                                          BuiltinOptions_NegOptions,
                                          BuiltinOptions_PadV2Options,
                                          BuiltinOptions_GreaterOptions,
                                          BuiltinOptions_GreaterEqualOptions,
                                          BuiltinOptions_LessEqualOptions,
                                          BuiltinOptions_SelectOptions,
                                          BuiltinOptions_SliceOptions,
                                          BuiltinOptions_TransposeConvOptions,
                                          BuiltinOptions_SparseToDenseOptions,
                                          BuiltinOptions_TileOptions,
                                          BuiltinOptions_ExpandDimsOptions,
                                          BuiltinOptions_EqualOptions,
                                          BuiltinOptions_NotEqualOptions,
                                          BuiltinOptions_ShapeOptions,
                                          BuiltinOptions_PowOptions,
                                          BuiltinOptions_ArgMinOptions,
                                          BuiltinOptions_FakeQuantOptions,
                                          BuiltinOptions_PackOptions,
                                          BuiltinOptions_LogicalOrOptions,
                                          BuiltinOptions_OneHotOptions,
                                          BuiltinOptions_LogicalAndOptions,
                                          BuiltinOptions_LogicalNotOptions,
                                          BuiltinOptions_UnpackOptions,
                                          BuiltinOptions_FloorDivOptions,
                                          BuiltinOptions_SquareOptions,
                                          BuiltinOptions_ZerosLikeOptions,
                                          BuiltinOptions_FillOptions,
                                          BuiltinOptions_BidirectionalSequenceLSTMOptions,
                                          BuiltinOptions_BidirectionalSequenceRNNOptions,
                                          BuiltinOptions_UnidirectionalSequenceLSTMOptions,
                                          BuiltinOptions_FloorModOptions,
                                          BuiltinOptions_RangeOptions,
                                          BuiltinOptions_ResizeNearestNeighborOptions,
                                          BuiltinOptions_LeakyReluOptions,
                                          BuiltinOptions_SquaredDifferenceOptions,
                                          BuiltinOptions_MirrorPadOptions,
                                          BuiltinOptions_AbsOptions,
                                          BuiltinOptions_SplitVOptions,
                                          BuiltinOptions_UniqueOptions,
                                          BuiltinOptions_ReverseV2Options,
                                          BuiltinOptions_AddNOptions,
                                          BuiltinOptions_GatherNdOptions,
                                          BuiltinOptions_CosOptions,
                                          BuiltinOptions_WhereOptions,
                                          BuiltinOptions_RankOptions,
                                          BuiltinOptions_ReverseSequenceOptions,
                                          BuiltinOptions_MatrixDiagOptions,
                                          BuiltinOptions_QuantizeOptions,
                                          BuiltinOptions_MatrixSetDiagOptions,
                                          BuiltinOptions_HardSwishOptions,
                                          BuiltinOptions_IfOptions,
                                          BuiltinOptions_WhileOptions,
                                          BuiltinOptions_DepthToSpaceOptions,
                                          BuiltinOptions_NonMaxSuppressionV4Options,
                                          BuiltinOptions_NonMaxSuppressionV5Options,
                                          BuiltinOptions_ScatterNdOptions,
                                          BuiltinOptions_SelectV2Options,
                                          BuiltinOptions_DensifyOptions,
                                          BuiltinOptions_SegmentSumOptions,
                                          BuiltinOptions_BatchMatMulOptions,
                                          BuiltinOptions_CumsumOptions,
                                          BuiltinOptions_CallOnceOptions,
                                          BuiltinOptions_BroadcastToOptions,
                                          BuiltinOptions_Rfft2dOptions,
                                          BuiltinOptions_Conv3DOptions,
                                          BuiltinOptions_HashtableOptions,
                                          BuiltinOptions_HashtableFindOptions,
                                          BuiltinOptions_HashtableImportOptions,
                                          BuiltinOptions_HashtableSizeOptions,
                                          BuiltinOptions_VarHandleOptions,
                                          BuiltinOptions_ReadVariableOptions,
                                          BuiltinOptions_AssignVariableOptions,
                                          BuiltinOptions_RandomOptions,
                                          BuiltinOptions_BucketizeOptions,
                                          BuiltinOptions_GeluOptions,
                                          BuiltinOptions_DynamicUpdateSliceOptions,
                                          BuiltinOptions_UnsortedSegmentProdOptions,
                                          BuiltinOptions_UnsortedSegmentMaxOptions,
                                          BuiltinOptions_UnsortedSegmentMinOptions,
                                          BuiltinOptions_UnsortedSegmentSumOptions,
                                          BuiltinOptions_ATan2Options,
                                          BuiltinOptions_SignOptions,
                                          BuiltinOptions_BitcastOptions,
                                          BuiltinOptions_BitwiseXorOptions,
                                          BuiltinOptions_RightShiftOptions,
                                          BuiltinOptions_GRUOptions,
                                          BuiltinOptions_BCQGatherOptions,
                                          BuiltinOptions_BCQFullyConnectedOptions,
                                          BuiltinOptions_InstanceNormOptions};
  return values;
}

inline const char *const *EnumNamesBuiltinOptions()
{
  static const char *const names[256] = {"NONE",
                                         "Conv2DOptions",
                                         "DepthwiseConv2DOptions",
                                         "ConcatEmbeddingsOptions",
                                         "LSHProjectionOptions",
                                         "Pool2DOptions",
                                         "SVDFOptions",
                                         "RNNOptions",
                                         "FullyConnectedOptions",
                                         "SoftmaxOptions",
                                         "ConcatenationOptions",
                                         "AddOptions",
                                         "L2NormOptions",
                                         "LocalResponseNormalizationOptions",
                                         "LSTMOptions",
                                         "ResizeBilinearOptions",
                                         "CallOptions",
                                         "ReshapeOptions",
                                         "SkipGramOptions",
                                         "SpaceToDepthOptions",
                                         "EmbeddingLookupSparseOptions",
                                         "MulOptions",
                                         "PadOptions",
                                         "GatherOptions",
                                         "BatchToSpaceNDOptions",
                                         "SpaceToBatchNDOptions",
                                         "TransposeOptions",
                                         "ReducerOptions",
                                         "SubOptions",
                                         "DivOptions",
                                         "SqueezeOptions",
                                         "SequenceRNNOptions",
                                         "StridedSliceOptions",
                                         "ExpOptions",
                                         "TopKV2Options",
                                         "SplitOptions",
                                         "LogSoftmaxOptions",
                                         "CastOptions",
                                         "DequantizeOptions",
                                         "MaximumMinimumOptions",
                                         "ArgMaxOptions",
                                         "LessOptions",
                                         "NegOptions",
                                         "PadV2Options",
                                         "GreaterOptions",
                                         "GreaterEqualOptions",
                                         "LessEqualOptions",
                                         "SelectOptions",
                                         "SliceOptions",
                                         "TransposeConvOptions",
                                         "SparseToDenseOptions",
                                         "TileOptions",
                                         "ExpandDimsOptions",
                                         "EqualOptions",
                                         "NotEqualOptions",
                                         "ShapeOptions",
                                         "PowOptions",
                                         "ArgMinOptions",
                                         "FakeQuantOptions",
                                         "PackOptions",
                                         "LogicalOrOptions",
                                         "OneHotOptions",
                                         "LogicalAndOptions",
                                         "LogicalNotOptions",
                                         "UnpackOptions",
                                         "FloorDivOptions",
                                         "SquareOptions",
                                         "ZerosLikeOptions",
                                         "FillOptions",
                                         "BidirectionalSequenceLSTMOptions",
                                         "BidirectionalSequenceRNNOptions",
                                         "UnidirectionalSequenceLSTMOptions",
                                         "FloorModOptions",
                                         "RangeOptions",
                                         "ResizeNearestNeighborOptions",
                                         "LeakyReluOptions",
                                         "SquaredDifferenceOptions",
                                         "MirrorPadOptions",
                                         "AbsOptions",
                                         "SplitVOptions",
                                         "UniqueOptions",
                                         "ReverseV2Options",
                                         "AddNOptions",
                                         "GatherNdOptions",
                                         "CosOptions",
                                         "WhereOptions",
                                         "RankOptions",
                                         "ReverseSequenceOptions",
                                         "MatrixDiagOptions",
                                         "QuantizeOptions",
                                         "MatrixSetDiagOptions",
                                         "HardSwishOptions",
                                         "IfOptions",
                                         "WhileOptions",
                                         "DepthToSpaceOptions",
                                         "NonMaxSuppressionV4Options",
                                         "NonMaxSuppressionV5Options",
                                         "ScatterNdOptions",
                                         "SelectV2Options",
                                         "DensifyOptions",
                                         "SegmentSumOptions",
                                         "BatchMatMulOptions",
                                         "CumsumOptions",
                                         "CallOnceOptions",
                                         "BroadcastToOptions",
                                         "Rfft2dOptions",
                                         "Conv3DOptions",
                                         "HashtableOptions",
                                         "HashtableFindOptions",
                                         "HashtableImportOptions",
                                         "HashtableSizeOptions",
                                         "VarHandleOptions",
                                         "ReadVariableOptions",
                                         "AssignVariableOptions",
                                         "RandomOptions",
                                         "BucketizeOptions",
                                         "GeluOptions",
                                         "DynamicUpdateSliceOptions",
                                         "UnsortedSegmentProdOptions",
                                         "UnsortedSegmentMaxOptions",
                                         "UnsortedSegmentMinOptions",
                                         "UnsortedSegmentSumOptions",
                                         "ATan2Options",
                                         "SignOptions",
                                         "BitcastOptions",
                                         "BitwiseXorOptions",
                                         "RightShiftOptions",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "GRUOptions",
                                         "BCQGatherOptions",
                                         "BCQFullyConnectedOptions",
                                         "InstanceNormOptions",
                                         nullptr};
  return names;
}

inline const char *EnumNameBuiltinOptions(BuiltinOptions e)
{
  if (::flatbuffers::IsOutRange(e, BuiltinOptions_NONE, BuiltinOptions_InstanceNormOptions))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOptions()[index];
}

template <typename T> struct BuiltinOptionsTraits
{
  static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template <> struct BuiltinOptionsTraits<circle::Conv2DOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template <> struct BuiltinOptionsTraits<circle::DepthwiseConv2DOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_DepthwiseConv2DOptions;
};

template <> struct BuiltinOptionsTraits<circle::ConcatEmbeddingsOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatEmbeddingsOptions;
};

template <> struct BuiltinOptionsTraits<circle::LSHProjectionOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template <> struct BuiltinOptionsTraits<circle::Pool2DOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template <> struct BuiltinOptionsTraits<circle::SVDFOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template <> struct BuiltinOptionsTraits<circle::RNNOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template <> struct BuiltinOptionsTraits<circle::FullyConnectedOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template <> struct BuiltinOptionsTraits<circle::SoftmaxOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template <> struct BuiltinOptionsTraits<circle::ConcatenationOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template <> struct BuiltinOptionsTraits<circle::AddOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template <> struct BuiltinOptionsTraits<circle::L2NormOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template <> struct BuiltinOptionsTraits<circle::LocalResponseNormalizationOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LocalResponseNormalizationOptions;
};

template <> struct BuiltinOptionsTraits<circle::LSTMOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template <> struct BuiltinOptionsTraits<circle::ResizeBilinearOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template <> struct BuiltinOptionsTraits<circle::CallOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template <> struct BuiltinOptionsTraits<circle::ReshapeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template <> struct BuiltinOptionsTraits<circle::SkipGramOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template <> struct BuiltinOptionsTraits<circle::SpaceToDepthOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template <> struct BuiltinOptionsTraits<circle::EmbeddingLookupSparseOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_EmbeddingLookupSparseOptions;
};

template <> struct BuiltinOptionsTraits<circle::MulOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template <> struct BuiltinOptionsTraits<circle::PadOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template <> struct BuiltinOptionsTraits<circle::GatherOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template <> struct BuiltinOptionsTraits<circle::BatchToSpaceNDOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template <> struct BuiltinOptionsTraits<circle::SpaceToBatchNDOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template <> struct BuiltinOptionsTraits<circle::TransposeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template <> struct BuiltinOptionsTraits<circle::ReducerOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template <> struct BuiltinOptionsTraits<circle::SubOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template <> struct BuiltinOptionsTraits<circle::DivOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template <> struct BuiltinOptionsTraits<circle::SqueezeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template <> struct BuiltinOptionsTraits<circle::SequenceRNNOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template <> struct BuiltinOptionsTraits<circle::StridedSliceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template <> struct BuiltinOptionsTraits<circle::ExpOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template <> struct BuiltinOptionsTraits<circle::TopKV2Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template <> struct BuiltinOptionsTraits<circle::SplitOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template <> struct BuiltinOptionsTraits<circle::LogSoftmaxOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template <> struct BuiltinOptionsTraits<circle::CastOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template <> struct BuiltinOptionsTraits<circle::DequantizeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template <> struct BuiltinOptionsTraits<circle::MaximumMinimumOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template <> struct BuiltinOptionsTraits<circle::ArgMaxOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template <> struct BuiltinOptionsTraits<circle::LessOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template <> struct BuiltinOptionsTraits<circle::NegOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template <> struct BuiltinOptionsTraits<circle::PadV2Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template <> struct BuiltinOptionsTraits<circle::GreaterOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template <> struct BuiltinOptionsTraits<circle::GreaterEqualOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template <> struct BuiltinOptionsTraits<circle::LessEqualOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template <> struct BuiltinOptionsTraits<circle::SelectOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template <> struct BuiltinOptionsTraits<circle::SliceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template <> struct BuiltinOptionsTraits<circle::TransposeConvOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template <> struct BuiltinOptionsTraits<circle::SparseToDenseOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template <> struct BuiltinOptionsTraits<circle::TileOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template <> struct BuiltinOptionsTraits<circle::ExpandDimsOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template <> struct BuiltinOptionsTraits<circle::EqualOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template <> struct BuiltinOptionsTraits<circle::NotEqualOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template <> struct BuiltinOptionsTraits<circle::ShapeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template <> struct BuiltinOptionsTraits<circle::PowOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template <> struct BuiltinOptionsTraits<circle::ArgMinOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template <> struct BuiltinOptionsTraits<circle::FakeQuantOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template <> struct BuiltinOptionsTraits<circle::PackOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template <> struct BuiltinOptionsTraits<circle::LogicalOrOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template <> struct BuiltinOptionsTraits<circle::OneHotOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template <> struct BuiltinOptionsTraits<circle::LogicalAndOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template <> struct BuiltinOptionsTraits<circle::LogicalNotOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template <> struct BuiltinOptionsTraits<circle::UnpackOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template <> struct BuiltinOptionsTraits<circle::FloorDivOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template <> struct BuiltinOptionsTraits<circle::SquareOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template <> struct BuiltinOptionsTraits<circle::ZerosLikeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template <> struct BuiltinOptionsTraits<circle::FillOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

template <> struct BuiltinOptionsTraits<circle::BidirectionalSequenceLSTMOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceLSTMOptions;
};

template <> struct BuiltinOptionsTraits<circle::BidirectionalSequenceRNNOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceRNNOptions;
};

template <> struct BuiltinOptionsTraits<circle::UnidirectionalSequenceLSTMOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_UnidirectionalSequenceLSTMOptions;
};

template <> struct BuiltinOptionsTraits<circle::FloorModOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_FloorModOptions;
};

template <> struct BuiltinOptionsTraits<circle::RangeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_RangeOptions;
};

template <> struct BuiltinOptionsTraits<circle::ResizeNearestNeighborOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeNearestNeighborOptions;
};

template <> struct BuiltinOptionsTraits<circle::LeakyReluOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LeakyReluOptions;
};

template <> struct BuiltinOptionsTraits<circle::SquaredDifferenceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SquaredDifferenceOptions;
};

template <> struct BuiltinOptionsTraits<circle::MirrorPadOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_MirrorPadOptions;
};

template <> struct BuiltinOptionsTraits<circle::AbsOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_AbsOptions;
};

template <> struct BuiltinOptionsTraits<circle::SplitVOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SplitVOptions;
};

template <> struct BuiltinOptionsTraits<circle::UniqueOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_UniqueOptions;
};

template <> struct BuiltinOptionsTraits<circle::ReverseV2Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseV2Options;
};

template <> struct BuiltinOptionsTraits<circle::AddNOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_AddNOptions;
};

template <> struct BuiltinOptionsTraits<circle::GatherNdOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_GatherNdOptions;
};

template <> struct BuiltinOptionsTraits<circle::CosOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_CosOptions;
};

template <> struct BuiltinOptionsTraits<circle::WhereOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_WhereOptions;
};

template <> struct BuiltinOptionsTraits<circle::RankOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_RankOptions;
};

template <> struct BuiltinOptionsTraits<circle::ReverseSequenceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseSequenceOptions;
};

template <> struct BuiltinOptionsTraits<circle::MatrixDiagOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixDiagOptions;
};

template <> struct BuiltinOptionsTraits<circle::QuantizeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_QuantizeOptions;
};

template <> struct BuiltinOptionsTraits<circle::MatrixSetDiagOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixSetDiagOptions;
};

template <> struct BuiltinOptionsTraits<circle::HardSwishOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_HardSwishOptions;
};

template <> struct BuiltinOptionsTraits<circle::IfOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_IfOptions;
};

template <> struct BuiltinOptionsTraits<circle::WhileOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_WhileOptions;
};

template <> struct BuiltinOptionsTraits<circle::DepthToSpaceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_DepthToSpaceOptions;
};

template <> struct BuiltinOptionsTraits<circle::NonMaxSuppressionV4Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV4Options;
};

template <> struct BuiltinOptionsTraits<circle::NonMaxSuppressionV5Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV5Options;
};

template <> struct BuiltinOptionsTraits<circle::ScatterNdOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ScatterNdOptions;
};

template <> struct BuiltinOptionsTraits<circle::SelectV2Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SelectV2Options;
};

template <> struct BuiltinOptionsTraits<circle::DensifyOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_DensifyOptions;
};

template <> struct BuiltinOptionsTraits<circle::SegmentSumOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SegmentSumOptions;
};

template <> struct BuiltinOptionsTraits<circle::BatchMatMulOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BatchMatMulOptions;
};

template <> struct BuiltinOptionsTraits<circle::CumsumOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_CumsumOptions;
};

template <> struct BuiltinOptionsTraits<circle::CallOnceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_CallOnceOptions;
};

template <> struct BuiltinOptionsTraits<circle::BroadcastToOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BroadcastToOptions;
};

template <> struct BuiltinOptionsTraits<circle::Rfft2dOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_Rfft2dOptions;
};

template <> struct BuiltinOptionsTraits<circle::Conv3DOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_Conv3DOptions;
};

template <> struct BuiltinOptionsTraits<circle::HashtableOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableOptions;
};

template <> struct BuiltinOptionsTraits<circle::HashtableFindOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableFindOptions;
};

template <> struct BuiltinOptionsTraits<circle::HashtableImportOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableImportOptions;
};

template <> struct BuiltinOptionsTraits<circle::HashtableSizeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableSizeOptions;
};

template <> struct BuiltinOptionsTraits<circle::VarHandleOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_VarHandleOptions;
};

template <> struct BuiltinOptionsTraits<circle::ReadVariableOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ReadVariableOptions;
};

template <> struct BuiltinOptionsTraits<circle::AssignVariableOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_AssignVariableOptions;
};

template <> struct BuiltinOptionsTraits<circle::RandomOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_RandomOptions;
};

template <> struct BuiltinOptionsTraits<circle::BucketizeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BucketizeOptions;
};

template <> struct BuiltinOptionsTraits<circle::GeluOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_GeluOptions;
};

template <> struct BuiltinOptionsTraits<circle::DynamicUpdateSliceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_DynamicUpdateSliceOptions;
};

template <> struct BuiltinOptionsTraits<circle::UnsortedSegmentProdOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentProdOptions;
};

template <> struct BuiltinOptionsTraits<circle::UnsortedSegmentMaxOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentMaxOptions;
};

template <> struct BuiltinOptionsTraits<circle::UnsortedSegmentMinOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentMinOptions;
};

template <> struct BuiltinOptionsTraits<circle::UnsortedSegmentSumOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentSumOptions;
};

template <> struct BuiltinOptionsTraits<circle::ATan2Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ATan2Options;
};

template <> struct BuiltinOptionsTraits<circle::SignOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SignOptions;
};

template <> struct BuiltinOptionsTraits<circle::BitcastOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BitcastOptions;
};

template <> struct BuiltinOptionsTraits<circle::BitwiseXorOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BitwiseXorOptions;
};

template <> struct BuiltinOptionsTraits<circle::RightShiftOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_RightShiftOptions;
};

template <> struct BuiltinOptionsTraits<circle::GRUOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_GRUOptions;
};

template <> struct BuiltinOptionsTraits<circle::BCQGatherOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BCQGatherOptions;
};

template <> struct BuiltinOptionsTraits<circle::BCQFullyConnectedOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BCQFullyConnectedOptions;
};

template <> struct BuiltinOptionsTraits<circle::InstanceNormOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_InstanceNormOptions;
};

bool VerifyBuiltinOptions(::flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);
bool VerifyBuiltinOptionsVector(::flatbuffers::Verifier &verifier,
                                const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
                                const ::flatbuffers::Vector<uint8_t> *types);

enum BuiltinOptions2 : uint8_t
{
  BuiltinOptions2_NONE = 0,
  BuiltinOptions2_StablehloConcatenateOptions = 1,
  BuiltinOptions2_StablehloBroadcastInDimOptions = 2,
  BuiltinOptions2_StablehloSliceOptions = 3,
  BuiltinOptions2_StablehloConvolutionOptions = 4,
  BuiltinOptions2_StablehloCustomCallOptions = 5,
  BuiltinOptions2_StablehloReduceOptions = 6,
  BuiltinOptions2_StablehloScatterOptions = 7,
  BuiltinOptions2_StablehloCompareOptions = 8,
  BuiltinOptions2_StablehloDynamicSliceOptions = 9,
  BuiltinOptions2_StablehloPadOptions = 10,
  BuiltinOptions2_StablehloIotaOptions = 11,
  BuiltinOptions2_StablehloDotGeneralOptions = 12,
  BuiltinOptions2_StablehloReduceWindowOptions = 13,
  BuiltinOptions2_StablehloSortOptions = 14,
  BuiltinOptions2_StablehloWhileOptions = 15,
  BuiltinOptions2_StablehloGatherOptions = 16,
  BuiltinOptions2_StablehloTransposeOptions = 17,
  BuiltinOptions2_DilateOptions = 18,
  BuiltinOptions2_StablehloRngBitGeneratorOptions = 19,
  BuiltinOptions2_ReduceWindowOptions = 20,
  BuiltinOptions2_MIN = BuiltinOptions2_NONE,
  BuiltinOptions2_MAX = BuiltinOptions2_ReduceWindowOptions
};

inline const BuiltinOptions2 (&EnumValuesBuiltinOptions2())[21]
{
  static const BuiltinOptions2 values[] = {BuiltinOptions2_NONE,
                                           BuiltinOptions2_StablehloConcatenateOptions,
                                           BuiltinOptions2_StablehloBroadcastInDimOptions,
                                           BuiltinOptions2_StablehloSliceOptions,
                                           BuiltinOptions2_StablehloConvolutionOptions,
                                           BuiltinOptions2_StablehloCustomCallOptions,
                                           BuiltinOptions2_StablehloReduceOptions,
                                           BuiltinOptions2_StablehloScatterOptions,
                                           BuiltinOptions2_StablehloCompareOptions,
                                           BuiltinOptions2_StablehloDynamicSliceOptions,
                                           BuiltinOptions2_StablehloPadOptions,
                                           BuiltinOptions2_StablehloIotaOptions,
                                           BuiltinOptions2_StablehloDotGeneralOptions,
                                           BuiltinOptions2_StablehloReduceWindowOptions,
                                           BuiltinOptions2_StablehloSortOptions,
                                           BuiltinOptions2_StablehloWhileOptions,
                                           BuiltinOptions2_StablehloGatherOptions,
                                           BuiltinOptions2_StablehloTransposeOptions,
                                           BuiltinOptions2_DilateOptions,
                                           BuiltinOptions2_StablehloRngBitGeneratorOptions,
                                           BuiltinOptions2_ReduceWindowOptions};
  return values;
}

inline const char *const *EnumNamesBuiltinOptions2()
{
  static const char *const names[22] = {"NONE",
                                        "StablehloConcatenateOptions",
                                        "StablehloBroadcastInDimOptions",
                                        "StablehloSliceOptions",
                                        "StablehloConvolutionOptions",
                                        "StablehloCustomCallOptions",
                                        "StablehloReduceOptions",
                                        "StablehloScatterOptions",
                                        "StablehloCompareOptions",
                                        "StablehloDynamicSliceOptions",
                                        "StablehloPadOptions",
                                        "StablehloIotaOptions",
                                        "StablehloDotGeneralOptions",
                                        "StablehloReduceWindowOptions",
                                        "StablehloSortOptions",
                                        "StablehloWhileOptions",
                                        "StablehloGatherOptions",
                                        "StablehloTransposeOptions",
                                        "DilateOptions",
                                        "StablehloRngBitGeneratorOptions",
                                        "ReduceWindowOptions",
                                        nullptr};
  return names;
}

inline const char *EnumNameBuiltinOptions2(BuiltinOptions2 e)
{
  if (::flatbuffers::IsOutRange(e, BuiltinOptions2_NONE, BuiltinOptions2_ReduceWindowOptions))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOptions2()[index];
}

template <typename T> struct BuiltinOptions2Traits
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_NONE;
};

template <> struct BuiltinOptions2Traits<circle::StablehloConcatenateOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloConcatenateOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloBroadcastInDimOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloBroadcastInDimOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloSliceOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloSliceOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloConvolutionOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloConvolutionOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloCustomCallOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloCustomCallOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloReduceOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloReduceOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloScatterOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloScatterOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloCompareOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloCompareOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloDynamicSliceOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloDynamicSliceOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloPadOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloPadOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloIotaOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloIotaOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloDotGeneralOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloDotGeneralOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloReduceWindowOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloReduceWindowOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloSortOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloSortOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloWhileOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloWhileOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloGatherOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloGatherOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloTransposeOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloTransposeOptions;
};

template <> struct BuiltinOptions2Traits<circle::DilateOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_DilateOptions;
};

template <> struct BuiltinOptions2Traits<circle::StablehloRngBitGeneratorOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloRngBitGeneratorOptions;
};

template <> struct BuiltinOptions2Traits<circle::ReduceWindowOptions>
{
  static const BuiltinOptions2 enum_value = BuiltinOptions2_ReduceWindowOptions;
};

bool VerifyBuiltinOptions2(::flatbuffers::Verifier &verifier, const void *obj,
                           BuiltinOptions2 type);
bool VerifyBuiltinOptions2Vector(::flatbuffers::Verifier &verifier,
                                 const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
                                 const ::flatbuffers::Vector<uint8_t> *types);

enum StablehloPrecisionConfig : uint32_t
{
  StablehloPrecisionConfig_DEFAULT = 0,
  StablehloPrecisionConfig_HIGH = 1,
  StablehloPrecisionConfig_HIGHEST = 2,
  StablehloPrecisionConfig_MIN = StablehloPrecisionConfig_DEFAULT,
  StablehloPrecisionConfig_MAX = StablehloPrecisionConfig_HIGHEST
};

inline const StablehloPrecisionConfig (&EnumValuesStablehloPrecisionConfig())[3]
{
  static const StablehloPrecisionConfig values[] = {StablehloPrecisionConfig_DEFAULT,
                                                    StablehloPrecisionConfig_HIGH,
                                                    StablehloPrecisionConfig_HIGHEST};
  return values;
}

inline const char *const *EnumNamesStablehloPrecisionConfig()
{
  static const char *const names[4] = {"DEFAULT", "HIGH", "HIGHEST", nullptr};
  return names;
}

inline const char *EnumNameStablehloPrecisionConfig(StablehloPrecisionConfig e)
{
  if (::flatbuffers::IsOutRange(e, StablehloPrecisionConfig_DEFAULT,
                                StablehloPrecisionConfig_HIGHEST))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStablehloPrecisionConfig()[index];
}

enum StablehloComparisonDirection : uint32_t
{
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ = 0,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_NE = 1,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GE = 2,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GT = 3,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LE = 4,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT = 5,
  StablehloComparisonDirection_MIN = StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ,
  StablehloComparisonDirection_MAX = StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT
};

inline const StablehloComparisonDirection (&EnumValuesStablehloComparisonDirection())[6]
{
  static const StablehloComparisonDirection values[] = {
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_NE,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GE,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GT,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LE,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT};
  return values;
}

inline const char *const *EnumNamesStablehloComparisonDirection()
{
  static const char *const names[7] = {"STABLEHLO_COMPARISON_DIRECTION_EQ",
                                       "STABLEHLO_COMPARISON_DIRECTION_NE",
                                       "STABLEHLO_COMPARISON_DIRECTION_GE",
                                       "STABLEHLO_COMPARISON_DIRECTION_GT",
                                       "STABLEHLO_COMPARISON_DIRECTION_LE",
                                       "STABLEHLO_COMPARISON_DIRECTION_LT",
                                       nullptr};
  return names;
}

inline const char *EnumNameStablehloComparisonDirection(StablehloComparisonDirection e)
{
  if (::flatbuffers::IsOutRange(e, StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ,
                                StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStablehloComparisonDirection()[index];
}

enum StablehloComparisonType : uint32_t
{
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE = 0,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT = 1,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT_TOTAL_ORDER = 2,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_SIGNED = 3,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED = 4,
  StablehloComparisonType_MIN = StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE,
  StablehloComparisonType_MAX = StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED
};

inline const StablehloComparisonType (&EnumValuesStablehloComparisonType())[5]
{
  static const StablehloComparisonType values[] = {
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT_TOTAL_ORDER,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_SIGNED,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED};
  return values;
}

inline const char *const *EnumNamesStablehloComparisonType()
{
  static const char *const names[6] = {"STABLEHLO_COMPARISON_TYPE_NOTYPE",
                                       "STABLEHLO_COMPARISON_TYPE_FLOAT",
                                       "STABLEHLO_COMPARISON_TYPE_FLOAT_TOTAL_ORDER",
                                       "STABLEHLO_COMPARISON_TYPE_SIGNED",
                                       "STABLEHLO_COMPARISON_TYPE_UNSIGNED",
                                       nullptr};
  return names;
}

inline const char *EnumNameStablehloComparisonType(StablehloComparisonType e)
{
  if (::flatbuffers::IsOutRange(e, StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE,
                                StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStablehloComparisonType()[index];
}

enum RngAlgorithm : int8_t
{
  RngAlgorithm_DEFAULT = 0,
  RngAlgorithm_PHILOX = 1,
  RngAlgorithm_THREEFRY = 2,
  RngAlgorithm_MIN = RngAlgorithm_DEFAULT,
  RngAlgorithm_MAX = RngAlgorithm_THREEFRY
};

inline const RngAlgorithm (&EnumValuesRngAlgorithm())[3]
{
  static const RngAlgorithm values[] = {RngAlgorithm_DEFAULT, RngAlgorithm_PHILOX,
                                        RngAlgorithm_THREEFRY};
  return values;
}

inline const char *const *EnumNamesRngAlgorithm()
{
  static const char *const names[4] = {"DEFAULT", "PHILOX", "THREEFRY", nullptr};
  return names;
}

inline const char *EnumNameRngAlgorithm(RngAlgorithm e)
{
  if (::flatbuffers::IsOutRange(e, RngAlgorithm_DEFAULT, RngAlgorithm_THREEFRY))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRngAlgorithm()[index];
}

enum Padding : int8_t
{
  Padding_SAME = 0,
  Padding_VALID = 1,
  Padding_MIN = Padding_SAME,
  Padding_MAX = Padding_VALID
};

inline const Padding (&EnumValuesPadding())[2]
{
  static const Padding values[] = {Padding_SAME, Padding_VALID};
  return values;
}

inline const char *const *EnumNamesPadding()
{
  static const char *const names[3] = {"SAME", "VALID", nullptr};
  return names;
}

inline const char *EnumNamePadding(Padding e)
{
  if (::flatbuffers::IsOutRange(e, Padding_SAME, Padding_VALID))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadding()[index];
}

enum ActivationFunctionType : int8_t
{
  ActivationFunctionType_NONE = 0,
  ActivationFunctionType_RELU = 1,
  ActivationFunctionType_RELU_N1_TO_1 = 2,
  ActivationFunctionType_RELU6 = 3,
  ActivationFunctionType_TANH = 4,
  ActivationFunctionType_SIGN_BIT = 5,
  ActivationFunctionType_MIN = ActivationFunctionType_NONE,
  ActivationFunctionType_MAX = ActivationFunctionType_SIGN_BIT
};

inline const ActivationFunctionType (&EnumValuesActivationFunctionType())[6]
{
  static const ActivationFunctionType values[] = {
    ActivationFunctionType_NONE,  ActivationFunctionType_RELU, ActivationFunctionType_RELU_N1_TO_1,
    ActivationFunctionType_RELU6, ActivationFunctionType_TANH, ActivationFunctionType_SIGN_BIT};
  return values;
}

inline const char *const *EnumNamesActivationFunctionType()
{
  static const char *const names[7] = {"NONE", "RELU",     "RELU_N1_TO_1", "RELU6",
                                       "TANH", "SIGN_BIT", nullptr};
  return names;
}

inline const char *EnumNameActivationFunctionType(ActivationFunctionType e)
{
  if (::flatbuffers::IsOutRange(e, ActivationFunctionType_NONE, ActivationFunctionType_SIGN_BIT))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationFunctionType()[index];
}

enum LSHProjectionType : int8_t
{
  LSHProjectionType_UNKNOWN = 0,
  LSHProjectionType_SPARSE = 1,
  LSHProjectionType_DENSE = 2,
  LSHProjectionType_MIN = LSHProjectionType_UNKNOWN,
  LSHProjectionType_MAX = LSHProjectionType_DENSE
};

inline const LSHProjectionType (&EnumValuesLSHProjectionType())[3]
{
  static const LSHProjectionType values[] = {LSHProjectionType_UNKNOWN, LSHProjectionType_SPARSE,
                                             LSHProjectionType_DENSE};
  return values;
}

inline const char *const *EnumNamesLSHProjectionType()
{
  static const char *const names[4] = {"UNKNOWN", "SPARSE", "DENSE", nullptr};
  return names;
}

inline const char *EnumNameLSHProjectionType(LSHProjectionType e)
{
  if (::flatbuffers::IsOutRange(e, LSHProjectionType_UNKNOWN, LSHProjectionType_DENSE))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSHProjectionType()[index];
}

enum FullyConnectedOptionsWeightsFormat : int8_t
{
  FullyConnectedOptionsWeightsFormat_DEFAULT = 0,
  FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
  FullyConnectedOptionsWeightsFormat_SHUFFLED16x1FLOAT32 = 127,
  FullyConnectedOptionsWeightsFormat_MIN = FullyConnectedOptionsWeightsFormat_DEFAULT,
  FullyConnectedOptionsWeightsFormat_MAX = FullyConnectedOptionsWeightsFormat_SHUFFLED16x1FLOAT32
};

inline const FullyConnectedOptionsWeightsFormat (&EnumValuesFullyConnectedOptionsWeightsFormat())[3]
{
  static const FullyConnectedOptionsWeightsFormat values[] = {
    FullyConnectedOptionsWeightsFormat_DEFAULT, FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8,
    FullyConnectedOptionsWeightsFormat_SHUFFLED16x1FLOAT32};
  return values;
}

inline const char *EnumNameFullyConnectedOptionsWeightsFormat(FullyConnectedOptionsWeightsFormat e)
{
  switch (e)
  {
    case FullyConnectedOptionsWeightsFormat_DEFAULT:
      return "DEFAULT";
    case FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8:
      return "SHUFFLED4x16INT8";
    case FullyConnectedOptionsWeightsFormat_SHUFFLED16x1FLOAT32:
      return "SHUFFLED16x1FLOAT32";
    default:
      return "";
  }
}

enum LSTMKernelType : int8_t
{
  LSTMKernelType_FULL = 0,
  LSTMKernelType_BASIC = 1,
  LSTMKernelType_MIN = LSTMKernelType_FULL,
  LSTMKernelType_MAX = LSTMKernelType_BASIC
};

inline const LSTMKernelType (&EnumValuesLSTMKernelType())[2]
{
  static const LSTMKernelType values[] = {LSTMKernelType_FULL, LSTMKernelType_BASIC};
  return values;
}

inline const char *const *EnumNamesLSTMKernelType()
{
  static const char *const names[3] = {"FULL", "BASIC", nullptr};
  return names;
}

inline const char *EnumNameLSTMKernelType(LSTMKernelType e)
{
  if (::flatbuffers::IsOutRange(e, LSTMKernelType_FULL, LSTMKernelType_BASIC))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSTMKernelType()[index];
}

enum CombinerType : int8_t
{
  CombinerType_SUM = 0,
  CombinerType_MEAN = 1,
  CombinerType_SQRTN = 2,
  CombinerType_MIN = CombinerType_SUM,
  CombinerType_MAX = CombinerType_SQRTN
};

inline const CombinerType (&EnumValuesCombinerType())[3]
{
  static const CombinerType values[] = {CombinerType_SUM, CombinerType_MEAN, CombinerType_SQRTN};
  return values;
}

inline const char *const *EnumNamesCombinerType()
{
  static const char *const names[4] = {"SUM", "MEAN", "SQRTN", nullptr};
  return names;
}

inline const char *EnumNameCombinerType(CombinerType e)
{
  if (::flatbuffers::IsOutRange(e, CombinerType_SUM, CombinerType_SQRTN))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCombinerType()[index];
}

enum MirrorPadMode : int8_t
{
  MirrorPadMode_REFLECT = 0,
  MirrorPadMode_SYMMETRIC = 1,
  MirrorPadMode_MIN = MirrorPadMode_REFLECT,
  MirrorPadMode_MAX = MirrorPadMode_SYMMETRIC
};

inline const MirrorPadMode (&EnumValuesMirrorPadMode())[2]
{
  static const MirrorPadMode values[] = {MirrorPadMode_REFLECT, MirrorPadMode_SYMMETRIC};
  return values;
}

inline const char *const *EnumNamesMirrorPadMode()
{
  static const char *const names[3] = {"REFLECT", "SYMMETRIC", nullptr};
  return names;
}

inline const char *EnumNameMirrorPadMode(MirrorPadMode e)
{
  if (::flatbuffers::IsOutRange(e, MirrorPadMode_REFLECT, MirrorPadMode_SYMMETRIC))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMirrorPadMode()[index];
}

enum ReduceWindowFunction : int32_t
{
  ReduceWindowFunction_UNSUPPORTED = 0,
  ReduceWindowFunction_ADD = 1,
  ReduceWindowFunction_MUL = 2,
  ReduceWindowFunction_MINIMUM = 3,
  ReduceWindowFunction_MAXIMUM = 4,
  ReduceWindowFunction_ALL = 5,
  ReduceWindowFunction_ANY = 6,
  ReduceWindowFunction_MIN = ReduceWindowFunction_UNSUPPORTED,
  ReduceWindowFunction_MAX = ReduceWindowFunction_ANY
};

inline const ReduceWindowFunction (&EnumValuesReduceWindowFunction())[7]
{
  static const ReduceWindowFunction values[] = {
    ReduceWindowFunction_UNSUPPORTED, ReduceWindowFunction_ADD,     ReduceWindowFunction_MUL,
    ReduceWindowFunction_MINIMUM,     ReduceWindowFunction_MAXIMUM, ReduceWindowFunction_ALL,
    ReduceWindowFunction_ANY};
  return values;
}

inline const char *const *EnumNamesReduceWindowFunction()
{
  static const char *const names[8] = {"UNSUPPORTED", "ADD", "MUL", "MINIMUM",
                                       "MAXIMUM",     "ALL", "ANY", nullptr};
  return names;
}

inline const char *EnumNameReduceWindowFunction(ReduceWindowFunction e)
{
  if (::flatbuffers::IsOutRange(e, ReduceWindowFunction_UNSUPPORTED, ReduceWindowFunction_ANY))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceWindowFunction()[index];
}

enum CustomOptionsFormat : int8_t
{
  CustomOptionsFormat_FLEXBUFFERS = 0,
  CustomOptionsFormat_MIN = CustomOptionsFormat_FLEXBUFFERS,
  CustomOptionsFormat_MAX = CustomOptionsFormat_FLEXBUFFERS
};

inline const CustomOptionsFormat (&EnumValuesCustomOptionsFormat())[1]
{
  static const CustomOptionsFormat values[] = {CustomOptionsFormat_FLEXBUFFERS};
  return values;
}

inline const char *const *EnumNamesCustomOptionsFormat()
{
  static const char *const names[2] = {"FLEXBUFFERS", nullptr};
  return names;
}

inline const char *EnumNameCustomOptionsFormat(CustomOptionsFormat e)
{
  if (::flatbuffers::IsOutRange(e, CustomOptionsFormat_FLEXBUFFERS,
                                CustomOptionsFormat_FLEXBUFFERS))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCustomOptionsFormat()[index];
}

enum DataFormat : int8_t
{
  DataFormat_CHANNELS_LAST = 0,
  DataFormat_CHANNELS_FIRST = 1,
  DataFormat_MIN = DataFormat_CHANNELS_LAST,
  DataFormat_MAX = DataFormat_CHANNELS_FIRST
};

inline const DataFormat (&EnumValuesDataFormat())[2]
{
  static const DataFormat values[] = {DataFormat_CHANNELS_LAST, DataFormat_CHANNELS_FIRST};
  return values;
}

inline const char *const *EnumNamesDataFormat()
{
  static const char *const names[3] = {"CHANNELS_LAST", "CHANNELS_FIRST", nullptr};
  return names;
}

inline const char *EnumNameDataFormat(DataFormat e)
{
  if (::flatbuffers::IsOutRange(e, DataFormat_CHANNELS_LAST, DataFormat_CHANNELS_FIRST))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataFormat()[index];
}

struct CustomQuantization FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef CustomQuantizationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_CUSTOM = 4
  };
  const ::flatbuffers::Vector<uint8_t> *custom() const
  {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CUSTOM) &&
           verifier.VerifyVector(custom()) && verifier.EndTable();
  }
};

struct CustomQuantizationBuilder
{
  typedef CustomQuantization Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_custom(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom)
  {
    fbb_.AddOffset(CustomQuantization::VT_CUSTOM, custom);
  }
  explicit CustomQuantizationBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CustomQuantization> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CustomQuantization>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CustomQuantization>
CreateCustomQuantization(::flatbuffers::FlatBufferBuilder &_fbb,
                         ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom = 0)
{
  CustomQuantizationBuilder builder_(_fbb);
  builder_.add_custom(custom);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CustomQuantization>
CreateCustomQuantizationDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                               const std::vector<uint8_t> *custom = nullptr)
{
  if (custom)
  {
    _fbb.ForceVectorAlignment(custom->size(), sizeof(uint8_t), 16);
  }
  auto custom__ = custom ? _fbb.CreateVector<uint8_t>(*custom) : 0;
  return circle::CreateCustomQuantization(_fbb, custom__);
}

struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef QuantizationParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_SCALE = 8,
    VT_ZERO_POINT = 10,
    VT_DETAILS_TYPE = 12,
    VT_DETAILS = 14,
    VT_QUANTIZED_DIMENSION = 16
  };
  const ::flatbuffers::Vector<float> *min() const
  {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MIN);
  }
  const ::flatbuffers::Vector<float> *max() const
  {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MAX);
  }
  const ::flatbuffers::Vector<float> *scale() const
  {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SCALE);
  }
  const ::flatbuffers::Vector<int64_t> *zero_point() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_ZERO_POINT);
  }
  circle::QuantizationDetails details_type() const
  {
    return static_cast<circle::QuantizationDetails>(GetField<uint8_t>(VT_DETAILS_TYPE, 0));
  }
  const void *details() const { return GetPointer<const void *>(VT_DETAILS); }
  template <typename T> const T *details_as() const;
  const circle::CustomQuantization *details_as_CustomQuantization() const
  {
    return details_type() == circle::QuantizationDetails_CustomQuantization
             ? static_cast<const circle::CustomQuantization *>(details())
             : nullptr;
  }
  int32_t quantized_dimension() const { return GetField<int32_t>(VT_QUANTIZED_DIMENSION, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) && VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) && VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) && VerifyOffset(verifier, VT_ZERO_POINT) &&
           verifier.VerifyVector(zero_point()) &&
           VerifyField<uint8_t>(verifier, VT_DETAILS_TYPE, 1) &&
           VerifyOffset(verifier, VT_DETAILS) &&
           VerifyQuantizationDetails(verifier, details(), details_type()) &&
           VerifyField<int32_t>(verifier, VT_QUANTIZED_DIMENSION, 4) && verifier.EndTable();
  }
};

template <>
inline const circle::CustomQuantization *
QuantizationParameters::details_as<circle::CustomQuantization>() const
{
  return details_as_CustomQuantization();
}

struct QuantizationParametersBuilder
{
  typedef QuantizationParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(::flatbuffers::Offset<::flatbuffers::Vector<float>> min)
  {
    fbb_.AddOffset(QuantizationParameters::VT_MIN, min);
  }
  void add_max(::flatbuffers::Offset<::flatbuffers::Vector<float>> max)
  {
    fbb_.AddOffset(QuantizationParameters::VT_MAX, max);
  }
  void add_scale(::flatbuffers::Offset<::flatbuffers::Vector<float>> scale)
  {
    fbb_.AddOffset(QuantizationParameters::VT_SCALE, scale);
  }
  void add_zero_point(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> zero_point)
  {
    fbb_.AddOffset(QuantizationParameters::VT_ZERO_POINT, zero_point);
  }
  void add_details_type(circle::QuantizationDetails details_type)
  {
    fbb_.AddElement<uint8_t>(QuantizationParameters::VT_DETAILS_TYPE,
                             static_cast<uint8_t>(details_type), 0);
  }
  void add_details(::flatbuffers::Offset<void> details)
  {
    fbb_.AddOffset(QuantizationParameters::VT_DETAILS, details);
  }
  void add_quantized_dimension(int32_t quantized_dimension)
  {
    fbb_.AddElement<int32_t>(QuantizationParameters::VT_QUANTIZED_DIMENSION, quantized_dimension,
                             0);
  }
  explicit QuantizationParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizationParameters> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizationParameters>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<float>> min = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<float>> max = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<float>> scale = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> zero_point = 0,
  circle::QuantizationDetails details_type = circle::QuantizationDetails_NONE,
  ::flatbuffers::Offset<void> details = 0, int32_t quantized_dimension = 0)
{
  QuantizationParametersBuilder builder_(_fbb);
  builder_.add_quantized_dimension(quantized_dimension);
  builder_.add_details(details);
  builder_.add_zero_point(zero_point);
  builder_.add_scale(scale);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_details_type(details_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<float> *min = nullptr,
  const std::vector<float> *max = nullptr, const std::vector<float> *scale = nullptr,
  const std::vector<int64_t> *zero_point = nullptr,
  circle::QuantizationDetails details_type = circle::QuantizationDetails_NONE,
  ::flatbuffers::Offset<void> details = 0, int32_t quantized_dimension = 0)
{
  auto min__ = min ? _fbb.CreateVector<float>(*min) : 0;
  auto max__ = max ? _fbb.CreateVector<float>(*max) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  auto zero_point__ = zero_point ? _fbb.CreateVector<int64_t>(*zero_point) : 0;
  return circle::CreateQuantizationParameters(_fbb, min__, max__, scale__, zero_point__,
                                              details_type, details, quantized_dimension);
}

struct Int32Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef Int32VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<int32_t> *values() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) && verifier.EndTable();
  }
};

struct Int32VectorBuilder
{
  typedef Int32Vector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> values)
  {
    fbb_.AddOffset(Int32Vector::VT_VALUES, values);
  }
  explicit Int32VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int32Vector> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int32Vector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int32Vector>
CreateInt32Vector(::flatbuffers::FlatBufferBuilder &_fbb,
                  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> values = 0)
{
  Int32VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Int32Vector>
CreateInt32VectorDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                        const std::vector<int32_t> *values = nullptr)
{
  auto values__ = values ? _fbb.CreateVector<int32_t>(*values) : 0;
  return circle::CreateInt32Vector(_fbb, values__);
}

struct Uint16Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef Uint16VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<uint16_t> *values() const
  {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) && verifier.EndTable();
  }
};

struct Uint16VectorBuilder
{
  typedef Uint16Vector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> values)
  {
    fbb_.AddOffset(Uint16Vector::VT_VALUES, values);
  }
  explicit Uint16VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Uint16Vector> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Uint16Vector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Uint16Vector>
CreateUint16Vector(::flatbuffers::FlatBufferBuilder &_fbb,
                   ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> values = 0)
{
  Uint16VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Uint16Vector>
CreateUint16VectorDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                         const std::vector<uint16_t> *values = nullptr)
{
  if (values)
  {
    _fbb.ForceVectorAlignment(values->size(), sizeof(uint16_t), 4);
  }
  auto values__ = values ? _fbb.CreateVector<uint16_t>(*values) : 0;
  return circle::CreateUint16Vector(_fbb, values__);
}

struct Uint8Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef Uint8VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<uint8_t> *values() const
  {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) && verifier.EndTable();
  }
};

struct Uint8VectorBuilder
{
  typedef Uint8Vector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values)
  {
    fbb_.AddOffset(Uint8Vector::VT_VALUES, values);
  }
  explicit Uint8VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Uint8Vector> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Uint8Vector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Uint8Vector>
CreateUint8Vector(::flatbuffers::FlatBufferBuilder &_fbb,
                  ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values = 0)
{
  Uint8VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Uint8Vector>
CreateUint8VectorDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                        const std::vector<uint8_t> *values = nullptr)
{
  if (values)
  {
    _fbb.ForceVectorAlignment(values->size(), sizeof(uint8_t), 4);
  }
  auto values__ = values ? _fbb.CreateVector<uint8_t>(*values) : 0;
  return circle::CreateUint8Vector(_fbb, values__);
}

struct DimensionMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef DimensionMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FORMAT = 4,
    VT_DENSE_SIZE = 6,
    VT_ARRAY_SEGMENTS_TYPE = 8,
    VT_ARRAY_SEGMENTS = 10,
    VT_ARRAY_INDICES_TYPE = 12,
    VT_ARRAY_INDICES = 14
  };
  circle::DimensionType format() const
  {
    return static_cast<circle::DimensionType>(GetField<int8_t>(VT_FORMAT, 0));
  }
  int32_t dense_size() const { return GetField<int32_t>(VT_DENSE_SIZE, 0); }
  circle::SparseIndexVector array_segments_type() const
  {
    return static_cast<circle::SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_SEGMENTS_TYPE, 0));
  }
  const void *array_segments() const { return GetPointer<const void *>(VT_ARRAY_SEGMENTS); }
  template <typename T> const T *array_segments_as() const;
  const circle::Int32Vector *array_segments_as_Int32Vector() const
  {
    return array_segments_type() == circle::SparseIndexVector_Int32Vector
             ? static_cast<const circle::Int32Vector *>(array_segments())
             : nullptr;
  }
  const circle::Uint16Vector *array_segments_as_Uint16Vector() const
  {
    return array_segments_type() == circle::SparseIndexVector_Uint16Vector
             ? static_cast<const circle::Uint16Vector *>(array_segments())
             : nullptr;
  }
  const circle::Uint8Vector *array_segments_as_Uint8Vector() const
  {
    return array_segments_type() == circle::SparseIndexVector_Uint8Vector
             ? static_cast<const circle::Uint8Vector *>(array_segments())
             : nullptr;
  }
  circle::SparseIndexVector array_indices_type() const
  {
    return static_cast<circle::SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_INDICES_TYPE, 0));
  }
  const void *array_indices() const { return GetPointer<const void *>(VT_ARRAY_INDICES); }
  template <typename T> const T *array_indices_as() const;
  const circle::Int32Vector *array_indices_as_Int32Vector() const
  {
    return array_indices_type() == circle::SparseIndexVector_Int32Vector
             ? static_cast<const circle::Int32Vector *>(array_indices())
             : nullptr;
  }
  const circle::Uint16Vector *array_indices_as_Uint16Vector() const
  {
    return array_indices_type() == circle::SparseIndexVector_Uint16Vector
             ? static_cast<const circle::Uint16Vector *>(array_indices())
             : nullptr;
  }
  const circle::Uint8Vector *array_indices_as_Uint8Vector() const
  {
    return array_indices_type() == circle::SparseIndexVector_Uint8Vector
             ? static_cast<const circle::Uint8Vector *>(array_indices())
             : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FORMAT, 1) &&
           VerifyField<int32_t>(verifier, VT_DENSE_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_SEGMENTS_TYPE, 1) &&
           VerifyOffset(verifier, VT_ARRAY_SEGMENTS) &&
           VerifySparseIndexVector(verifier, array_segments(), array_segments_type()) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_INDICES_TYPE, 1) &&
           VerifyOffset(verifier, VT_ARRAY_INDICES) &&
           VerifySparseIndexVector(verifier, array_indices(), array_indices_type()) &&
           verifier.EndTable();
  }
};

template <>
inline const circle::Int32Vector *DimensionMetadata::array_segments_as<circle::Int32Vector>() const
{
  return array_segments_as_Int32Vector();
}

template <>
inline const circle::Uint16Vector *
DimensionMetadata::array_segments_as<circle::Uint16Vector>() const
{
  return array_segments_as_Uint16Vector();
}

template <>
inline const circle::Uint8Vector *DimensionMetadata::array_segments_as<circle::Uint8Vector>() const
{
  return array_segments_as_Uint8Vector();
}

template <>
inline const circle::Int32Vector *DimensionMetadata::array_indices_as<circle::Int32Vector>() const
{
  return array_indices_as_Int32Vector();
}

template <>
inline const circle::Uint16Vector *DimensionMetadata::array_indices_as<circle::Uint16Vector>() const
{
  return array_indices_as_Uint16Vector();
}

template <>
inline const circle::Uint8Vector *DimensionMetadata::array_indices_as<circle::Uint8Vector>() const
{
  return array_indices_as_Uint8Vector();
}

struct DimensionMetadataBuilder
{
  typedef DimensionMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_format(circle::DimensionType format)
  {
    fbb_.AddElement<int8_t>(DimensionMetadata::VT_FORMAT, static_cast<int8_t>(format), 0);
  }
  void add_dense_size(int32_t dense_size)
  {
    fbb_.AddElement<int32_t>(DimensionMetadata::VT_DENSE_SIZE, dense_size, 0);
  }
  void add_array_segments_type(circle::SparseIndexVector array_segments_type)
  {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE,
                             static_cast<uint8_t>(array_segments_type), 0);
  }
  void add_array_segments(::flatbuffers::Offset<void> array_segments)
  {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_SEGMENTS, array_segments);
  }
  void add_array_indices_type(circle::SparseIndexVector array_indices_type)
  {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_INDICES_TYPE,
                             static_cast<uint8_t>(array_indices_type), 0);
  }
  void add_array_indices(::flatbuffers::Offset<void> array_indices)
  {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_INDICES, array_indices);
  }
  explicit DimensionMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DimensionMetadata> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DimensionMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::DimensionType format = circle::DimensionType_DENSE, int32_t dense_size = 0,
  circle::SparseIndexVector array_segments_type = circle::SparseIndexVector_NONE,
  ::flatbuffers::Offset<void> array_segments = 0,
  circle::SparseIndexVector array_indices_type = circle::SparseIndexVector_NONE,
  ::flatbuffers::Offset<void> array_indices = 0)
{
  DimensionMetadataBuilder builder_(_fbb);
  builder_.add_array_indices(array_indices);
  builder_.add_array_segments(array_segments);
  builder_.add_dense_size(dense_size);
  builder_.add_array_indices_type(array_indices_type);
  builder_.add_array_segments_type(array_segments_type);
  builder_.add_format(format);
  return builder_.Finish();
}

struct SparsityParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SparsityParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TRAVERSAL_ORDER = 4,
    VT_BLOCK_MAP = 6,
    VT_DIM_METADATA = 8
  };
  const ::flatbuffers::Vector<int32_t> *traversal_order() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TRAVERSAL_ORDER);
  }
  const ::flatbuffers::Vector<int32_t> *block_map() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_BLOCK_MAP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<circle::DimensionMetadata>> *
  dim_metadata() const
  {
    return GetPointer<
      const ::flatbuffers::Vector<::flatbuffers::Offset<circle::DimensionMetadata>> *>(
      VT_DIM_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TRAVERSAL_ORDER) &&
           verifier.VerifyVector(traversal_order()) && VerifyOffset(verifier, VT_BLOCK_MAP) &&
           verifier.VerifyVector(block_map()) && VerifyOffset(verifier, VT_DIM_METADATA) &&
           verifier.VerifyVector(dim_metadata()) && verifier.VerifyVectorOfTables(dim_metadata()) &&
           verifier.EndTable();
  }
};

struct SparsityParametersBuilder
{
  typedef SparsityParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_traversal_order(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> traversal_order)
  {
    fbb_.AddOffset(SparsityParameters::VT_TRAVERSAL_ORDER, traversal_order);
  }
  void add_block_map(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> block_map)
  {
    fbb_.AddOffset(SparsityParameters::VT_BLOCK_MAP, block_map);
  }
  void add_dim_metadata(
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::DimensionMetadata>>>
      dim_metadata)
  {
    fbb_.AddOffset(SparsityParameters::VT_DIM_METADATA, dim_metadata);
  }
  explicit SparsityParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SparsityParameters> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SparsityParameters>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> traversal_order = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> block_map = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::DimensionMetadata>>>
    dim_metadata = 0)
{
  SparsityParametersBuilder builder_(_fbb);
  builder_.add_dim_metadata(dim_metadata);
  builder_.add_block_map(block_map);
  builder_.add_traversal_order(traversal_order);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SparsityParameters> CreateSparsityParametersDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *traversal_order = nullptr,
  const std::vector<int32_t> *block_map = nullptr,
  const std::vector<::flatbuffers::Offset<circle::DimensionMetadata>> *dim_metadata = nullptr)
{
  auto traversal_order__ = traversal_order ? _fbb.CreateVector<int32_t>(*traversal_order) : 0;
  auto block_map__ = block_map ? _fbb.CreateVector<int32_t>(*block_map) : 0;
  auto dim_metadata__ =
    dim_metadata
      ? _fbb.CreateVector<::flatbuffers::Offset<circle::DimensionMetadata>>(*dim_metadata)
      : 0;
  return circle::CreateSparsityParameters(_fbb, traversal_order__, block_map__, dim_metadata__);
}

struct VariantSubType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef VariantSubTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SHAPE = 4,
    VT_TYPE = 6,
    VT_HAS_RANK = 8
  };
  const ::flatbuffers::Vector<int32_t> *shape() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  circle::TensorType type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool has_rank() const { return GetField<uint8_t>(VT_HAS_RANK, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) && VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_HAS_RANK, 1) && verifier.EndTable();
  }
};

struct VariantSubTypeBuilder
{
  typedef VariantSubType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape)
  {
    fbb_.AddOffset(VariantSubType::VT_SHAPE, shape);
  }
  void add_type(circle::TensorType type)
  {
    fbb_.AddElement<int8_t>(VariantSubType::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_has_rank(bool has_rank)
  {
    fbb_.AddElement<uint8_t>(VariantSubType::VT_HAS_RANK, static_cast<uint8_t>(has_rank), 0);
  }
  explicit VariantSubTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VariantSubType> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VariantSubType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VariantSubType>
CreateVariantSubType(::flatbuffers::FlatBufferBuilder &_fbb,
                     ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
                     circle::TensorType type = circle::TensorType_FLOAT32, bool has_rank = false)
{
  VariantSubTypeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_has_rank(has_rank);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VariantSubType> CreateVariantSubTypeDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *shape = nullptr,
  circle::TensorType type = circle::TensorType_FLOAT32, bool has_rank = false)
{
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  return circle::CreateVariantSubType(_fbb, shape__, type, has_rank);
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SHAPE = 4,
    VT_TYPE = 6,
    VT_BUFFER = 8,
    VT_NAME = 10,
    VT_QUANTIZATION = 12,
    VT_IS_VARIABLE = 14,
    VT_SPARSITY = 16,
    VT_SHAPE_SIGNATURE = 18,
    VT_HAS_RANK = 20,
    VT_VARIANT_TENSORS = 22
  };
  const ::flatbuffers::Vector<int32_t> *shape() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  circle::TensorType type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t buffer() const { return GetField<uint32_t>(VT_BUFFER, 0); }
  const ::flatbuffers::String *name() const
  {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const circle::QuantizationParameters *quantization() const
  {
    return GetPointer<const circle::QuantizationParameters *>(VT_QUANTIZATION);
  }
  bool is_variable() const { return GetField<uint8_t>(VT_IS_VARIABLE, 0) != 0; }
  const circle::SparsityParameters *sparsity() const
  {
    return GetPointer<const circle::SparsityParameters *>(VT_SPARSITY);
  }
  const ::flatbuffers::Vector<int32_t> *shape_signature() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE_SIGNATURE);
  }
  bool has_rank() const { return GetField<uint8_t>(VT_HAS_RANK, 0) != 0; }
  const ::flatbuffers::Vector<::flatbuffers::Offset<circle::VariantSubType>> *
  variant_tensors() const
  {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<circle::VariantSubType>> *>(
      VT_VARIANT_TENSORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) && VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER, 4) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) && VerifyOffset(verifier, VT_QUANTIZATION) &&
           verifier.VerifyTable(quantization()) &&
           VerifyField<uint8_t>(verifier, VT_IS_VARIABLE, 1) &&
           VerifyOffset(verifier, VT_SPARSITY) && verifier.VerifyTable(sparsity()) &&
           VerifyOffset(verifier, VT_SHAPE_SIGNATURE) && verifier.VerifyVector(shape_signature()) &&
           VerifyField<uint8_t>(verifier, VT_HAS_RANK, 1) &&
           VerifyOffset(verifier, VT_VARIANT_TENSORS) && verifier.VerifyVector(variant_tensors()) &&
           verifier.VerifyVectorOfTables(variant_tensors()) && verifier.EndTable();
  }
};

struct TensorBuilder
{
  typedef Tensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape)
  {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_type(circle::TensorType type)
  {
    fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_buffer(uint32_t buffer) { fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER, buffer, 0); }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
  {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_quantization(::flatbuffers::Offset<circle::QuantizationParameters> quantization)
  {
    fbb_.AddOffset(Tensor::VT_QUANTIZATION, quantization);
  }
  void add_is_variable(bool is_variable)
  {
    fbb_.AddElement<uint8_t>(Tensor::VT_IS_VARIABLE, static_cast<uint8_t>(is_variable), 0);
  }
  void add_sparsity(::flatbuffers::Offset<circle::SparsityParameters> sparsity)
  {
    fbb_.AddOffset(Tensor::VT_SPARSITY, sparsity);
  }
  void add_shape_signature(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape_signature)
  {
    fbb_.AddOffset(Tensor::VT_SHAPE_SIGNATURE, shape_signature);
  }
  void add_has_rank(bool has_rank)
  {
    fbb_.AddElement<uint8_t>(Tensor::VT_HAS_RANK, static_cast<uint8_t>(has_rank), 0);
  }
  void add_variant_tensors(
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::VariantSubType>>>
      variant_tensors)
  {
    fbb_.AddOffset(Tensor::VT_VARIANT_TENSORS, variant_tensors);
  }
  explicit TensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tensor> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tensor> CreateTensor(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
  circle::TensorType type = circle::TensorType_FLOAT32, uint32_t buffer = 0,
  ::flatbuffers::Offset<::flatbuffers::String> name = 0,
  ::flatbuffers::Offset<circle::QuantizationParameters> quantization = 0, bool is_variable = false,
  ::flatbuffers::Offset<circle::SparsityParameters> sparsity = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape_signature = 0, bool has_rank = false,
  ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::VariantSubType>>>
    variant_tensors = 0)
{
  TensorBuilder builder_(_fbb);
  builder_.add_variant_tensors(variant_tensors);
  builder_.add_shape_signature(shape_signature);
  builder_.add_sparsity(sparsity);
  builder_.add_quantization(quantization);
  builder_.add_name(name);
  builder_.add_buffer(buffer);
  builder_.add_shape(shape);
  builder_.add_has_rank(has_rank);
  builder_.add_is_variable(is_variable);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tensor> CreateTensorDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *shape = nullptr,
  circle::TensorType type = circle::TensorType_FLOAT32, uint32_t buffer = 0,
  const char *name = nullptr,
  ::flatbuffers::Offset<circle::QuantizationParameters> quantization = 0, bool is_variable = false,
  ::flatbuffers::Offset<circle::SparsityParameters> sparsity = 0,
  const std::vector<int32_t> *shape_signature = nullptr, bool has_rank = false,
  const std::vector<::flatbuffers::Offset<circle::VariantSubType>> *variant_tensors = nullptr)
{
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shape_signature__ = shape_signature ? _fbb.CreateVector<int32_t>(*shape_signature) : 0;
  auto variant_tensors__ =
    variant_tensors
      ? _fbb.CreateVector<::flatbuffers::Offset<circle::VariantSubType>>(*variant_tensors)
      : 0;
  return circle::CreateTensor(_fbb, shape__, type, buffer, name__, quantization, is_variable,
                              sparsity, shape_signature__, has_rank, variant_tensors__);
}

struct StablehloGatherOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloGatherOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_OFFSET_DIMS = 4,
    VT_COLLAPSED_SLICE_DIMS = 6,
    VT_START_INDEX_MAP = 8,
    VT_INDEX_VECTOR_DIM = 10,
    VT_SLICE_SIZES = 12,
    VT_INDICES_ARE_SORTED = 14
  };
  const ::flatbuffers::Vector<int64_t> *offset_dims() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_OFFSET_DIMS);
  }
  const ::flatbuffers::Vector<int64_t> *collapsed_slice_dims() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_COLLAPSED_SLICE_DIMS);
  }
  const ::flatbuffers::Vector<int64_t> *start_index_map() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_START_INDEX_MAP);
  }
  int64_t index_vector_dim() const { return GetField<int64_t>(VT_INDEX_VECTOR_DIM, 0); }
  const ::flatbuffers::Vector<int64_t> *slice_sizes() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SLICE_SIZES);
  }
  bool indices_are_sorted() const { return GetField<uint8_t>(VT_INDICES_ARE_SORTED, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_OFFSET_DIMS) &&
           verifier.VerifyVector(offset_dims()) &&
           VerifyOffset(verifier, VT_COLLAPSED_SLICE_DIMS) &&
           verifier.VerifyVector(collapsed_slice_dims()) &&
           VerifyOffset(verifier, VT_START_INDEX_MAP) && verifier.VerifyVector(start_index_map()) &&
           VerifyField<int64_t>(verifier, VT_INDEX_VECTOR_DIM, 8) &&
           VerifyOffset(verifier, VT_SLICE_SIZES) && verifier.VerifyVector(slice_sizes()) &&
           VerifyField<uint8_t>(verifier, VT_INDICES_ARE_SORTED, 1) && verifier.EndTable();
  }
};

struct StablehloGatherOptionsBuilder
{
  typedef StablehloGatherOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_offset_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> offset_dims)
  {
    fbb_.AddOffset(StablehloGatherOptions::VT_OFFSET_DIMS, offset_dims);
  }
  void add_collapsed_slice_dims(
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> collapsed_slice_dims)
  {
    fbb_.AddOffset(StablehloGatherOptions::VT_COLLAPSED_SLICE_DIMS, collapsed_slice_dims);
  }
  void add_start_index_map(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> start_index_map)
  {
    fbb_.AddOffset(StablehloGatherOptions::VT_START_INDEX_MAP, start_index_map);
  }
  void add_index_vector_dim(int64_t index_vector_dim)
  {
    fbb_.AddElement<int64_t>(StablehloGatherOptions::VT_INDEX_VECTOR_DIM, index_vector_dim, 0);
  }
  void add_slice_sizes(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> slice_sizes)
  {
    fbb_.AddOffset(StablehloGatherOptions::VT_SLICE_SIZES, slice_sizes);
  }
  void add_indices_are_sorted(bool indices_are_sorted)
  {
    fbb_.AddElement<uint8_t>(StablehloGatherOptions::VT_INDICES_ARE_SORTED,
                             static_cast<uint8_t>(indices_are_sorted), 0);
  }
  explicit StablehloGatherOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloGatherOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloGatherOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloGatherOptions> CreateStablehloGatherOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> offset_dims = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> collapsed_slice_dims = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> start_index_map = 0,
  int64_t index_vector_dim = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> slice_sizes = 0,
  bool indices_are_sorted = false)
{
  StablehloGatherOptionsBuilder builder_(_fbb);
  builder_.add_index_vector_dim(index_vector_dim);
  builder_.add_slice_sizes(slice_sizes);
  builder_.add_start_index_map(start_index_map);
  builder_.add_collapsed_slice_dims(collapsed_slice_dims);
  builder_.add_offset_dims(offset_dims);
  builder_.add_indices_are_sorted(indices_are_sorted);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloGatherOptions> CreateStablehloGatherOptionsDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int64_t> *offset_dims = nullptr,
  const std::vector<int64_t> *collapsed_slice_dims = nullptr,
  const std::vector<int64_t> *start_index_map = nullptr, int64_t index_vector_dim = 0,
  const std::vector<int64_t> *slice_sizes = nullptr, bool indices_are_sorted = false)
{
  auto offset_dims__ = offset_dims ? _fbb.CreateVector<int64_t>(*offset_dims) : 0;
  auto collapsed_slice_dims__ =
    collapsed_slice_dims ? _fbb.CreateVector<int64_t>(*collapsed_slice_dims) : 0;
  auto start_index_map__ = start_index_map ? _fbb.CreateVector<int64_t>(*start_index_map) : 0;
  auto slice_sizes__ = slice_sizes ? _fbb.CreateVector<int64_t>(*slice_sizes) : 0;
  return circle::CreateStablehloGatherOptions(_fbb, offset_dims__, collapsed_slice_dims__,
                                              start_index_map__, index_vector_dim, slice_sizes__,
                                              indices_are_sorted);
}

struct StablehloTransposeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloTransposeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_PERMUTATION = 4
  };
  const ::flatbuffers::Vector<int64_t> *permutation() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_PERMUTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_PERMUTATION) &&
           verifier.VerifyVector(permutation()) && verifier.EndTable();
  }
};

struct StablehloTransposeOptionsBuilder
{
  typedef StablehloTransposeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_permutation(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> permutation)
  {
    fbb_.AddOffset(StablehloTransposeOptions::VT_PERMUTATION, permutation);
  }
  explicit StablehloTransposeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloTransposeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloTransposeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloTransposeOptions> CreateStablehloTransposeOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> permutation = 0)
{
  StablehloTransposeOptionsBuilder builder_(_fbb);
  builder_.add_permutation(permutation);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloTransposeOptions>
CreateStablehloTransposeOptionsDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                      const std::vector<int64_t> *permutation = nullptr)
{
  auto permutation__ = permutation ? _fbb.CreateVector<int64_t>(*permutation) : 0;
  return circle::CreateStablehloTransposeOptions(_fbb, permutation__);
}

struct StablehloDotGeneralOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloDotGeneralOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_LHS_BATCHING_DIMENSIONS = 4,
    VT_RHS_BATCHING_DIMENSIONS = 6,
    VT_LHS_CONTRACTING_DIMENSIONS = 8,
    VT_RHS_CONTRACTING_DIMENSIONS = 10,
    VT_PRECISION_CONFIG = 12
  };
  const ::flatbuffers::Vector<int64_t> *lhs_batching_dimensions() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_LHS_BATCHING_DIMENSIONS);
  }
  const ::flatbuffers::Vector<int64_t> *rhs_batching_dimensions() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_RHS_BATCHING_DIMENSIONS);
  }
  const ::flatbuffers::Vector<int64_t> *lhs_contracting_dimensions() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_LHS_CONTRACTING_DIMENSIONS);
  }
  const ::flatbuffers::Vector<int64_t> *rhs_contracting_dimensions() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_RHS_CONTRACTING_DIMENSIONS);
  }
  const ::flatbuffers::Vector<uint32_t> *precision_config() const
  {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_PRECISION_CONFIG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_LHS_BATCHING_DIMENSIONS) &&
           verifier.VerifyVector(lhs_batching_dimensions()) &&
           VerifyOffset(verifier, VT_RHS_BATCHING_DIMENSIONS) &&
           verifier.VerifyVector(rhs_batching_dimensions()) &&
           VerifyOffset(verifier, VT_LHS_CONTRACTING_DIMENSIONS) &&
           verifier.VerifyVector(lhs_contracting_dimensions()) &&
           VerifyOffset(verifier, VT_RHS_CONTRACTING_DIMENSIONS) &&
           verifier.VerifyVector(rhs_contracting_dimensions()) &&
           VerifyOffset(verifier, VT_PRECISION_CONFIG) &&
           verifier.VerifyVector(precision_config()) && verifier.EndTable();
  }
};

struct StablehloDotGeneralOptionsBuilder
{
  typedef StablehloDotGeneralOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lhs_batching_dimensions(
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_batching_dimensions)
  {
    fbb_.AddOffset(StablehloDotGeneralOptions::VT_LHS_BATCHING_DIMENSIONS, lhs_batching_dimensions);
  }
  void add_rhs_batching_dimensions(
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_batching_dimensions)
  {
    fbb_.AddOffset(StablehloDotGeneralOptions::VT_RHS_BATCHING_DIMENSIONS, rhs_batching_dimensions);
  }
  void add_lhs_contracting_dimensions(
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_contracting_dimensions)
  {
    fbb_.AddOffset(StablehloDotGeneralOptions::VT_LHS_CONTRACTING_DIMENSIONS,
                   lhs_contracting_dimensions);
  }
  void add_rhs_contracting_dimensions(
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_contracting_dimensions)
  {
    fbb_.AddOffset(StablehloDotGeneralOptions::VT_RHS_CONTRACTING_DIMENSIONS,
                   rhs_contracting_dimensions);
  }
  void add_precision_config(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> precision_config)
  {
    fbb_.AddOffset(StablehloDotGeneralOptions::VT_PRECISION_CONFIG, precision_config);
  }
  explicit StablehloDotGeneralOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloDotGeneralOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloDotGeneralOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloDotGeneralOptions> CreateStablehloDotGeneralOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_batching_dimensions = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_batching_dimensions = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_contracting_dimensions = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_contracting_dimensions = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> precision_config = 0)
{
  StablehloDotGeneralOptionsBuilder builder_(_fbb);
  builder_.add_precision_config(precision_config);
  builder_.add_rhs_contracting_dimensions(rhs_contracting_dimensions);
  builder_.add_lhs_contracting_dimensions(lhs_contracting_dimensions);
  builder_.add_rhs_batching_dimensions(rhs_batching_dimensions);
  builder_.add_lhs_batching_dimensions(lhs_batching_dimensions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloDotGeneralOptions> CreateStablehloDotGeneralOptionsDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  const std::vector<int64_t> *lhs_batching_dimensions = nullptr,
  const std::vector<int64_t> *rhs_batching_dimensions = nullptr,
  const std::vector<int64_t> *lhs_contracting_dimensions = nullptr,
  const std::vector<int64_t> *rhs_contracting_dimensions = nullptr,
  const std::vector<uint32_t> *precision_config = nullptr)
{
  auto lhs_batching_dimensions__ =
    lhs_batching_dimensions ? _fbb.CreateVector<int64_t>(*lhs_batching_dimensions) : 0;
  auto rhs_batching_dimensions__ =
    rhs_batching_dimensions ? _fbb.CreateVector<int64_t>(*rhs_batching_dimensions) : 0;
  auto lhs_contracting_dimensions__ =
    lhs_contracting_dimensions ? _fbb.CreateVector<int64_t>(*lhs_contracting_dimensions) : 0;
  auto rhs_contracting_dimensions__ =
    rhs_contracting_dimensions ? _fbb.CreateVector<int64_t>(*rhs_contracting_dimensions) : 0;
  auto precision_config__ = precision_config ? _fbb.CreateVector<uint32_t>(*precision_config) : 0;
  return circle::CreateStablehloDotGeneralOptions(
    _fbb, lhs_batching_dimensions__, rhs_batching_dimensions__, lhs_contracting_dimensions__,
    rhs_contracting_dimensions__, precision_config__);
}

struct StablehloReduceWindowOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloReduceWindowOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_WINDOW_DIMENSIONS = 4,
    VT_WINDOW_STRIDES = 6,
    VT_BASE_DILATIONS = 8,
    VT_WINDOW_DILATIONS = 10,
    VT_PADDING = 12,
    VT_BODY_SUBGRAPH_INDEX = 14
  };
  const ::flatbuffers::Vector<int64_t> *window_dimensions() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_WINDOW_DIMENSIONS);
  }
  const ::flatbuffers::Vector<int64_t> *window_strides() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_WINDOW_STRIDES);
  }
  const ::flatbuffers::Vector<int64_t> *base_dilations() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_BASE_DILATIONS);
  }
  const ::flatbuffers::Vector<int64_t> *window_dilations() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_WINDOW_DILATIONS);
  }
  const ::flatbuffers::Vector<int64_t> *padding() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_PADDING);
  }
  int32_t body_subgraph_index() const { return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_WINDOW_DIMENSIONS) &&
           verifier.VerifyVector(window_dimensions()) &&
           VerifyOffset(verifier, VT_WINDOW_STRIDES) && verifier.VerifyVector(window_strides()) &&
           VerifyOffset(verifier, VT_BASE_DILATIONS) && verifier.VerifyVector(base_dilations()) &&
           VerifyOffset(verifier, VT_WINDOW_DILATIONS) &&
           verifier.VerifyVector(window_dilations()) && VerifyOffset(verifier, VT_PADDING) &&
           verifier.VerifyVector(padding()) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX, 4) && verifier.EndTable();
  }
};

struct StablehloReduceWindowOptionsBuilder
{
  typedef StablehloReduceWindowOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void
  add_window_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_dimensions)
  {
    fbb_.AddOffset(StablehloReduceWindowOptions::VT_WINDOW_DIMENSIONS, window_dimensions);
  }
  void add_window_strides(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_strides)
  {
    fbb_.AddOffset(StablehloReduceWindowOptions::VT_WINDOW_STRIDES, window_strides);
  }
  void add_base_dilations(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> base_dilations)
  {
    fbb_.AddOffset(StablehloReduceWindowOptions::VT_BASE_DILATIONS, base_dilations);
  }
  void add_window_dilations(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_dilations)
  {
    fbb_.AddOffset(StablehloReduceWindowOptions::VT_WINDOW_DILATIONS, window_dilations);
  }
  void add_padding(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> padding)
  {
    fbb_.AddOffset(StablehloReduceWindowOptions::VT_PADDING, padding);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index)
  {
    fbb_.AddElement<int32_t>(StablehloReduceWindowOptions::VT_BODY_SUBGRAPH_INDEX,
                             body_subgraph_index, 0);
  }
  explicit StablehloReduceWindowOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloReduceWindowOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloReduceWindowOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloReduceWindowOptions> CreateStablehloReduceWindowOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_dimensions = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_strides = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> base_dilations = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_dilations = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> padding = 0,
  int32_t body_subgraph_index = 0)
{
  StablehloReduceWindowOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_padding(padding);
  builder_.add_window_dilations(window_dilations);
  builder_.add_base_dilations(base_dilations);
  builder_.add_window_strides(window_strides);
  builder_.add_window_dimensions(window_dimensions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloReduceWindowOptions> CreateStablehloReduceWindowOptionsDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int64_t> *window_dimensions = nullptr,
  const std::vector<int64_t> *window_strides = nullptr,
  const std::vector<int64_t> *base_dilations = nullptr,
  const std::vector<int64_t> *window_dilations = nullptr,
  const std::vector<int64_t> *padding = nullptr, int32_t body_subgraph_index = 0)
{
  auto window_dimensions__ = window_dimensions ? _fbb.CreateVector<int64_t>(*window_dimensions) : 0;
  auto window_strides__ = window_strides ? _fbb.CreateVector<int64_t>(*window_strides) : 0;
  auto base_dilations__ = base_dilations ? _fbb.CreateVector<int64_t>(*base_dilations) : 0;
  auto window_dilations__ = window_dilations ? _fbb.CreateVector<int64_t>(*window_dilations) : 0;
  auto padding__ = padding ? _fbb.CreateVector<int64_t>(*padding) : 0;
  return circle::CreateStablehloReduceWindowOptions(_fbb, window_dimensions__, window_strides__,
                                                    base_dilations__, window_dilations__, padding__,
                                                    body_subgraph_index);
}

struct StablehloWhileOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloWhileOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_COND_SUBGRAPH_INDEX = 4,
    VT_BODY_SUBGRAPH_INDEX = 6
  };
  int32_t cond_subgraph_index() const { return GetField<int32_t>(VT_COND_SUBGRAPH_INDEX, 0); }
  int32_t body_subgraph_index() const { return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COND_SUBGRAPH_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX, 4) && verifier.EndTable();
  }
};

struct StablehloWhileOptionsBuilder
{
  typedef StablehloWhileOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cond_subgraph_index(int32_t cond_subgraph_index)
  {
    fbb_.AddElement<int32_t>(StablehloWhileOptions::VT_COND_SUBGRAPH_INDEX, cond_subgraph_index, 0);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index)
  {
    fbb_.AddElement<int32_t>(StablehloWhileOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
  }
  explicit StablehloWhileOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloWhileOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloWhileOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloWhileOptions>
CreateStablehloWhileOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t cond_subgraph_index = 0,
                            int32_t body_subgraph_index = 0)
{
  StablehloWhileOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_cond_subgraph_index(cond_subgraph_index);
  return builder_.Finish();
}

struct StablehloSortOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloSortOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_DIMENSION = 4,
    VT_IS_STABLE = 6,
    VT_COMPARATOR_SUBGRAPH_INDEX = 8
  };
  int64_t dimension() const { return GetField<int64_t>(VT_DIMENSION, 0); }
  bool is_stable() const { return GetField<uint8_t>(VT_IS_STABLE, 0) != 0; }
  int32_t comparator_subgraph_index() const
  {
    return GetField<int32_t>(VT_COMPARATOR_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_DIMENSION, 8) &&
           VerifyField<uint8_t>(verifier, VT_IS_STABLE, 1) &&
           VerifyField<int32_t>(verifier, VT_COMPARATOR_SUBGRAPH_INDEX, 4) && verifier.EndTable();
  }
};

struct StablehloSortOptionsBuilder
{
  typedef StablehloSortOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dimension(int64_t dimension)
  {
    fbb_.AddElement<int64_t>(StablehloSortOptions::VT_DIMENSION, dimension, 0);
  }
  void add_is_stable(bool is_stable)
  {
    fbb_.AddElement<uint8_t>(StablehloSortOptions::VT_IS_STABLE, static_cast<uint8_t>(is_stable),
                             0);
  }
  void add_comparator_subgraph_index(int32_t comparator_subgraph_index)
  {
    fbb_.AddElement<int32_t>(StablehloSortOptions::VT_COMPARATOR_SUBGRAPH_INDEX,
                             comparator_subgraph_index, 0);
  }
  explicit StablehloSortOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloSortOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloSortOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloSortOptions>
CreateStablehloSortOptions(::flatbuffers::FlatBufferBuilder &_fbb, int64_t dimension = 0,
                           bool is_stable = false, int32_t comparator_subgraph_index = 0)
{
  StablehloSortOptionsBuilder builder_(_fbb);
  builder_.add_dimension(dimension);
  builder_.add_comparator_subgraph_index(comparator_subgraph_index);
  builder_.add_is_stable(is_stable);
  return builder_.Finish();
}

struct StablehloConcatenateOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloConcatenateOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_DIMENSION = 4
  };
  int64_t dimension() const { return GetField<int64_t>(VT_DIMENSION, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_DIMENSION, 8) &&
           verifier.EndTable();
  }
};

struct StablehloConcatenateOptionsBuilder
{
  typedef StablehloConcatenateOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dimension(int64_t dimension)
  {
    fbb_.AddElement<int64_t>(StablehloConcatenateOptions::VT_DIMENSION, dimension, 0);
  }
  explicit StablehloConcatenateOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloConcatenateOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloConcatenateOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloConcatenateOptions>
CreateStablehloConcatenateOptions(::flatbuffers::FlatBufferBuilder &_fbb, int64_t dimension = 0)
{
  StablehloConcatenateOptionsBuilder builder_(_fbb);
  builder_.add_dimension(dimension);
  return builder_.Finish();
}

struct StablehloBroadcastInDimOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloBroadcastInDimOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_BROADCAST_DIMENSIONS = 4
  };
  const ::flatbuffers::Vector<int64_t> *broadcast_dimensions() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_BROADCAST_DIMENSIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_BROADCAST_DIMENSIONS) &&
           verifier.VerifyVector(broadcast_dimensions()) && verifier.EndTable();
  }
};

struct StablehloBroadcastInDimOptionsBuilder
{
  typedef StablehloBroadcastInDimOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_broadcast_dimensions(
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> broadcast_dimensions)
  {
    fbb_.AddOffset(StablehloBroadcastInDimOptions::VT_BROADCAST_DIMENSIONS, broadcast_dimensions);
  }
  explicit StablehloBroadcastInDimOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
    : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloBroadcastInDimOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloBroadcastInDimOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloBroadcastInDimOptions> CreateStablehloBroadcastInDimOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> broadcast_dimensions = 0)
{
  StablehloBroadcastInDimOptionsBuilder builder_(_fbb);
  builder_.add_broadcast_dimensions(broadcast_dimensions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloBroadcastInDimOptions>
CreateStablehloBroadcastInDimOptionsDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  const std::vector<int64_t> *broadcast_dimensions = nullptr)
{
  auto broadcast_dimensions__ =
    broadcast_dimensions ? _fbb.CreateVector<int64_t>(*broadcast_dimensions) : 0;
  return circle::CreateStablehloBroadcastInDimOptions(_fbb, broadcast_dimensions__);
}

struct StablehloCompareOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloCompareOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_COMPARISON_DIRECTION = 4,
    VT_COMPARE_TYPE = 6
  };
  circle::StablehloComparisonDirection comparison_direction() const
  {
    return static_cast<circle::StablehloComparisonDirection>(
      GetField<uint32_t>(VT_COMPARISON_DIRECTION, 0));
  }
  circle::StablehloComparisonType compare_type() const
  {
    return static_cast<circle::StablehloComparisonType>(GetField<uint32_t>(VT_COMPARE_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COMPARISON_DIRECTION, 4) &&
           VerifyField<uint32_t>(verifier, VT_COMPARE_TYPE, 4) && verifier.EndTable();
  }
};

struct StablehloCompareOptionsBuilder
{
  typedef StablehloCompareOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_comparison_direction(circle::StablehloComparisonDirection comparison_direction)
  {
    fbb_.AddElement<uint32_t>(StablehloCompareOptions::VT_COMPARISON_DIRECTION,
                              static_cast<uint32_t>(comparison_direction), 0);
  }
  void add_compare_type(circle::StablehloComparisonType compare_type)
  {
    fbb_.AddElement<uint32_t>(StablehloCompareOptions::VT_COMPARE_TYPE,
                              static_cast<uint32_t>(compare_type), 0);
  }
  explicit StablehloCompareOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloCompareOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloCompareOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloCompareOptions> CreateStablehloCompareOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::StablehloComparisonDirection comparison_direction =
    circle::StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ,
  circle::StablehloComparisonType compare_type =
    circle::StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE)
{
  StablehloCompareOptionsBuilder builder_(_fbb);
  builder_.add_compare_type(compare_type);
  builder_.add_comparison_direction(comparison_direction);
  return builder_.Finish();
}

struct StablehloDynamicSliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloDynamicSliceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SLICE_SIZES = 4
  };
  const ::flatbuffers::Vector<int64_t> *slice_sizes() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SLICE_SIZES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SLICE_SIZES) &&
           verifier.VerifyVector(slice_sizes()) && verifier.EndTable();
  }
};

struct StablehloDynamicSliceOptionsBuilder
{
  typedef StablehloDynamicSliceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_slice_sizes(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> slice_sizes)
  {
    fbb_.AddOffset(StablehloDynamicSliceOptions::VT_SLICE_SIZES, slice_sizes);
  }
  explicit StablehloDynamicSliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloDynamicSliceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloDynamicSliceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloDynamicSliceOptions> CreateStablehloDynamicSliceOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> slice_sizes = 0)
{
  StablehloDynamicSliceOptionsBuilder builder_(_fbb);
  builder_.add_slice_sizes(slice_sizes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloDynamicSliceOptions>
CreateStablehloDynamicSliceOptionsDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                         const std::vector<int64_t> *slice_sizes = nullptr)
{
  auto slice_sizes__ = slice_sizes ? _fbb.CreateVector<int64_t>(*slice_sizes) : 0;
  return circle::CreateStablehloDynamicSliceOptions(_fbb, slice_sizes__);
}

struct StablehloPadOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloPadOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_EDGE_PADDING_LOW = 4,
    VT_EDGE_PADDING_HIGH = 6,
    VT_INTERIOR_PADDING = 8
  };
  const ::flatbuffers::Vector<int64_t> *edge_padding_low() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_EDGE_PADDING_LOW);
  }
  const ::flatbuffers::Vector<int64_t> *edge_padding_high() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_EDGE_PADDING_HIGH);
  }
  const ::flatbuffers::Vector<int64_t> *interior_padding() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INTERIOR_PADDING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_EDGE_PADDING_LOW) &&
           verifier.VerifyVector(edge_padding_low()) &&
           VerifyOffset(verifier, VT_EDGE_PADDING_HIGH) &&
           verifier.VerifyVector(edge_padding_high()) &&
           VerifyOffset(verifier, VT_INTERIOR_PADDING) &&
           verifier.VerifyVector(interior_padding()) && verifier.EndTable();
  }
};

struct StablehloPadOptionsBuilder
{
  typedef StablehloPadOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_edge_padding_low(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> edge_padding_low)
  {
    fbb_.AddOffset(StablehloPadOptions::VT_EDGE_PADDING_LOW, edge_padding_low);
  }
  void
  add_edge_padding_high(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> edge_padding_high)
  {
    fbb_.AddOffset(StablehloPadOptions::VT_EDGE_PADDING_HIGH, edge_padding_high);
  }
  void add_interior_padding(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> interior_padding)
  {
    fbb_.AddOffset(StablehloPadOptions::VT_INTERIOR_PADDING, interior_padding);
  }
  explicit StablehloPadOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloPadOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloPadOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloPadOptions> CreateStablehloPadOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> edge_padding_low = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> edge_padding_high = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> interior_padding = 0)
{
  StablehloPadOptionsBuilder builder_(_fbb);
  builder_.add_interior_padding(interior_padding);
  builder_.add_edge_padding_high(edge_padding_high);
  builder_.add_edge_padding_low(edge_padding_low);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloPadOptions>
CreateStablehloPadOptionsDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                const std::vector<int64_t> *edge_padding_low = nullptr,
                                const std::vector<int64_t> *edge_padding_high = nullptr,
                                const std::vector<int64_t> *interior_padding = nullptr)
{
  auto edge_padding_low__ = edge_padding_low ? _fbb.CreateVector<int64_t>(*edge_padding_low) : 0;
  auto edge_padding_high__ = edge_padding_high ? _fbb.CreateVector<int64_t>(*edge_padding_high) : 0;
  auto interior_padding__ = interior_padding ? _fbb.CreateVector<int64_t>(*interior_padding) : 0;
  return circle::CreateStablehloPadOptions(_fbb, edge_padding_low__, edge_padding_high__,
                                           interior_padding__);
}

struct StablehloIotaOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloIotaOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_IOTA_DIMENSION = 4
  };
  int64_t iota_dimension() const { return GetField<int64_t>(VT_IOTA_DIMENSION, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_IOTA_DIMENSION, 8) &&
           verifier.EndTable();
  }
};

struct StablehloIotaOptionsBuilder
{
  typedef StablehloIotaOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_iota_dimension(int64_t iota_dimension)
  {
    fbb_.AddElement<int64_t>(StablehloIotaOptions::VT_IOTA_DIMENSION, iota_dimension, 0);
  }
  explicit StablehloIotaOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloIotaOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloIotaOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloIotaOptions>
CreateStablehloIotaOptions(::flatbuffers::FlatBufferBuilder &_fbb, int64_t iota_dimension = 0)
{
  StablehloIotaOptionsBuilder builder_(_fbb);
  builder_.add_iota_dimension(iota_dimension);
  return builder_.Finish();
}

struct StablehloCustomCallOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloCustomCallOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_CALL_TARGET_NAME = 4,
    VT_HAS_SIDE_EFFECT = 6,
    VT_BACKEND_CONFIG = 8,
    VT_API_VERSION = 10,
    VT_CALLED_COMPUTATIONS = 12,
    VT_CUSTOM_ATTRIBUTES = 14
  };
  const ::flatbuffers::String *call_target_name() const
  {
    return GetPointer<const ::flatbuffers::String *>(VT_CALL_TARGET_NAME);
  }
  bool has_side_effect() const { return GetField<uint8_t>(VT_HAS_SIDE_EFFECT, 0) != 0; }
  const ::flatbuffers::String *backend_config() const
  {
    return GetPointer<const ::flatbuffers::String *>(VT_BACKEND_CONFIG);
  }
  int32_t api_version() const { return GetField<int32_t>(VT_API_VERSION, 0); }
  const ::flatbuffers::Vector<int32_t> *called_computations() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_CALLED_COMPUTATIONS);
  }
  const ::flatbuffers::Vector<uint8_t> *custom_attributes() const
  {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_ATTRIBUTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CALL_TARGET_NAME) &&
           verifier.VerifyString(call_target_name()) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SIDE_EFFECT, 1) &&
           VerifyOffset(verifier, VT_BACKEND_CONFIG) && verifier.VerifyString(backend_config()) &&
           VerifyField<int32_t>(verifier, VT_API_VERSION, 4) &&
           VerifyOffset(verifier, VT_CALLED_COMPUTATIONS) &&
           verifier.VerifyVector(called_computations()) &&
           VerifyOffset(verifier, VT_CUSTOM_ATTRIBUTES) &&
           verifier.VerifyVector(custom_attributes()) && verifier.EndTable();
  }
};

struct StablehloCustomCallOptionsBuilder
{
  typedef StablehloCustomCallOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_call_target_name(::flatbuffers::Offset<::flatbuffers::String> call_target_name)
  {
    fbb_.AddOffset(StablehloCustomCallOptions::VT_CALL_TARGET_NAME, call_target_name);
  }
  void add_has_side_effect(bool has_side_effect)
  {
    fbb_.AddElement<uint8_t>(StablehloCustomCallOptions::VT_HAS_SIDE_EFFECT,
                             static_cast<uint8_t>(has_side_effect), 0);
  }
  void add_backend_config(::flatbuffers::Offset<::flatbuffers::String> backend_config)
  {
    fbb_.AddOffset(StablehloCustomCallOptions::VT_BACKEND_CONFIG, backend_config);
  }
  void add_api_version(int32_t api_version)
  {
    fbb_.AddElement<int32_t>(StablehloCustomCallOptions::VT_API_VERSION, api_version, 0);
  }
  void
  add_called_computations(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> called_computations)
  {
    fbb_.AddOffset(StablehloCustomCallOptions::VT_CALLED_COMPUTATIONS, called_computations);
  }
  void
  add_custom_attributes(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom_attributes)
  {
    fbb_.AddOffset(StablehloCustomCallOptions::VT_CUSTOM_ATTRIBUTES, custom_attributes);
  }
  explicit StablehloCustomCallOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloCustomCallOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloCustomCallOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloCustomCallOptions> CreateStablehloCustomCallOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::String> call_target_name = 0, bool has_side_effect = false,
  ::flatbuffers::Offset<::flatbuffers::String> backend_config = 0, int32_t api_version = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> called_computations = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom_attributes = 0)
{
  StablehloCustomCallOptionsBuilder builder_(_fbb);
  builder_.add_custom_attributes(custom_attributes);
  builder_.add_called_computations(called_computations);
  builder_.add_api_version(api_version);
  builder_.add_backend_config(backend_config);
  builder_.add_call_target_name(call_target_name);
  builder_.add_has_side_effect(has_side_effect);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloCustomCallOptions> CreateStablehloCustomCallOptionsDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const char *call_target_name = nullptr,
  bool has_side_effect = false, const char *backend_config = nullptr, int32_t api_version = 0,
  const std::vector<int32_t> *called_computations = nullptr,
  const std::vector<uint8_t> *custom_attributes = nullptr)
{
  auto call_target_name__ = call_target_name ? _fbb.CreateString(call_target_name) : 0;
  auto backend_config__ = backend_config ? _fbb.CreateString(backend_config) : 0;
  auto called_computations__ =
    called_computations ? _fbb.CreateVector<int32_t>(*called_computations) : 0;
  auto custom_attributes__ = custom_attributes ? _fbb.CreateVector<uint8_t>(*custom_attributes) : 0;
  return circle::CreateStablehloCustomCallOptions(_fbb, call_target_name__, has_side_effect,
                                                  backend_config__, api_version,
                                                  called_computations__, custom_attributes__);
}

struct StablehloReduceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloReduceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_DIMENSIONS = 4,
    VT_BODY_SUBGRAPH_INDEX = 6
  };
  const ::flatbuffers::Vector<int64_t> *dimensions() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIMENSIONS);
  }
  int32_t body_subgraph_index() const { return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DIMENSIONS) &&
           verifier.VerifyVector(dimensions()) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX, 4) && verifier.EndTable();
  }
};

struct StablehloReduceOptionsBuilder
{
  typedef StablehloReduceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dimensions)
  {
    fbb_.AddOffset(StablehloReduceOptions::VT_DIMENSIONS, dimensions);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index)
  {
    fbb_.AddElement<int32_t>(StablehloReduceOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index,
                             0);
  }
  explicit StablehloReduceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloReduceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloReduceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloReduceOptions>
CreateStablehloReduceOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                             ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dimensions = 0,
                             int32_t body_subgraph_index = 0)
{
  StablehloReduceOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_dimensions(dimensions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloReduceOptions>
CreateStablehloReduceOptionsDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                   const std::vector<int64_t> *dimensions = nullptr,
                                   int32_t body_subgraph_index = 0)
{
  auto dimensions__ = dimensions ? _fbb.CreateVector<int64_t>(*dimensions) : 0;
  return circle::CreateStablehloReduceOptions(_fbb, dimensions__, body_subgraph_index);
}

struct StablehloSliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloSliceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_START_INDICES = 4,
    VT_LIMIT_INDICES = 6,
    VT_STRIDES = 8
  };
  const ::flatbuffers::Vector<int64_t> *start_indices() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_START_INDICES);
  }
  const ::flatbuffers::Vector<int64_t> *limit_indices() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_LIMIT_INDICES);
  }
  const ::flatbuffers::Vector<int64_t> *strides() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_START_INDICES) &&
           verifier.VerifyVector(start_indices()) && VerifyOffset(verifier, VT_LIMIT_INDICES) &&
           verifier.VerifyVector(limit_indices()) && VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) && verifier.EndTable();
  }
};

struct StablehloSliceOptionsBuilder
{
  typedef StablehloSliceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start_indices(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> start_indices)
  {
    fbb_.AddOffset(StablehloSliceOptions::VT_START_INDICES, start_indices);
  }
  void add_limit_indices(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> limit_indices)
  {
    fbb_.AddOffset(StablehloSliceOptions::VT_LIMIT_INDICES, limit_indices);
  }
  void add_strides(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> strides)
  {
    fbb_.AddOffset(StablehloSliceOptions::VT_STRIDES, strides);
  }
  explicit StablehloSliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloSliceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloSliceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloSliceOptions>
CreateStablehloSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                            ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> start_indices = 0,
                            ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> limit_indices = 0,
                            ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> strides = 0)
{
  StablehloSliceOptionsBuilder builder_(_fbb);
  builder_.add_strides(strides);
  builder_.add_limit_indices(limit_indices);
  builder_.add_start_indices(start_indices);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloSliceOptions>
CreateStablehloSliceOptionsDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                  const std::vector<int64_t> *start_indices = nullptr,
                                  const std::vector<int64_t> *limit_indices = nullptr,
                                  const std::vector<int64_t> *strides = nullptr)
{
  auto start_indices__ = start_indices ? _fbb.CreateVector<int64_t>(*start_indices) : 0;
  auto limit_indices__ = limit_indices ? _fbb.CreateVector<int64_t>(*limit_indices) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
  return circle::CreateStablehloSliceOptions(_fbb, start_indices__, limit_indices__, strides__);
}

struct StablehloConvolutionOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloConvolutionOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_WINDOW_STRIDES = 4,
    VT_PADDING = 6,
    VT_LHS_DILATION = 8,
    VT_RHS_DILATION = 10,
    VT_WINDOW_REVERSAL = 12,
    VT_INPUT_BATCH_DIMENSION = 14,
    VT_INPUT_FEATURE_DIMENSION = 16,
    VT_INPUT_SPATIAL_DIMENSIONS = 18,
    VT_KERNEL_INPUT_FEATURE_DIMENSION = 20,
    VT_KERNEL_OUTPUT_FEATURE_DIMENSION = 22,
    VT_KERNEL_SPATIAL_DIMENSIONS = 24,
    VT_OUTPUT_BATCH_DIMENSION = 26,
    VT_OUTPUT_FEATURE_DIMENSION = 28,
    VT_OUTPUT_SPATIAL_DIMENSIONS = 30,
    VT_FEATURE_GROUP_COUNT = 32,
    VT_BATCH_GROUP_COUNT = 34,
    VT_PRECISION_CONFIG = 36
  };
  const ::flatbuffers::Vector<int64_t> *window_strides() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_WINDOW_STRIDES);
  }
  const ::flatbuffers::Vector<int64_t> *padding() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_PADDING);
  }
  const ::flatbuffers::Vector<int64_t> *lhs_dilation() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_LHS_DILATION);
  }
  const ::flatbuffers::Vector<int64_t> *rhs_dilation() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_RHS_DILATION);
  }
  const ::flatbuffers::Vector<uint8_t> *window_reversal() const
  {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_WINDOW_REVERSAL);
  }
  int64_t input_batch_dimension() const { return GetField<int64_t>(VT_INPUT_BATCH_DIMENSION, 0); }
  int64_t input_feature_dimension() const
  {
    return GetField<int64_t>(VT_INPUT_FEATURE_DIMENSION, 0);
  }
  const ::flatbuffers::Vector<int64_t> *input_spatial_dimensions() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INPUT_SPATIAL_DIMENSIONS);
  }
  int64_t kernel_input_feature_dimension() const
  {
    return GetField<int64_t>(VT_KERNEL_INPUT_FEATURE_DIMENSION, 0);
  }
  int64_t kernel_output_feature_dimension() const
  {
    return GetField<int64_t>(VT_KERNEL_OUTPUT_FEATURE_DIMENSION, 0);
  }
  const ::flatbuffers::Vector<int64_t> *kernel_spatial_dimensions() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_KERNEL_SPATIAL_DIMENSIONS);
  }
  int64_t output_batch_dimension() const { return GetField<int64_t>(VT_OUTPUT_BATCH_DIMENSION, 0); }
  int64_t output_feature_dimension() const
  {
    return GetField<int64_t>(VT_OUTPUT_FEATURE_DIMENSION, 0);
  }
  const ::flatbuffers::Vector<int64_t> *output_spatial_dimensions() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_OUTPUT_SPATIAL_DIMENSIONS);
  }
  int64_t feature_group_count() const { return GetField<int64_t>(VT_FEATURE_GROUP_COUNT, 0); }
  int64_t batch_group_count() const { return GetField<int64_t>(VT_BATCH_GROUP_COUNT, 0); }
  const ::flatbuffers::Vector<uint32_t> *precision_config() const
  {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_PRECISION_CONFIG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_WINDOW_STRIDES) &&
           verifier.VerifyVector(window_strides()) && VerifyOffset(verifier, VT_PADDING) &&
           verifier.VerifyVector(padding()) && VerifyOffset(verifier, VT_LHS_DILATION) &&
           verifier.VerifyVector(lhs_dilation()) && VerifyOffset(verifier, VT_RHS_DILATION) &&
           verifier.VerifyVector(rhs_dilation()) && VerifyOffset(verifier, VT_WINDOW_REVERSAL) &&
           verifier.VerifyVector(window_reversal()) &&
           VerifyField<int64_t>(verifier, VT_INPUT_BATCH_DIMENSION, 8) &&
           VerifyField<int64_t>(verifier, VT_INPUT_FEATURE_DIMENSION, 8) &&
           VerifyOffset(verifier, VT_INPUT_SPATIAL_DIMENSIONS) &&
           verifier.VerifyVector(input_spatial_dimensions()) &&
           VerifyField<int64_t>(verifier, VT_KERNEL_INPUT_FEATURE_DIMENSION, 8) &&
           VerifyField<int64_t>(verifier, VT_KERNEL_OUTPUT_FEATURE_DIMENSION, 8) &&
           VerifyOffset(verifier, VT_KERNEL_SPATIAL_DIMENSIONS) &&
           verifier.VerifyVector(kernel_spatial_dimensions()) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_BATCH_DIMENSION, 8) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_FEATURE_DIMENSION, 8) &&
           VerifyOffset(verifier, VT_OUTPUT_SPATIAL_DIMENSIONS) &&
           verifier.VerifyVector(output_spatial_dimensions()) &&
           VerifyField<int64_t>(verifier, VT_FEATURE_GROUP_COUNT, 8) &&
           VerifyField<int64_t>(verifier, VT_BATCH_GROUP_COUNT, 8) &&
           VerifyOffset(verifier, VT_PRECISION_CONFIG) &&
           verifier.VerifyVector(precision_config()) && verifier.EndTable();
  }
};

struct StablehloConvolutionOptionsBuilder
{
  typedef StablehloConvolutionOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_window_strides(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_strides)
  {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_WINDOW_STRIDES, window_strides);
  }
  void add_padding(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> padding)
  {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_PADDING, padding);
  }
  void add_lhs_dilation(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_dilation)
  {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_LHS_DILATION, lhs_dilation);
  }
  void add_rhs_dilation(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_dilation)
  {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_RHS_DILATION, rhs_dilation);
  }
  void add_window_reversal(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> window_reversal)
  {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_WINDOW_REVERSAL, window_reversal);
  }
  void add_input_batch_dimension(int64_t input_batch_dimension)
  {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_INPUT_BATCH_DIMENSION,
                             input_batch_dimension, 0);
  }
  void add_input_feature_dimension(int64_t input_feature_dimension)
  {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_INPUT_FEATURE_DIMENSION,
                             input_feature_dimension, 0);
  }
  void add_input_spatial_dimensions(
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> input_spatial_dimensions)
  {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_INPUT_SPATIAL_DIMENSIONS,
                   input_spatial_dimensions);
  }
  void add_kernel_input_feature_dimension(int64_t kernel_input_feature_dimension)
  {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_KERNEL_INPUT_FEATURE_DIMENSION,
                             kernel_input_feature_dimension, 0);
  }
  void add_kernel_output_feature_dimension(int64_t kernel_output_feature_dimension)
  {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_KERNEL_OUTPUT_FEATURE_DIMENSION,
                             kernel_output_feature_dimension, 0);
  }
  void add_kernel_spatial_dimensions(
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> kernel_spatial_dimensions)
  {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_KERNEL_SPATIAL_DIMENSIONS,
                   kernel_spatial_dimensions);
  }
  void add_output_batch_dimension(int64_t output_batch_dimension)
  {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_OUTPUT_BATCH_DIMENSION,
                             output_batch_dimension, 0);
  }
  void add_output_feature_dimension(int64_t output_feature_dimension)
  {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_OUTPUT_FEATURE_DIMENSION,
                             output_feature_dimension, 0);
  }
  void add_output_spatial_dimensions(
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> output_spatial_dimensions)
  {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_OUTPUT_SPATIAL_DIMENSIONS,
                   output_spatial_dimensions);
  }
  void add_feature_group_count(int64_t feature_group_count)
  {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_FEATURE_GROUP_COUNT,
                             feature_group_count, 0);
  }
  void add_batch_group_count(int64_t batch_group_count)
  {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_BATCH_GROUP_COUNT, batch_group_count,
                             0);
  }
  void add_precision_config(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> precision_config)
  {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_PRECISION_CONFIG, precision_config);
  }
  explicit StablehloConvolutionOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloConvolutionOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloConvolutionOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloConvolutionOptions> CreateStablehloConvolutionOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_strides = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> padding = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_dilation = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_dilation = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> window_reversal = 0,
  int64_t input_batch_dimension = 0, int64_t input_feature_dimension = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> input_spatial_dimensions = 0,
  int64_t kernel_input_feature_dimension = 0, int64_t kernel_output_feature_dimension = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> kernel_spatial_dimensions = 0,
  int64_t output_batch_dimension = 0, int64_t output_feature_dimension = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> output_spatial_dimensions = 0,
  int64_t feature_group_count = 0, int64_t batch_group_count = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> precision_config = 0)
{
  StablehloConvolutionOptionsBuilder builder_(_fbb);
  builder_.add_batch_group_count(batch_group_count);
  builder_.add_feature_group_count(feature_group_count);
  builder_.add_output_feature_dimension(output_feature_dimension);
  builder_.add_output_batch_dimension(output_batch_dimension);
  builder_.add_kernel_output_feature_dimension(kernel_output_feature_dimension);
  builder_.add_kernel_input_feature_dimension(kernel_input_feature_dimension);
  builder_.add_input_feature_dimension(input_feature_dimension);
  builder_.add_input_batch_dimension(input_batch_dimension);
  builder_.add_precision_config(precision_config);
  builder_.add_output_spatial_dimensions(output_spatial_dimensions);
  builder_.add_kernel_spatial_dimensions(kernel_spatial_dimensions);
  builder_.add_input_spatial_dimensions(input_spatial_dimensions);
  builder_.add_window_reversal(window_reversal);
  builder_.add_rhs_dilation(rhs_dilation);
  builder_.add_lhs_dilation(lhs_dilation);
  builder_.add_padding(padding);
  builder_.add_window_strides(window_strides);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloConvolutionOptions> CreateStablehloConvolutionOptionsDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int64_t> *window_strides = nullptr,
  const std::vector<int64_t> *padding = nullptr, const std::vector<int64_t> *lhs_dilation = nullptr,
  const std::vector<int64_t> *rhs_dilation = nullptr,
  const std::vector<uint8_t> *window_reversal = nullptr, int64_t input_batch_dimension = 0,
  int64_t input_feature_dimension = 0,
  const std::vector<int64_t> *input_spatial_dimensions = nullptr,
  int64_t kernel_input_feature_dimension = 0, int64_t kernel_output_feature_dimension = 0,
  const std::vector<int64_t> *kernel_spatial_dimensions = nullptr,
  int64_t output_batch_dimension = 0, int64_t output_feature_dimension = 0,
  const std::vector<int64_t> *output_spatial_dimensions = nullptr, int64_t feature_group_count = 0,
  int64_t batch_group_count = 0, const std::vector<uint32_t> *precision_config = nullptr)
{
  auto window_strides__ = window_strides ? _fbb.CreateVector<int64_t>(*window_strides) : 0;
  auto padding__ = padding ? _fbb.CreateVector<int64_t>(*padding) : 0;
  auto lhs_dilation__ = lhs_dilation ? _fbb.CreateVector<int64_t>(*lhs_dilation) : 0;
  auto rhs_dilation__ = rhs_dilation ? _fbb.CreateVector<int64_t>(*rhs_dilation) : 0;
  auto window_reversal__ = window_reversal ? _fbb.CreateVector<uint8_t>(*window_reversal) : 0;
  auto input_spatial_dimensions__ =
    input_spatial_dimensions ? _fbb.CreateVector<int64_t>(*input_spatial_dimensions) : 0;
  auto kernel_spatial_dimensions__ =
    kernel_spatial_dimensions ? _fbb.CreateVector<int64_t>(*kernel_spatial_dimensions) : 0;
  auto output_spatial_dimensions__ =
    output_spatial_dimensions ? _fbb.CreateVector<int64_t>(*output_spatial_dimensions) : 0;
  auto precision_config__ = precision_config ? _fbb.CreateVector<uint32_t>(*precision_config) : 0;
  return circle::CreateStablehloConvolutionOptions(
    _fbb, window_strides__, padding__, lhs_dilation__, rhs_dilation__, window_reversal__,
    input_batch_dimension, input_feature_dimension, input_spatial_dimensions__,
    kernel_input_feature_dimension, kernel_output_feature_dimension, kernel_spatial_dimensions__,
    output_batch_dimension, output_feature_dimension, output_spatial_dimensions__,
    feature_group_count, batch_group_count, precision_config__);
}

struct StablehloScatterOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloScatterOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_INDICES_ARE_SORTED = 4,
    VT_UPDATE_WINDOW_DIMS = 6,
    VT_INSERTED_WINDOW_DIMS = 8,
    VT_SCATTER_DIMS_TO_OPERAND_DIMS = 10,
    VT_INDEX_VECTOR_DIM = 12,
    VT_UNIQUE_INDICES = 14,
    VT_UPDATE_COMPUTATION_SUBGRAPH_INDEX = 16
  };
  bool indices_are_sorted() const { return GetField<uint8_t>(VT_INDICES_ARE_SORTED, 0) != 0; }
  const ::flatbuffers::Vector<int64_t> *update_window_dims() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_UPDATE_WINDOW_DIMS);
  }
  const ::flatbuffers::Vector<int64_t> *inserted_window_dims() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INSERTED_WINDOW_DIMS);
  }
  const ::flatbuffers::Vector<int64_t> *scatter_dims_to_operand_dims() const
  {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SCATTER_DIMS_TO_OPERAND_DIMS);
  }
  int64_t index_vector_dim() const { return GetField<int64_t>(VT_INDEX_VECTOR_DIM, 0); }
  bool unique_indices() const { return GetField<uint8_t>(VT_UNIQUE_INDICES, 0) != 0; }
  int32_t update_computation_subgraph_index() const
  {
    return GetField<int32_t>(VT_UPDATE_COMPUTATION_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_INDICES_ARE_SORTED, 1) &&
           VerifyOffset(verifier, VT_UPDATE_WINDOW_DIMS) &&
           verifier.VerifyVector(update_window_dims()) &&
           VerifyOffset(verifier, VT_INSERTED_WINDOW_DIMS) &&
           verifier.VerifyVector(inserted_window_dims()) &&
           VerifyOffset(verifier, VT_SCATTER_DIMS_TO_OPERAND_DIMS) &&
           verifier.VerifyVector(scatter_dims_to_operand_dims()) &&
           VerifyField<int64_t>(verifier, VT_INDEX_VECTOR_DIM, 8) &&
           VerifyField<uint8_t>(verifier, VT_UNIQUE_INDICES, 1) &&
           VerifyField<int32_t>(verifier, VT_UPDATE_COMPUTATION_SUBGRAPH_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct StablehloScatterOptionsBuilder
{
  typedef StablehloScatterOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_indices_are_sorted(bool indices_are_sorted)
  {
    fbb_.AddElement<uint8_t>(StablehloScatterOptions::VT_INDICES_ARE_SORTED,
                             static_cast<uint8_t>(indices_are_sorted), 0);
  }
  void
  add_update_window_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> update_window_dims)
  {
    fbb_.AddOffset(StablehloScatterOptions::VT_UPDATE_WINDOW_DIMS, update_window_dims);
  }
  void add_inserted_window_dims(
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> inserted_window_dims)
  {
    fbb_.AddOffset(StablehloScatterOptions::VT_INSERTED_WINDOW_DIMS, inserted_window_dims);
  }
  void add_scatter_dims_to_operand_dims(
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> scatter_dims_to_operand_dims)
  {
    fbb_.AddOffset(StablehloScatterOptions::VT_SCATTER_DIMS_TO_OPERAND_DIMS,
                   scatter_dims_to_operand_dims);
  }
  void add_index_vector_dim(int64_t index_vector_dim)
  {
    fbb_.AddElement<int64_t>(StablehloScatterOptions::VT_INDEX_VECTOR_DIM, index_vector_dim, 0);
  }
  void add_unique_indices(bool unique_indices)
  {
    fbb_.AddElement<uint8_t>(StablehloScatterOptions::VT_UNIQUE_INDICES,
                             static_cast<uint8_t>(unique_indices), 0);
  }
  void add_update_computation_subgraph_index(int32_t update_computation_subgraph_index)
  {
    fbb_.AddElement<int32_t>(StablehloScatterOptions::VT_UPDATE_COMPUTATION_SUBGRAPH_INDEX,
                             update_computation_subgraph_index, 0);
  }
  explicit StablehloScatterOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloScatterOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloScatterOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloScatterOptions> CreateStablehloScatterOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, bool indices_are_sorted = false,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> update_window_dims = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> inserted_window_dims = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> scatter_dims_to_operand_dims = 0,
  int64_t index_vector_dim = 0, bool unique_indices = false,
  int32_t update_computation_subgraph_index = 0)
{
  StablehloScatterOptionsBuilder builder_(_fbb);
  builder_.add_index_vector_dim(index_vector_dim);
  builder_.add_update_computation_subgraph_index(update_computation_subgraph_index);
  builder_.add_scatter_dims_to_operand_dims(scatter_dims_to_operand_dims);
  builder_.add_inserted_window_dims(inserted_window_dims);
  builder_.add_update_window_dims(update_window_dims);
  builder_.add_unique_indices(unique_indices);
  builder_.add_indices_are_sorted(indices_are_sorted);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloScatterOptions> CreateStablehloScatterOptionsDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, bool indices_are_sorted = false,
  const std::vector<int64_t> *update_window_dims = nullptr,
  const std::vector<int64_t> *inserted_window_dims = nullptr,
  const std::vector<int64_t> *scatter_dims_to_operand_dims = nullptr, int64_t index_vector_dim = 0,
  bool unique_indices = false, int32_t update_computation_subgraph_index = 0)
{
  auto update_window_dims__ =
    update_window_dims ? _fbb.CreateVector<int64_t>(*update_window_dims) : 0;
  auto inserted_window_dims__ =
    inserted_window_dims ? _fbb.CreateVector<int64_t>(*inserted_window_dims) : 0;
  auto scatter_dims_to_operand_dims__ =
    scatter_dims_to_operand_dims ? _fbb.CreateVector<int64_t>(*scatter_dims_to_operand_dims) : 0;
  return circle::CreateStablehloScatterOptions(_fbb, indices_are_sorted, update_window_dims__,
                                               inserted_window_dims__,
                                               scatter_dims_to_operand_dims__, index_vector_dim,
                                               unique_indices, update_computation_subgraph_index);
}

struct StablehloRngBitGeneratorOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StablehloRngBitGeneratorOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_ALGORITHM = 4
  };
  circle::RngAlgorithm algorithm() const
  {
    return static_cast<circle::RngAlgorithm>(GetField<int8_t>(VT_ALGORITHM, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_ALGORITHM, 1) &&
           verifier.EndTable();
  }
};

struct StablehloRngBitGeneratorOptionsBuilder
{
  typedef StablehloRngBitGeneratorOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_algorithm(circle::RngAlgorithm algorithm)
  {
    fbb_.AddElement<int8_t>(StablehloRngBitGeneratorOptions::VT_ALGORITHM,
                            static_cast<int8_t>(algorithm), 0);
  }
  explicit StablehloRngBitGeneratorOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
    : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloRngBitGeneratorOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloRngBitGeneratorOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloRngBitGeneratorOptions>
CreateStablehloRngBitGeneratorOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                                      circle::RngAlgorithm algorithm = circle::RngAlgorithm_DEFAULT)
{
  StablehloRngBitGeneratorOptionsBuilder builder_(_fbb);
  builder_.add_algorithm(algorithm);
  return builder_.Finish();
}

struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef Conv2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FUSED_ACTIVATION_FUNCTION = 10,
    VT_DILATION_W_FACTOR = 12,
    VT_DILATION_H_FACTOR = 14,
    VT_QUANTIZED_BIAS_TYPE = 16
  };
  circle::Padding padding() const
  {
    return static_cast<circle::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const { return GetField<int32_t>(VT_DILATION_W_FACTOR, 1); }
  int32_t dilation_h_factor() const { return GetField<int32_t>(VT_DILATION_H_FACTOR, 1); }
  circle::TensorType quantized_bias_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_QUANTIZED_BIAS_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING, 1) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR, 4) &&
           VerifyField<int8_t>(verifier, VT_QUANTIZED_BIAS_TYPE, 1) && verifier.EndTable();
  }
};

struct Conv2DOptionsBuilder
{
  typedef Conv2DOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padding(circle::Padding padding)
  {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w)
  {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h)
  {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor)
  {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor)
  {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  void add_quantized_bias_type(circle::TensorType quantized_bias_type)
  {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_QUANTIZED_BIAS_TYPE,
                            static_cast<int8_t>(quantized_bias_type), 0);
  }
  explicit Conv2DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conv2DOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conv2DOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, circle::Padding padding = circle::Padding_SAME,
  int32_t stride_w = 0, int32_t stride_h = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1,
  circle::TensorType quantized_bias_type = circle::TensorType_FLOAT32)
{
  Conv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_quantized_bias_type(quantized_bias_type);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct Conv3DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef Conv3DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_PADDING = 4,
    VT_STRIDE_D = 6,
    VT_STRIDE_W = 8,
    VT_STRIDE_H = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_D_FACTOR = 14,
    VT_DILATION_W_FACTOR = 16,
    VT_DILATION_H_FACTOR = 18
  };
  circle::Padding padding() const
  {
    return static_cast<circle::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_d() const { return GetField<int32_t>(VT_STRIDE_D, 0); }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_d_factor() const { return GetField<int32_t>(VT_DILATION_D_FACTOR, 1); }
  int32_t dilation_w_factor() const { return GetField<int32_t>(VT_DILATION_W_FACTOR, 1); }
  int32_t dilation_h_factor() const { return GetField<int32_t>(VT_DILATION_H_FACTOR, 1); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING, 1) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_D, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<int32_t>(verifier, VT_DILATION_D_FACTOR, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR, 4) && verifier.EndTable();
  }
};

struct Conv3DOptionsBuilder
{
  typedef Conv3DOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padding(circle::Padding padding)
  {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_d(int32_t stride_d)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_D, stride_d, 0);
  }
  void add_stride_w(int32_t stride_w)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_d_factor(int32_t dilation_d_factor)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_D_FACTOR, dilation_d_factor, 1);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit Conv3DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conv3DOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conv3DOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, circle::Padding padding = circle::Padding_SAME,
  int32_t stride_d = 0, int32_t stride_w = 0, int32_t stride_h = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  int32_t dilation_d_factor = 1, int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1)
{
  Conv3DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_dilation_d_factor(dilation_d_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_stride_d(stride_d);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef Pool2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FILTER_WIDTH = 10,
    VT_FILTER_HEIGHT = 12,
    VT_FUSED_ACTIVATION_FUNCTION = 14
  };
  circle::Padding padding() const
  {
    return static_cast<circle::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  int32_t filter_width() const { return GetField<int32_t>(VT_FILTER_WIDTH, 0); }
  int32_t filter_height() const { return GetField<int32_t>(VT_FILTER_HEIGHT, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING, 1) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H, 4) &&
           VerifyField<int32_t>(verifier, VT_FILTER_WIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_FILTER_HEIGHT, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) && verifier.EndTable();
  }
};

struct Pool2DOptionsBuilder
{
  typedef Pool2DOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padding(circle::Padding padding)
  {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w)
  {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h)
  {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_filter_width(int32_t filter_width)
  {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
  }
  void add_filter_height(int32_t filter_height)
  {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit Pool2DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pool2DOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pool2DOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, circle::Padding padding = circle::Padding_SAME,
  int32_t stride_w = 0, int32_t stride_h = 0, int32_t filter_width = 0, int32_t filter_height = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  Pool2DOptionsBuilder builder_(_fbb);
  builder_.add_filter_height(filter_height);
  builder_.add_filter_width(filter_width);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef DepthwiseConv2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_DEPTH_MULTIPLIER = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_W_FACTOR = 14,
    VT_DILATION_H_FACTOR = 16
  };
  circle::Padding padding() const
  {
    return static_cast<circle::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  int32_t depth_multiplier() const { return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const { return GetField<int32_t>(VT_DILATION_W_FACTOR, 1); }
  int32_t dilation_h_factor() const { return GetField<int32_t>(VT_DILATION_H_FACTOR, 1); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING, 1) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H, 4) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR, 4) && verifier.EndTable();
  }
};

struct DepthwiseConv2DOptionsBuilder
{
  typedef DepthwiseConv2DOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padding(circle::Padding padding)
  {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w)
  {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h)
  {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_depth_multiplier(int32_t depth_multiplier)
  {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor)
  {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor)
  {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit DepthwiseConv2DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DepthwiseConv2DOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DepthwiseConv2DOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, circle::Padding padding = circle::Padding_SAME,
  int32_t stride_w = 0, int32_t stride_h = 0, int32_t depth_multiplier = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1)
{
  DepthwiseConv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ConcatEmbeddingsOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NUM_CHANNELS = 4,
    VT_NUM_COLUMNS_PER_CHANNEL = 6,
    VT_EMBEDDING_DIM_PER_CHANNEL = 8
  };
  int32_t num_channels() const { return GetField<int32_t>(VT_NUM_CHANNELS, 0); }
  const ::flatbuffers::Vector<int32_t> *num_columns_per_channel() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);
  }
  const ::flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM_CHANNELS, 4) &&
           VerifyOffset(verifier, VT_NUM_COLUMNS_PER_CHANNEL) &&
           verifier.VerifyVector(num_columns_per_channel()) &&
           VerifyOffset(verifier, VT_EMBEDDING_DIM_PER_CHANNEL) &&
           verifier.VerifyVector(embedding_dim_per_channel()) && verifier.EndTable();
  }
};

struct ConcatEmbeddingsOptionsBuilder
{
  typedef ConcatEmbeddingsOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_num_channels(int32_t num_channels)
  {
    fbb_.AddElement<int32_t>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
  }
  void add_num_columns_per_channel(
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> num_columns_per_channel)
  {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);
  }
  void add_embedding_dim_per_channel(
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> embedding_dim_per_channel)
  {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL,
                   embedding_dim_per_channel);
  }
  explicit ConcatEmbeddingsOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConcatEmbeddingsOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConcatEmbeddingsOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, int32_t num_channels = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> num_columns_per_channel = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0)
{
  ConcatEmbeddingsOptionsBuilder builder_(_fbb);
  builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);
  builder_.add_num_columns_per_channel(num_columns_per_channel);
  builder_.add_num_channels(num_channels);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConcatEmbeddingsOptions>
CreateConcatEmbeddingsOptionsDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                    int32_t num_channels = 0,
                                    const std::vector<int32_t> *num_columns_per_channel = nullptr,
                                    const std::vector<int32_t> *embedding_dim_per_channel = nullptr)
{
  auto num_columns_per_channel__ =
    num_columns_per_channel ? _fbb.CreateVector<int32_t>(*num_columns_per_channel) : 0;
  auto embedding_dim_per_channel__ =
    embedding_dim_per_channel ? _fbb.CreateVector<int32_t>(*embedding_dim_per_channel) : 0;
  return circle::CreateConcatEmbeddingsOptions(_fbb, num_channels, num_columns_per_channel__,
                                               embedding_dim_per_channel__);
}

struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef LSHProjectionOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TYPE = 4
  };
  circle::LSHProjectionType type() const
  {
    return static_cast<circle::LSHProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct LSHProjectionOptionsBuilder
{
  typedef LSHProjectionOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(circle::LSHProjectionType type)
  {
    fbb_.AddElement<int8_t>(LSHProjectionOptions::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit LSHProjectionOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LSHProjectionOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LSHProjectionOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LSHProjectionOptions>
CreateLSHProjectionOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                           circle::LSHProjectionType type = circle::LSHProjectionType_UNKNOWN)
{
  LSHProjectionOptionsBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SVDFOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_RANK = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  int32_t rank() const { return GetField<int32_t>(VT_RANK, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_RANK, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) && verifier.EndTable();
  }
};

struct SVDFOptionsBuilder
{
  typedef SVDFOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) { fbb_.AddElement<int32_t>(SVDFOptions::VT_RANK, rank, 0); }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SVDFOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SVDFOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SVDFOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, int32_t rank = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool asymmetric_quantize_inputs = false)
{
  SVDFOptionsBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct RNNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef RNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 6
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) && verifier.EndTable();
  }
};

struct RNNOptionsBuilder
{
  typedef RNNOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit RNNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RNNOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RNNOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RNNOptions> CreateRNNOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool asymmetric_quantize_inputs = false)
{
  RNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SequenceRNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0; }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_TIME_MAJOR, 1) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) && verifier.EndTable();
  }
};

struct SequenceRNNOptionsBuilder
{
  typedef SequenceRNNOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major)
  {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major),
                             0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SequenceRNNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SequenceRNNOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SequenceRNNOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, bool time_major = false,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool asymmetric_quantize_inputs = false)
{
  SequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef BidirectionalSequenceRNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_MERGE_OUTPUTS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
  };
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0; }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool merge_outputs() const { return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0; }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_TIME_MAJOR, 1) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) && verifier.EndTable();
  }
};

struct BidirectionalSequenceRNNOptionsBuilder
{
  typedef BidirectionalSequenceRNNOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR,
                             static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_merge_outputs(bool merge_outputs)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS,
                             static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceRNNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
    : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, bool time_major = false,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool merge_outputs = false, bool asymmetric_quantize_inputs = false)
{
  BidirectionalSequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef FullyConnectedOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_WEIGHTS_FORMAT = 6,
    VT_KEEP_NUM_DIMS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10,
    VT_QUANTIZED_BIAS_TYPE = 12
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  circle::FullyConnectedOptionsWeightsFormat weights_format() const
  {
    return static_cast<circle::FullyConnectedOptionsWeightsFormat>(
      GetField<int8_t>(VT_WEIGHTS_FORMAT, 0));
  }
  bool keep_num_dims() const { return GetField<uint8_t>(VT_KEEP_NUM_DIMS, 0) != 0; }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  circle::TensorType quantized_bias_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_QUANTIZED_BIAS_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<int8_t>(verifier, VT_WEIGHTS_FORMAT, 1) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_NUM_DIMS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&
           VerifyField<int8_t>(verifier, VT_QUANTIZED_BIAS_TYPE, 1) && verifier.EndTable();
  }
};

struct FullyConnectedOptionsBuilder
{
  typedef FullyConnectedOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_weights_format(circle::FullyConnectedOptionsWeightsFormat weights_format)
  {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_WEIGHTS_FORMAT,
                            static_cast<int8_t>(weights_format), 0);
  }
  void add_keep_num_dims(bool keep_num_dims)
  {
    fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_KEEP_NUM_DIMS,
                             static_cast<uint8_t>(keep_num_dims), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  void add_quantized_bias_type(circle::TensorType quantized_bias_type)
  {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_QUANTIZED_BIAS_TYPE,
                            static_cast<int8_t>(quantized_bias_type), 0);
  }
  explicit FullyConnectedOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FullyConnectedOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FullyConnectedOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  circle::FullyConnectedOptionsWeightsFormat weights_format =
    circle::FullyConnectedOptionsWeightsFormat_DEFAULT,
  bool keep_num_dims = false, bool asymmetric_quantize_inputs = false,
  circle::TensorType quantized_bias_type = circle::TensorType_FLOAT32)
{
  FullyConnectedOptionsBuilder builder_(_fbb);
  builder_.add_quantized_bias_type(quantized_bias_type);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_keep_num_dims(keep_num_dims);
  builder_.add_weights_format(weights_format);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SoftmaxOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_BETA = 4
  };
  float beta() const { return GetField<float>(VT_BETA, 0.0f); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
};

struct SoftmaxOptionsBuilder
{
  typedef SoftmaxOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_beta(float beta) { fbb_.AddElement<float>(SoftmaxOptions::VT_BETA, beta, 0.0f); }
  explicit SoftmaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SoftmaxOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SoftmaxOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SoftmaxOptions>
CreateSoftmaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, float beta = 0.0f)
{
  SoftmaxOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ConcatenationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_AXIS = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) && verifier.EndTable();
  }
};

struct ConcatenationOptionsBuilder
{
  typedef ConcatenationOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(ConcatenationOptions::VT_AXIS, axis, 0); }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit ConcatenationOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConcatenationOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConcatenationOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  ConcatenationOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct AddOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef AddOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const { return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16, 1) && verifier.EndTable();
  }
};

struct AddOptionsBuilder
{
  typedef AddOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16)
  {
    fbb_.AddElement<uint8_t>(AddOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16),
                             1);
  }
  explicit AddOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddOptions> CreateAddOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool pot_scale_int16 = true)
{
  AddOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct MulOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef MulOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) && verifier.EndTable();
  }
};

struct MulOptionsBuilder
{
  typedef MulOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit MulOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MulOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MulOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MulOptions> CreateMulOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  MulOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef L2NormOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) && verifier.EndTable();
  }
};

struct L2NormOptionsBuilder
{
  typedef L2NormOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit L2NormOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<L2NormOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<L2NormOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  L2NormOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef LocalResponseNormalizationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t radius() const { return GetField<int32_t>(VT_RADIUS, 0); }
  float bias() const { return GetField<float>(VT_BIAS, 0.0f); }
  float alpha() const { return GetField<float>(VT_ALPHA, 0.0f); }
  float beta() const { return GetField<float>(VT_BETA, 0.0f); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_BIAS, 4) && VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_BETA, 4) && verifier.EndTable();
  }
};

struct LocalResponseNormalizationOptionsBuilder
{
  typedef LocalResponseNormalizationOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_radius(int32_t radius)
  {
    fbb_.AddElement<int32_t>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias)
  {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha)
  {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta)
  {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0f);
  }
  explicit LocalResponseNormalizationOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
    : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LocalResponseNormalizationOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LocalResponseNormalizationOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LocalResponseNormalizationOptions>
CreateLocalResponseNormalizationOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t radius = 0,
                                        float bias = 0.0f, float alpha = 0.0f, float beta = 0.0f)
{
  LocalResponseNormalizationOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  return builder_.Finish();
}

struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef LSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_KERNEL_TYPE = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const { return GetField<float>(VT_CELL_CLIP, 0.0f); }
  float proj_clip() const { return GetField<float>(VT_PROJ_CLIP, 0.0f); }
  circle::LSTMKernelType kernel_type() const
  {
    return static_cast<circle::LSTMKernelType>(GetField<int8_t>(VT_KERNEL_TYPE, 0));
  }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<float>(verifier, VT_CELL_CLIP, 4) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP, 4) &&
           VerifyField<int8_t>(verifier, VT_KERNEL_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) && verifier.EndTable();
  }
};

struct LSTMOptionsBuilder
{
  typedef LSTMOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip)
  {
    fbb_.AddElement<float>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip)
  {
    fbb_.AddElement<float>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_kernel_type(circle::LSTMKernelType kernel_type)
  {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_KERNEL_TYPE, static_cast<int8_t>(kernel_type), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit LSTMOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LSTMOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LSTMOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  float cell_clip = 0.0f, float proj_clip = 0.0f,
  circle::LSTMKernelType kernel_type = circle::LSTMKernelType_FULL,
  bool asymmetric_quantize_inputs = false)
{
  LSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_kernel_type(kernel_type);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef UnidirectionalSequenceLSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_TIME_MAJOR = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12,
    VT_DIAGONAL_RECURRENT_TENSORS = 14
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const { return GetField<float>(VT_CELL_CLIP, 0.0f); }
  float proj_clip() const { return GetField<float>(VT_PROJ_CLIP, 0.0f); }
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0; }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool diagonal_recurrent_tensors() const
  {
    return GetField<uint8_t>(VT_DIAGONAL_RECURRENT_TENSORS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<float>(verifier, VT_CELL_CLIP, 4) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP, 4) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&
           VerifyField<uint8_t>(verifier, VT_DIAGONAL_RECURRENT_TENSORS, 1) && verifier.EndTable();
  }
};

struct UnidirectionalSequenceLSTMOptionsBuilder
{
  typedef UnidirectionalSequenceLSTMOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip)
  {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip)
  {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_time_major(bool time_major)
  {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR,
                             static_cast<uint8_t>(time_major), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  void add_diagonal_recurrent_tensors(bool diagonal_recurrent_tensors)
  {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_DIAGONAL_RECURRENT_TENSORS,
                             static_cast<uint8_t>(diagonal_recurrent_tensors), 0);
  }
  explicit UnidirectionalSequenceLSTMOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
    : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>
CreateUnidirectionalSequenceLSTMOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  float cell_clip = 0.0f, float proj_clip = 0.0f, bool time_major = false,
  bool asymmetric_quantize_inputs = false, bool diagonal_recurrent_tensors = false)
{
  UnidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_diagonal_recurrent_tensors(diagonal_recurrent_tensors);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef BidirectionalSequenceLSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_MERGE_OUTPUTS = 10,
    VT_TIME_MAJOR = 12,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 14
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const { return GetField<float>(VT_CELL_CLIP, 0.0f); }
  float proj_clip() const { return GetField<float>(VT_PROJ_CLIP, 0.0f); }
  bool merge_outputs() const { return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0; }
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 1) != 0; }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<float>(verifier, VT_CELL_CLIP, 4) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP, 4) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) && verifier.EndTable();
  }
};

struct BidirectionalSequenceLSTMOptionsBuilder
{
  typedef BidirectionalSequenceLSTMOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip)
  {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip)
  {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_merge_outputs(bool merge_outputs)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS,
                             static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_time_major(bool time_major)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR,
                             static_cast<uint8_t>(time_major), 1);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceLSTMOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
    : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions>
CreateBidirectionalSequenceLSTMOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  float cell_clip = 0.0f, float proj_clip = 0.0f, bool merge_outputs = false,
  bool time_major = true, bool asymmetric_quantize_inputs = false)
{
  BidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ResizeBilinearOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_ALIGN_CORNERS = 8,
    VT_HALF_PIXEL_CENTERS = 10
  };
  bool align_corners() const { return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0; }
  bool half_pixel_centers() const { return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS, 1) && verifier.EndTable();
  }
};

struct ResizeBilinearOptionsBuilder
{
  typedef ResizeBilinearOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners)
  {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_ALIGN_CORNERS,
                             static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers)
  {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS,
                             static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeBilinearOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResizeBilinearOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResizeBilinearOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResizeBilinearOptions>
CreateResizeBilinearOptions(::flatbuffers::FlatBufferBuilder &_fbb, bool align_corners = false,
                            bool half_pixel_centers = false)
{
  ResizeBilinearOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ResizeNearestNeighborOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_ALIGN_CORNERS = 4,
    VT_HALF_PIXEL_CENTERS = 6
  };
  bool align_corners() const { return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0; }
  bool half_pixel_centers() const { return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS, 1) && verifier.EndTable();
  }
};

struct ResizeNearestNeighborOptionsBuilder
{
  typedef ResizeNearestNeighborOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners)
  {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS,
                             static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers)
  {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS,
                             static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeNearestNeighborOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResizeNearestNeighborOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResizeNearestNeighborOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResizeNearestNeighborOptions>
CreateResizeNearestNeighborOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                                   bool align_corners = false, bool half_pixel_centers = false)
{
  ResizeNearestNeighborOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

struct CallOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef CallOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SUBGRAPH = 4
  };
  uint32_t subgraph() const { return GetField<uint32_t>(VT_SUBGRAPH, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_SUBGRAPH, 4) &&
           verifier.EndTable();
  }
};

struct CallOptionsBuilder
{
  typedef CallOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subgraph(uint32_t subgraph)
  {
    fbb_.AddElement<uint32_t>(CallOptions::VT_SUBGRAPH, subgraph, 0);
  }
  explicit CallOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CallOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CallOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CallOptions> CreateCallOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                                                            uint32_t subgraph = 0)
{
  CallOptionsBuilder builder_(_fbb);
  builder_.add_subgraph(subgraph);
  return builder_.Finish();
}

struct PadOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef PadOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct PadOptionsBuilder
{
  typedef PadOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PadOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PadOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PadOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PadOptions> CreatePadOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  PadOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PadV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef PadV2OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct PadV2OptionsBuilder
{
  typedef PadV2Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PadV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PadV2Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PadV2Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PadV2Options>
CreatePadV2Options(::flatbuffers::FlatBufferBuilder &_fbb)
{
  PadV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ReshapeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NEW_SHAPE = 4
  };
  const ::flatbuffers::Vector<int32_t> *new_shape() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NEW_SHAPE) &&
           verifier.VerifyVector(new_shape()) && verifier.EndTable();
  }
};

struct ReshapeOptionsBuilder
{
  typedef ReshapeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_new_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> new_shape)
  {
    fbb_.AddOffset(ReshapeOptions::VT_NEW_SHAPE, new_shape);
  }
  explicit ReshapeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReshapeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReshapeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReshapeOptions>
CreateReshapeOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                     ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> new_shape = 0)
{
  ReshapeOptionsBuilder builder_(_fbb);
  builder_.add_new_shape(new_shape);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReshapeOptions>
CreateReshapeOptionsDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                           const std::vector<int32_t> *new_shape = nullptr)
{
  auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;
  return circle::CreateReshapeOptions(_fbb, new_shape__);
}

struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SpaceToBatchNDOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SpaceToBatchNDOptionsBuilder
{
  typedef SpaceToBatchNDOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SpaceToBatchNDOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpaceToBatchNDOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpaceToBatchNDOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpaceToBatchNDOptions>
CreateSpaceToBatchNDOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  SpaceToBatchNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef BatchToSpaceNDOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct BatchToSpaceNDOptionsBuilder
{
  typedef BatchToSpaceNDOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BatchToSpaceNDOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchToSpaceNDOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchToSpaceNDOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchToSpaceNDOptions>
CreateBatchToSpaceNDOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  BatchToSpaceNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SkipGramOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NGRAM_SIZE = 4,
    VT_MAX_SKIP_SIZE = 6,
    VT_INCLUDE_ALL_NGRAMS = 8
  };
  int32_t ngram_size() const { return GetField<int32_t>(VT_NGRAM_SIZE, 0); }
  int32_t max_skip_size() const { return GetField<int32_t>(VT_MAX_SKIP_SIZE, 0); }
  bool include_all_ngrams() const { return GetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NGRAM_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX_SKIP_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_NGRAMS, 1) && verifier.EndTable();
  }
};

struct SkipGramOptionsBuilder
{
  typedef SkipGramOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ngram_size(int32_t ngram_size)
  {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
  }
  void add_max_skip_size(int32_t max_skip_size)
  {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
  }
  void add_include_all_ngrams(bool include_all_ngrams)
  {
    fbb_.AddElement<uint8_t>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS,
                             static_cast<uint8_t>(include_all_ngrams), 0);
  }
  explicit SkipGramOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SkipGramOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SkipGramOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SkipGramOptions>
CreateSkipGramOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t ngram_size = 0,
                      int32_t max_skip_size = 0, bool include_all_ngrams = false)
{
  SkipGramOptionsBuilder builder_(_fbb);
  builder_.add_max_skip_size(max_skip_size);
  builder_.add_ngram_size(ngram_size);
  builder_.add_include_all_ngrams(include_all_ngrams);
  return builder_.Finish();
}

struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SpaceToDepthOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const { return GetField<int32_t>(VT_BLOCK_SIZE, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BLOCK_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct SpaceToDepthOptionsBuilder
{
  typedef SpaceToDepthOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size)
  {
    fbb_.AddElement<int32_t>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit SpaceToDepthOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpaceToDepthOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpaceToDepthOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpaceToDepthOptions>
CreateSpaceToDepthOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t block_size = 0)
{
  SpaceToDepthOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

struct DepthToSpaceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef DepthToSpaceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const { return GetField<int32_t>(VT_BLOCK_SIZE, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BLOCK_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct DepthToSpaceOptionsBuilder
{
  typedef DepthToSpaceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size)
  {
    fbb_.AddElement<int32_t>(DepthToSpaceOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit DepthToSpaceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DepthToSpaceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DepthToSpaceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DepthToSpaceOptions>
CreateDepthToSpaceOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t block_size = 0)
{
  DepthToSpaceOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

struct SubOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SubOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const { return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16, 1) && verifier.EndTable();
  }
};

struct SubOptionsBuilder
{
  typedef SubOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16)
  {
    fbb_.AddElement<uint8_t>(SubOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16),
                             1);
  }
  explicit SubOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubOptions> CreateSubOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool pot_scale_int16 = true)
{
  SubOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct DivOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef DivOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) && verifier.EndTable();
  }
};

struct DivOptionsBuilder
{
  typedef DivOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit DivOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DivOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DivOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DivOptions> CreateDivOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  DivOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef TopKV2OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct TopKV2OptionsBuilder
{
  typedef TopKV2Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit TopKV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TopKV2Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TopKV2Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TopKV2Options>
CreateTopKV2Options(::flatbuffers::FlatBufferBuilder &_fbb)
{
  TopKV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef EmbeddingLookupSparseOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_COMBINER = 4
  };
  circle::CombinerType combiner() const
  {
    return static_cast<circle::CombinerType>(GetField<int8_t>(VT_COMBINER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_COMBINER, 1) &&
           verifier.EndTable();
  }
};

struct EmbeddingLookupSparseOptionsBuilder
{
  typedef EmbeddingLookupSparseOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_combiner(circle::CombinerType combiner)
  {
    fbb_.AddElement<int8_t>(EmbeddingLookupSparseOptions::VT_COMBINER,
                            static_cast<int8_t>(combiner), 0);
  }
  explicit EmbeddingLookupSparseOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EmbeddingLookupSparseOptions>
CreateEmbeddingLookupSparseOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                                   circle::CombinerType combiner = circle::CombinerType_SUM)
{
  EmbeddingLookupSparseOptionsBuilder builder_(_fbb);
  builder_.add_combiner(combiner);
  return builder_.Finish();
}

struct GatherOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef GatherOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_AXIS = 4,
    VT_BATCH_DIMS = 6
  };
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  int32_t batch_dims() const { return GetField<int32_t>(VT_BATCH_DIMS, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIMS, 4) && verifier.EndTable();
  }
};

struct GatherOptionsBuilder
{
  typedef GatherOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(GatherOptions::VT_AXIS, axis, 0); }
  void add_batch_dims(int32_t batch_dims)
  {
    fbb_.AddElement<int32_t>(GatherOptions::VT_BATCH_DIMS, batch_dims, 0);
  }
  explicit GatherOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GatherOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GatherOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GatherOptions>
CreateGatherOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0,
                    int32_t batch_dims = 0)
{
  GatherOptionsBuilder builder_(_fbb);
  builder_.add_batch_dims(batch_dims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef TransposeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct TransposeOptionsBuilder
{
  typedef TransposeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit TransposeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransposeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransposeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TransposeOptions>
CreateTransposeOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  TransposeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ExpOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ExpOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ExpOptionsBuilder
{
  typedef ExpOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ExpOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExpOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExpOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExpOptions> CreateExpOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  ExpOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CosOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef CosOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct CosOptionsBuilder
{
  typedef CosOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CosOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CosOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CosOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CosOptions> CreateCosOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  CosOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ReducerOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_KEEP_DIMS = 4
  };
  bool keep_dims() const { return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_KEEP_DIMS, 1) &&
           verifier.EndTable();
  }
};

struct ReducerOptionsBuilder
{
  typedef ReducerOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_keep_dims(bool keep_dims)
  {
    fbb_.AddElement<uint8_t>(ReducerOptions::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  explicit ReducerOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReducerOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReducerOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReducerOptions>
CreateReducerOptions(::flatbuffers::FlatBufferBuilder &_fbb, bool keep_dims = false)
{
  ReducerOptionsBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SqueezeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SQUEEZE_DIMS = 4
  };
  const ::flatbuffers::Vector<int32_t> *squeeze_dims() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SQUEEZE_DIMS) &&
           verifier.VerifyVector(squeeze_dims()) && verifier.EndTable();
  }
};

struct SqueezeOptionsBuilder
{
  typedef SqueezeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_squeeze_dims(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> squeeze_dims)
  {
    fbb_.AddOffset(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);
  }
  explicit SqueezeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SqueezeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SqueezeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SqueezeOptions>
CreateSqueezeOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                     ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> squeeze_dims = 0)
{
  SqueezeOptionsBuilder builder_(_fbb);
  builder_.add_squeeze_dims(squeeze_dims);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SqueezeOptions>
CreateSqueezeOptionsDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                           const std::vector<int32_t> *squeeze_dims = nullptr)
{
  auto squeeze_dims__ = squeeze_dims ? _fbb.CreateVector<int32_t>(*squeeze_dims) : 0;
  return circle::CreateSqueezeOptions(_fbb, squeeze_dims__);
}

struct SplitOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SplitOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const { return GetField<int32_t>(VT_NUM_SPLITS, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM_SPLITS, 4) &&
           verifier.EndTable();
  }
};

struct SplitOptionsBuilder
{
  typedef SplitOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits)
  {
    fbb_.AddElement<int32_t>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SplitOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SplitOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SplitOptions>
CreateSplitOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t num_splits = 0)
{
  SplitOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SplitVOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const { return GetField<int32_t>(VT_NUM_SPLITS, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM_SPLITS, 4) &&
           verifier.EndTable();
  }
};

struct SplitVOptionsBuilder
{
  typedef SplitVOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits)
  {
    fbb_.AddElement<int32_t>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitVOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SplitVOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SplitVOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SplitVOptions>
CreateSplitVOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t num_splits = 0)
{
  SplitVOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef StridedSliceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12,
    VT_OFFSET = 14
  };
  int32_t begin_mask() const { return GetField<int32_t>(VT_BEGIN_MASK, 0); }
  int32_t end_mask() const { return GetField<int32_t>(VT_END_MASK, 0); }
  int32_t ellipsis_mask() const { return GetField<int32_t>(VT_ELLIPSIS_MASK, 0); }
  int32_t new_axis_mask() const { return GetField<int32_t>(VT_NEW_AXIS_MASK, 0); }
  int32_t shrink_axis_mask() const { return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0); }
  bool offset() const { return GetField<uint8_t>(VT_OFFSET, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BEGIN_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_END_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSIS_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_NEW_AXIS_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK, 4) &&
           VerifyField<uint8_t>(verifier, VT_OFFSET, 1) && verifier.EndTable();
  }
};

struct StridedSliceOptionsBuilder
{
  typedef StridedSliceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_begin_mask(int32_t begin_mask)
  {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask)
  {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int32_t ellipsis_mask)
  {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int32_t new_axis_mask)
  {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask)
  {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  void add_offset(bool offset)
  {
    fbb_.AddElement<uint8_t>(StridedSliceOptions::VT_OFFSET, static_cast<uint8_t>(offset), 0);
  }
  explicit StridedSliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StridedSliceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StridedSliceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StridedSliceOptions>
CreateStridedSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t begin_mask = 0,
                          int32_t end_mask = 0, int32_t ellipsis_mask = 0,
                          int32_t new_axis_mask = 0, int32_t shrink_axis_mask = 0,
                          bool offset = false)
{
  StridedSliceOptionsBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef LogSoftmaxOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LogSoftmaxOptionsBuilder
{
  typedef LogSoftmaxOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LogSoftmaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogSoftmaxOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogSoftmaxOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogSoftmaxOptions>
CreateLogSoftmaxOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  LogSoftmaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CastOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef CastOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_IN_DATA_TYPE = 4,
    VT_OUT_DATA_TYPE = 6
  };
  circle::TensorType in_data_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_IN_DATA_TYPE, 0));
  }
  circle::TensorType out_data_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_OUT_DATA_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_IN_DATA_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_OUT_DATA_TYPE, 1) && verifier.EndTable();
  }
};

struct CastOptionsBuilder
{
  typedef CastOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_in_data_type(circle::TensorType in_data_type)
  {
    fbb_.AddElement<int8_t>(CastOptions::VT_IN_DATA_TYPE, static_cast<int8_t>(in_data_type), 0);
  }
  void add_out_data_type(circle::TensorType out_data_type)
  {
    fbb_.AddElement<int8_t>(CastOptions::VT_OUT_DATA_TYPE, static_cast<int8_t>(out_data_type), 0);
  }
  explicit CastOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CastOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CastOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CastOptions>
CreateCastOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                  circle::TensorType in_data_type = circle::TensorType_FLOAT32,
                  circle::TensorType out_data_type = circle::TensorType_FLOAT32)
{
  CastOptionsBuilder builder_(_fbb);
  builder_.add_out_data_type(out_data_type);
  builder_.add_in_data_type(in_data_type);
  return builder_.Finish();
}

struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef DequantizeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct DequantizeOptionsBuilder
{
  typedef DequantizeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit DequantizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DequantizeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DequantizeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DequantizeOptions>
CreateDequantizeOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  DequantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef MaximumMinimumOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct MaximumMinimumOptionsBuilder
{
  typedef MaximumMinimumOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit MaximumMinimumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaximumMinimumOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaximumMinimumOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MaximumMinimumOptions>
CreateMaximumMinimumOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  MaximumMinimumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TileOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef TileOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct TileOptionsBuilder
{
  typedef TileOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit TileOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TileOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TileOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TileOptions> CreateTileOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  TileOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ArgMaxOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_OUTPUT_TYPE = 4
  };
  circle::TensorType output_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct ArgMaxOptionsBuilder
{
  typedef ArgMaxOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_output_type(circle::TensorType output_type)
  {
    fbb_.AddElement<int8_t>(ArgMaxOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArgMaxOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArgMaxOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArgMaxOptions>
CreateArgMaxOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                    circle::TensorType output_type = circle::TensorType_FLOAT32)
{
  ArgMaxOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ArgMinOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_OUTPUT_TYPE = 4
  };
  circle::TensorType output_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct ArgMinOptionsBuilder
{
  typedef ArgMinOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_output_type(circle::TensorType output_type)
  {
    fbb_.AddElement<int8_t>(ArgMinOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMinOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArgMinOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArgMinOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArgMinOptions>
CreateArgMinOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                    circle::TensorType output_type = circle::TensorType_FLOAT32)
{
  ArgMinOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef GreaterOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct GreaterOptionsBuilder
{
  typedef GreaterOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GreaterOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GreaterOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GreaterOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GreaterOptions>
CreateGreaterOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  GreaterOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef GreaterEqualOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct GreaterEqualOptionsBuilder
{
  typedef GreaterEqualOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GreaterEqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GreaterEqualOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GreaterEqualOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GreaterEqualOptions>
CreateGreaterEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  GreaterEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LessOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef LessOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LessOptionsBuilder
{
  typedef LessOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LessOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LessOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LessOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LessOptions> CreateLessOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  LessOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef LessEqualOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LessEqualOptionsBuilder
{
  typedef LessEqualOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LessEqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LessEqualOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LessEqualOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LessEqualOptions>
CreateLessEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  LessEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NegOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef NegOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct NegOptionsBuilder
{
  typedef NegOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NegOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NegOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NegOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NegOptions> CreateNegOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  NegOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SelectOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SelectOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SelectOptionsBuilder
{
  typedef SelectOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SelectOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SelectOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SelectOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SelectOptions>
CreateSelectOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  SelectOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SliceOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SliceOptionsBuilder
{
  typedef SliceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SliceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SliceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SliceOptions>
CreateSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  SliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef TransposeConvOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FUSED_ACTIVATION_FUNCTION = 10,
    VT_QUANTIZED_BIAS_TYPE = 12
  };
  circle::Padding padding() const
  {
    return static_cast<circle::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  circle::TensorType quantized_bias_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_QUANTIZED_BIAS_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING, 1) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<int8_t>(verifier, VT_QUANTIZED_BIAS_TYPE, 1) && verifier.EndTable();
  }
};

struct TransposeConvOptionsBuilder
{
  typedef TransposeConvOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padding(circle::Padding padding)
  {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w)
  {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h)
  {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_quantized_bias_type(circle::TensorType quantized_bias_type)
  {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_QUANTIZED_BIAS_TYPE,
                            static_cast<int8_t>(quantized_bias_type), 0);
  }
  explicit TransposeConvOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransposeConvOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransposeConvOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, circle::Padding padding = circle::Padding_SAME,
  int32_t stride_w = 0, int32_t stride_h = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  circle::TensorType quantized_bias_type = circle::TensorType_FLOAT32)
{
  TransposeConvOptionsBuilder builder_(_fbb);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_quantized_bias_type(quantized_bias_type);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ExpandDimsOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ExpandDimsOptionsBuilder
{
  typedef ExpandDimsOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ExpandDimsOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExpandDimsOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExpandDimsOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExpandDimsOptions>
CreateExpandDimsOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  ExpandDimsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SparseToDenseOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VALIDATE_INDICES = 4
  };
  bool validate_indices() const { return GetField<uint8_t>(VT_VALIDATE_INDICES, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_VALIDATE_INDICES, 1) &&
           verifier.EndTable();
  }
};

struct SparseToDenseOptionsBuilder
{
  typedef SparseToDenseOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_validate_indices(bool validate_indices)
  {
    fbb_.AddElement<uint8_t>(SparseToDenseOptions::VT_VALIDATE_INDICES,
                             static_cast<uint8_t>(validate_indices), 0);
  }
  explicit SparseToDenseOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SparseToDenseOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SparseToDenseOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SparseToDenseOptions>
CreateSparseToDenseOptions(::flatbuffers::FlatBufferBuilder &_fbb, bool validate_indices = false)
{
  SparseToDenseOptionsBuilder builder_(_fbb);
  builder_.add_validate_indices(validate_indices);
  return builder_.Finish();
}

struct EqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef EqualOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct EqualOptionsBuilder
{
  typedef EqualOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EqualOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EqualOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EqualOptions>
CreateEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  EqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef NotEqualOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct NotEqualOptionsBuilder
{
  typedef NotEqualOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NotEqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotEqualOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotEqualOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotEqualOptions>
CreateNotEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  NotEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ShapeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_OUT_TYPE = 4
  };
  circle::TensorType out_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_OUT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct ShapeOptionsBuilder
{
  typedef ShapeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_out_type(circle::TensorType out_type)
  {
    fbb_.AddElement<int8_t>(ShapeOptions::VT_OUT_TYPE, static_cast<int8_t>(out_type), 0);
  }
  explicit ShapeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShapeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShapeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShapeOptions>
CreateShapeOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                   circle::TensorType out_type = circle::TensorType_FLOAT32)
{
  ShapeOptionsBuilder builder_(_fbb);
  builder_.add_out_type(out_type);
  return builder_.Finish();
}

struct RankOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef RankOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct RankOptionsBuilder
{
  typedef RankOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RankOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RankOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RankOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RankOptions> CreateRankOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  RankOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PowOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef PowOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct PowOptionsBuilder
{
  typedef PowOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PowOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PowOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PowOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PowOptions> CreatePowOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  PowOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef FakeQuantOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_NUM_BITS = 8,
    VT_NARROW_RANGE = 10
  };
  float min() const { return GetField<float>(VT_MIN, 0.0f); }
  float max() const { return GetField<float>(VT_MAX, 0.0f); }
  int32_t num_bits() const { return GetField<int32_t>(VT_NUM_BITS, 0); }
  bool narrow_range() const { return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_MIN, 4) &&
           VerifyField<float>(verifier, VT_MAX, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_BITS, 4) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE, 1) && verifier.EndTable();
  }
};

struct FakeQuantOptionsBuilder
{
  typedef FakeQuantOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(float min) { fbb_.AddElement<float>(FakeQuantOptions::VT_MIN, min, 0.0f); }
  void add_max(float max) { fbb_.AddElement<float>(FakeQuantOptions::VT_MAX, max, 0.0f); }
  void add_num_bits(int32_t num_bits)
  {
    fbb_.AddElement<int32_t>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range)
  {
    fbb_.AddElement<uint8_t>(FakeQuantOptions::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range),
                             0);
  }
  explicit FakeQuantOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FakeQuantOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FakeQuantOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FakeQuantOptions>
CreateFakeQuantOptions(::flatbuffers::FlatBufferBuilder &_fbb, float min = 0.0f, float max = 0.0f,
                       int32_t num_bits = 0, bool narrow_range = false)
{
  FakeQuantOptionsBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

struct PackOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef PackOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VALUES_COUNT = 4,
    VT_AXIS = 6
  };
  int32_t values_count() const { return GetField<int32_t>(VT_VALUES_COUNT, 0); }
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_VALUES_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) && verifier.EndTable();
  }
};

struct PackOptionsBuilder
{
  typedef PackOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values_count(int32_t values_count)
  {
    fbb_.AddElement<int32_t>(PackOptions::VT_VALUES_COUNT, values_count, 0);
  }
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(PackOptions::VT_AXIS, axis, 0); }
  explicit PackOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PackOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PackOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PackOptions> CreatePackOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                                                            int32_t values_count = 0,
                                                            int32_t axis = 0)
{
  PackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_values_count(values_count);
  return builder_.Finish();
}

struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef LogicalOrOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LogicalOrOptionsBuilder
{
  typedef LogicalOrOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LogicalOrOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogicalOrOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogicalOrOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogicalOrOptions>
CreateLogicalOrOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  LogicalOrOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef OneHotOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_AXIS = 4
  };
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct OneHotOptionsBuilder
{
  typedef OneHotOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(OneHotOptions::VT_AXIS, axis, 0); }
  explicit OneHotOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OneHotOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OneHotOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OneHotOptions>
CreateOneHotOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0)
{
  OneHotOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct AbsOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef AbsOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct AbsOptionsBuilder
{
  typedef AbsOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit AbsOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AbsOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AbsOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AbsOptions> CreateAbsOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  AbsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HardSwishOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef HardSwishOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct HardSwishOptionsBuilder
{
  typedef HardSwishOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HardSwishOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HardSwishOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HardSwishOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HardSwishOptions>
CreateHardSwishOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  HardSwishOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef LogicalAndOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LogicalAndOptionsBuilder
{
  typedef LogicalAndOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LogicalAndOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogicalAndOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogicalAndOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogicalAndOptions>
CreateLogicalAndOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  LogicalAndOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef LogicalNotOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LogicalNotOptionsBuilder
{
  typedef LogicalNotOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LogicalNotOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogicalNotOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogicalNotOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogicalNotOptions>
CreateLogicalNotOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  LogicalNotOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef UnpackOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NUM = 4,
    VT_AXIS = 6
  };
  int32_t num() const { return GetField<int32_t>(VT_NUM, 0); }
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) && verifier.EndTable();
  }
};

struct UnpackOptionsBuilder
{
  typedef UnpackOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_num(int32_t num) { fbb_.AddElement<int32_t>(UnpackOptions::VT_NUM, num, 0); }
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(UnpackOptions::VT_AXIS, axis, 0); }
  explicit UnpackOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnpackOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnpackOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnpackOptions>
CreateUnpackOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t num = 0, int32_t axis = 0)
{
  UnpackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef FloorDivOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct FloorDivOptionsBuilder
{
  typedef FloorDivOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FloorDivOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloorDivOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloorDivOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloorDivOptions>
CreateFloorDivOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  FloorDivOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SquareOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SquareOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SquareOptionsBuilder
{
  typedef SquareOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SquareOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SquareOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SquareOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SquareOptions>
CreateSquareOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  SquareOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ZerosLikeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ZerosLikeOptionsBuilder
{
  typedef ZerosLikeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ZerosLikeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ZerosLikeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ZerosLikeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ZerosLikeOptions>
CreateZerosLikeOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  ZerosLikeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FillOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef FillOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct FillOptionsBuilder
{
  typedef FillOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FillOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FillOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FillOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FillOptions> CreateFillOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  FillOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FloorModOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef FloorModOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct FloorModOptionsBuilder
{
  typedef FloorModOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FloorModOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloorModOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloorModOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloorModOptions>
CreateFloorModOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  FloorModOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RangeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef RangeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct RangeOptionsBuilder
{
  typedef RangeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RangeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RangeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RangeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RangeOptions>
CreateRangeOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  RangeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef LeakyReluOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_ALPHA = 4
  };
  float alpha() const { return GetField<float>(VT_ALPHA, 0.0f); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
};

struct LeakyReluOptionsBuilder
{
  typedef LeakyReluOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) { fbb_.AddElement<float>(LeakyReluOptions::VT_ALPHA, alpha, 0.0f); }
  explicit LeakyReluOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LeakyReluOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LeakyReluOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LeakyReluOptions>
CreateLeakyReluOptions(::flatbuffers::FlatBufferBuilder &_fbb, float alpha = 0.0f)
{
  LeakyReluOptionsBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct SquaredDifferenceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SquaredDifferenceOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SquaredDifferenceOptionsBuilder
{
  typedef SquaredDifferenceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SquaredDifferenceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SquaredDifferenceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SquaredDifferenceOptions>
CreateSquaredDifferenceOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  SquaredDifferenceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef MirrorPadOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_MODE = 4
  };
  circle::MirrorPadMode mode() const
  {
    return static_cast<circle::MirrorPadMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           verifier.EndTable();
  }
};

struct MirrorPadOptionsBuilder
{
  typedef MirrorPadOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(circle::MirrorPadMode mode)
  {
    fbb_.AddElement<int8_t>(MirrorPadOptions::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit MirrorPadOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MirrorPadOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MirrorPadOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MirrorPadOptions>
CreateMirrorPadOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                       circle::MirrorPadMode mode = circle::MirrorPadMode_REFLECT)
{
  MirrorPadOptionsBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct UniqueOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef UniqueOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_IDX_OUT_TYPE = 4
  };
  circle::TensorType idx_out_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_IDX_OUT_TYPE, 2));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_IDX_OUT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct UniqueOptionsBuilder
{
  typedef UniqueOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_idx_out_type(circle::TensorType idx_out_type)
  {
    fbb_.AddElement<int8_t>(UniqueOptions::VT_IDX_OUT_TYPE, static_cast<int8_t>(idx_out_type), 2);
  }
  explicit UniqueOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueOptions>
CreateUniqueOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                    circle::TensorType idx_out_type = circle::TensorType_INT32)
{
  UniqueOptionsBuilder builder_(_fbb);
  builder_.add_idx_out_type(idx_out_type);
  return builder_.Finish();
}

struct ReverseV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ReverseV2OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ReverseV2OptionsBuilder
{
  typedef ReverseV2Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ReverseV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReverseV2Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReverseV2Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReverseV2Options>
CreateReverseV2Options(::flatbuffers::FlatBufferBuilder &_fbb)
{
  ReverseV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AddNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef AddNOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct AddNOptionsBuilder
{
  typedef AddNOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit AddNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddNOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddNOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddNOptions> CreateAddNOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  AddNOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GatherNdOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef GatherNdOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct GatherNdOptionsBuilder
{
  typedef GatherNdOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GatherNdOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GatherNdOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GatherNdOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GatherNdOptions>
CreateGatherNdOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  GatherNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WhereOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef WhereOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct WhereOptionsBuilder
{
  typedef WhereOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit WhereOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhereOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhereOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhereOptions>
CreateWhereOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  WhereOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReverseSequenceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ReverseSequenceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SEQ_DIM = 4,
    VT_BATCH_DIM = 6
  };
  int32_t seq_dim() const { return GetField<int32_t>(VT_SEQ_DIM, 0); }
  int32_t batch_dim() const { return GetField<int32_t>(VT_BATCH_DIM, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_SEQ_DIM, 4) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIM, 4) && verifier.EndTable();
  }
};

struct ReverseSequenceOptionsBuilder
{
  typedef ReverseSequenceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_seq_dim(int32_t seq_dim)
  {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);
  }
  void add_batch_dim(int32_t batch_dim)
  {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim, 0);
  }
  explicit ReverseSequenceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReverseSequenceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReverseSequenceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReverseSequenceOptions>
CreateReverseSequenceOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t seq_dim = 0,
                             int32_t batch_dim = 0)
{
  ReverseSequenceOptionsBuilder builder_(_fbb);
  builder_.add_batch_dim(batch_dim);
  builder_.add_seq_dim(seq_dim);
  return builder_.Finish();
}

struct MatrixDiagOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef MatrixDiagOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct MatrixDiagOptionsBuilder
{
  typedef MatrixDiagOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit MatrixDiagOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MatrixDiagOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MatrixDiagOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MatrixDiagOptions>
CreateMatrixDiagOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  MatrixDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct QuantizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef QuantizeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct QuantizeOptionsBuilder
{
  typedef QuantizeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit QuantizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizeOptions>
CreateQuantizeOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  QuantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MatrixSetDiagOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef MatrixSetDiagOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct MatrixSetDiagOptionsBuilder
{
  typedef MatrixSetDiagOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit MatrixSetDiagOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MatrixSetDiagOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MatrixSetDiagOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MatrixSetDiagOptions>
CreateMatrixSetDiagOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  MatrixSetDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct IfOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef IfOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_THEN_SUBGRAPH_INDEX = 4,
    VT_ELSE_SUBGRAPH_INDEX = 6
  };
  int32_t then_subgraph_index() const { return GetField<int32_t>(VT_THEN_SUBGRAPH_INDEX, 0); }
  int32_t else_subgraph_index() const { return GetField<int32_t>(VT_ELSE_SUBGRAPH_INDEX, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_THEN_SUBGRAPH_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_ELSE_SUBGRAPH_INDEX, 4) && verifier.EndTable();
  }
};

struct IfOptionsBuilder
{
  typedef IfOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_then_subgraph_index(int32_t then_subgraph_index)
  {
    fbb_.AddElement<int32_t>(IfOptions::VT_THEN_SUBGRAPH_INDEX, then_subgraph_index, 0);
  }
  void add_else_subgraph_index(int32_t else_subgraph_index)
  {
    fbb_.AddElement<int32_t>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, else_subgraph_index, 0);
  }
  explicit IfOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IfOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IfOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IfOptions> CreateIfOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                                                        int32_t then_subgraph_index = 0,
                                                        int32_t else_subgraph_index = 0)
{
  IfOptionsBuilder builder_(_fbb);
  builder_.add_else_subgraph_index(else_subgraph_index);
  builder_.add_then_subgraph_index(then_subgraph_index);
  return builder_.Finish();
}

struct CallOnceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef CallOnceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_INIT_SUBGRAPH_INDEX = 4
  };
  int32_t init_subgraph_index() const { return GetField<int32_t>(VT_INIT_SUBGRAPH_INDEX, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INIT_SUBGRAPH_INDEX, 4) && verifier.EndTable();
  }
};

struct CallOnceOptionsBuilder
{
  typedef CallOnceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_init_subgraph_index(int32_t init_subgraph_index)
  {
    fbb_.AddElement<int32_t>(CallOnceOptions::VT_INIT_SUBGRAPH_INDEX, init_subgraph_index, 0);
  }
  explicit CallOnceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CallOnceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CallOnceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CallOnceOptions>
CreateCallOnceOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t init_subgraph_index = 0)
{
  CallOnceOptionsBuilder builder_(_fbb);
  builder_.add_init_subgraph_index(init_subgraph_index);
  return builder_.Finish();
}

struct WhileOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef WhileOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_COND_SUBGRAPH_INDEX = 4,
    VT_BODY_SUBGRAPH_INDEX = 6
  };
  int32_t cond_subgraph_index() const { return GetField<int32_t>(VT_COND_SUBGRAPH_INDEX, 0); }
  int32_t body_subgraph_index() const { return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COND_SUBGRAPH_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX, 4) && verifier.EndTable();
  }
};

struct WhileOptionsBuilder
{
  typedef WhileOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cond_subgraph_index(int32_t cond_subgraph_index)
  {
    fbb_.AddElement<int32_t>(WhileOptions::VT_COND_SUBGRAPH_INDEX, cond_subgraph_index, 0);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index)
  {
    fbb_.AddElement<int32_t>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
  }
  explicit WhileOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhileOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhileOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhileOptions>
CreateWhileOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t cond_subgraph_index = 0,
                   int32_t body_subgraph_index = 0)
{
  WhileOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_cond_subgraph_index(cond_subgraph_index);
  return builder_.Finish();
}

struct NonMaxSuppressionV4Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef NonMaxSuppressionV4OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct NonMaxSuppressionV4OptionsBuilder
{
  typedef NonMaxSuppressionV4Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV4OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NonMaxSuppressionV4Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NonMaxSuppressionV4Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NonMaxSuppressionV4Options>
CreateNonMaxSuppressionV4Options(::flatbuffers::FlatBufferBuilder &_fbb)
{
  NonMaxSuppressionV4OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NonMaxSuppressionV5Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef NonMaxSuppressionV5OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct NonMaxSuppressionV5OptionsBuilder
{
  typedef NonMaxSuppressionV5Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV5OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NonMaxSuppressionV5Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NonMaxSuppressionV5Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NonMaxSuppressionV5Options>
CreateNonMaxSuppressionV5Options(::flatbuffers::FlatBufferBuilder &_fbb)
{
  NonMaxSuppressionV5OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ScatterNdOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ScatterNdOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ScatterNdOptionsBuilder
{
  typedef ScatterNdOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ScatterNdOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScatterNdOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScatterNdOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScatterNdOptions>
CreateScatterNdOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  ScatterNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SelectV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SelectV2OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SelectV2OptionsBuilder
{
  typedef SelectV2Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SelectV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SelectV2Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SelectV2Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SelectV2Options>
CreateSelectV2Options(::flatbuffers::FlatBufferBuilder &_fbb)
{
  SelectV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DensifyOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef DensifyOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct DensifyOptionsBuilder
{
  typedef DensifyOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit DensifyOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DensifyOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DensifyOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DensifyOptions>
CreateDensifyOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  DensifyOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SegmentSumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SegmentSumOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SegmentSumOptionsBuilder
{
  typedef SegmentSumOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SegmentSumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SegmentSumOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SegmentSumOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SegmentSumOptions>
CreateSegmentSumOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  SegmentSumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchMatMulOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef BatchMatMulOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_ADJOINT_LHS = 4,
    VT_ADJOINT_RHS = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool adjoint_lhs() const { return GetField<uint8_t>(VT_ADJOINT_LHS, 0) != 0; }
  bool adjoint_rhs() const { return GetField<uint8_t>(VT_ADJOINT_RHS, 0) != 0; }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ADJOINT_LHS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ADJOINT_RHS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) && verifier.EndTable();
  }
};

struct BatchMatMulOptionsBuilder
{
  typedef BatchMatMulOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_adjoint_lhs(bool adjoint_lhs)
  {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJOINT_LHS, static_cast<uint8_t>(adjoint_lhs),
                             0);
  }
  void add_adjoint_rhs(bool adjoint_rhs)
  {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJOINT_RHS, static_cast<uint8_t>(adjoint_rhs),
                             0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BatchMatMulOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchMatMulOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchMatMulOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchMatMulOptions>
CreateBatchMatMulOptions(::flatbuffers::FlatBufferBuilder &_fbb, bool adjoint_lhs = false,
                         bool adjoint_rhs = false, bool asymmetric_quantize_inputs = false)
{
  BatchMatMulOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_adjoint_rhs(adjoint_rhs);
  builder_.add_adjoint_lhs(adjoint_lhs);
  return builder_.Finish();
}

struct CumsumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef CumsumOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_EXCLUSIVE = 4,
    VT_REVERSE = 6
  };
  bool exclusive() const { return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0; }
  bool reverse() const { return GetField<uint8_t>(VT_REVERSE, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_EXCLUSIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE, 1) && verifier.EndTable();
  }
};

struct CumsumOptionsBuilder
{
  typedef CumsumOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive)
  {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse)
  {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
  }
  explicit CumsumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CumsumOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CumsumOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CumsumOptions>
CreateCumsumOptions(::flatbuffers::FlatBufferBuilder &_fbb, bool exclusive = false,
                    bool reverse = false)
{
  CumsumOptionsBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

struct BroadcastToOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef BroadcastToOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct BroadcastToOptionsBuilder
{
  typedef BroadcastToOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BroadcastToOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BroadcastToOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BroadcastToOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BroadcastToOptions>
CreateBroadcastToOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  BroadcastToOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Rfft2dOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef Rfft2dOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct Rfft2dOptionsBuilder
{
  typedef Rfft2dOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit Rfft2dOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Rfft2dOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Rfft2dOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Rfft2dOptions>
CreateRfft2dOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  Rfft2dOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HashtableOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef HashtableOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TABLE_ID = 4,
    VT_KEY_DTYPE = 6,
    VT_VALUE_DTYPE = 8
  };
  int32_t table_id() const { return GetField<int32_t>(VT_TABLE_ID, 0); }
  circle::TensorType key_dtype() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_KEY_DTYPE, 0));
  }
  circle::TensorType value_dtype() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_VALUE_DTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_TABLE_ID, 4) &&
           VerifyField<int8_t>(verifier, VT_KEY_DTYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_VALUE_DTYPE, 1) && verifier.EndTable();
  }
};

struct HashtableOptionsBuilder
{
  typedef HashtableOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_table_id(int32_t table_id)
  {
    fbb_.AddElement<int32_t>(HashtableOptions::VT_TABLE_ID, table_id, 0);
  }
  void add_key_dtype(circle::TensorType key_dtype)
  {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_KEY_DTYPE, static_cast<int8_t>(key_dtype), 0);
  }
  void add_value_dtype(circle::TensorType value_dtype)
  {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_VALUE_DTYPE, static_cast<int8_t>(value_dtype), 0);
  }
  explicit HashtableOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HashtableOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HashtableOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HashtableOptions>
CreateHashtableOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t table_id = 0,
                       circle::TensorType key_dtype = circle::TensorType_FLOAT32,
                       circle::TensorType value_dtype = circle::TensorType_FLOAT32)
{
  HashtableOptionsBuilder builder_(_fbb);
  builder_.add_table_id(table_id);
  builder_.add_value_dtype(value_dtype);
  builder_.add_key_dtype(key_dtype);
  return builder_.Finish();
}

struct HashtableFindOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef HashtableFindOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct HashtableFindOptionsBuilder
{
  typedef HashtableFindOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HashtableFindOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HashtableFindOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HashtableFindOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HashtableFindOptions>
CreateHashtableFindOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  HashtableFindOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HashtableImportOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef HashtableImportOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct HashtableImportOptionsBuilder
{
  typedef HashtableImportOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HashtableImportOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HashtableImportOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HashtableImportOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HashtableImportOptions>
CreateHashtableImportOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  HashtableImportOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HashtableSizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef HashtableSizeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct HashtableSizeOptionsBuilder
{
  typedef HashtableSizeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HashtableSizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HashtableSizeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HashtableSizeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HashtableSizeOptions>
CreateHashtableSizeOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  HashtableSizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct VarHandleOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef VarHandleOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_CONTAINER = 4,
    VT_SHARED_NAME = 6
  };
  const ::flatbuffers::String *container() const
  {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTAINER);
  }
  const ::flatbuffers::String *shared_name() const
  {
    return GetPointer<const ::flatbuffers::String *>(VT_SHARED_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CONTAINER) &&
           verifier.VerifyString(container()) && VerifyOffset(verifier, VT_SHARED_NAME) &&
           verifier.VerifyString(shared_name()) && verifier.EndTable();
  }
};

struct VarHandleOptionsBuilder
{
  typedef VarHandleOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_container(::flatbuffers::Offset<::flatbuffers::String> container)
  {
    fbb_.AddOffset(VarHandleOptions::VT_CONTAINER, container);
  }
  void add_shared_name(::flatbuffers::Offset<::flatbuffers::String> shared_name)
  {
    fbb_.AddOffset(VarHandleOptions::VT_SHARED_NAME, shared_name);
  }
  explicit VarHandleOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VarHandleOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VarHandleOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VarHandleOptions>
CreateVarHandleOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                       ::flatbuffers::Offset<::flatbuffers::String> container = 0,
                       ::flatbuffers::Offset<::flatbuffers::String> shared_name = 0)
{
  VarHandleOptionsBuilder builder_(_fbb);
  builder_.add_shared_name(shared_name);
  builder_.add_container(container);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VarHandleOptions>
CreateVarHandleOptionsDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                             const char *container = nullptr, const char *shared_name = nullptr)
{
  auto container__ = container ? _fbb.CreateString(container) : 0;
  auto shared_name__ = shared_name ? _fbb.CreateString(shared_name) : 0;
  return circle::CreateVarHandleOptions(_fbb, container__, shared_name__);
}

struct ReadVariableOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ReadVariableOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ReadVariableOptionsBuilder
{
  typedef ReadVariableOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ReadVariableOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadVariableOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadVariableOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadVariableOptions>
CreateReadVariableOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  ReadVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AssignVariableOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef AssignVariableOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct AssignVariableOptionsBuilder
{
  typedef AssignVariableOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit AssignVariableOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AssignVariableOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AssignVariableOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AssignVariableOptions>
CreateAssignVariableOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  AssignVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RandomOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef RandomOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SEED = 4,
    VT_SEED2 = 6
  };
  int64_t seed() const { return GetField<int64_t>(VT_SEED, 0); }
  int64_t seed2() const { return GetField<int64_t>(VT_SEED2, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_SEED, 8) &&
           VerifyField<int64_t>(verifier, VT_SEED2, 8) && verifier.EndTable();
  }
};

struct RandomOptionsBuilder
{
  typedef RandomOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_seed(int64_t seed) { fbb_.AddElement<int64_t>(RandomOptions::VT_SEED, seed, 0); }
  void add_seed2(int64_t seed2) { fbb_.AddElement<int64_t>(RandomOptions::VT_SEED2, seed2, 0); }
  explicit RandomOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RandomOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RandomOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RandomOptions>
CreateRandomOptions(::flatbuffers::FlatBufferBuilder &_fbb, int64_t seed = 0, int64_t seed2 = 0)
{
  RandomOptionsBuilder builder_(_fbb);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

struct BucketizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef BucketizeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_BOUNDARIES = 4
  };
  const ::flatbuffers::Vector<float> *boundaries() const
  {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BOUNDARIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_BOUNDARIES) &&
           verifier.VerifyVector(boundaries()) && verifier.EndTable();
  }
};

struct BucketizeOptionsBuilder
{
  typedef BucketizeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_boundaries(::flatbuffers::Offset<::flatbuffers::Vector<float>> boundaries)
  {
    fbb_.AddOffset(BucketizeOptions::VT_BOUNDARIES, boundaries);
  }
  explicit BucketizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BucketizeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BucketizeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BucketizeOptions>
CreateBucketizeOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                       ::flatbuffers::Offset<::flatbuffers::Vector<float>> boundaries = 0)
{
  BucketizeOptionsBuilder builder_(_fbb);
  builder_.add_boundaries(boundaries);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BucketizeOptions>
CreateBucketizeOptionsDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                             const std::vector<float> *boundaries = nullptr)
{
  auto boundaries__ = boundaries ? _fbb.CreateVector<float>(*boundaries) : 0;
  return circle::CreateBucketizeOptions(_fbb, boundaries__);
}

struct GeluOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef GeluOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_APPROXIMATE = 4
  };
  bool approximate() const { return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_APPROXIMATE, 1) &&
           verifier.EndTable();
  }
};

struct GeluOptionsBuilder
{
  typedef GeluOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_approximate(bool approximate)
  {
    fbb_.AddElement<uint8_t>(GeluOptions::VT_APPROXIMATE, static_cast<uint8_t>(approximate), 0);
  }
  explicit GeluOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeluOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeluOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GeluOptions> CreateGeluOptions(::flatbuffers::FlatBufferBuilder &_fbb,
                                                            bool approximate = false)
{
  GeluOptionsBuilder builder_(_fbb);
  builder_.add_approximate(approximate);
  return builder_.Finish();
}

struct DynamicUpdateSliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef DynamicUpdateSliceOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct DynamicUpdateSliceOptionsBuilder
{
  typedef DynamicUpdateSliceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit DynamicUpdateSliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DynamicUpdateSliceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DynamicUpdateSliceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DynamicUpdateSliceOptions>
CreateDynamicUpdateSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  DynamicUpdateSliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnsortedSegmentProdOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef UnsortedSegmentProdOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct UnsortedSegmentProdOptionsBuilder
{
  typedef UnsortedSegmentProdOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentProdOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnsortedSegmentProdOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnsortedSegmentProdOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnsortedSegmentProdOptions>
CreateUnsortedSegmentProdOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  UnsortedSegmentProdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnsortedSegmentMaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef UnsortedSegmentMaxOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct UnsortedSegmentMaxOptionsBuilder
{
  typedef UnsortedSegmentMaxOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentMaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnsortedSegmentMaxOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnsortedSegmentMaxOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnsortedSegmentMaxOptions>
CreateUnsortedSegmentMaxOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  UnsortedSegmentMaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnsortedSegmentSumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef UnsortedSegmentSumOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct UnsortedSegmentSumOptionsBuilder
{
  typedef UnsortedSegmentSumOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentSumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnsortedSegmentSumOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnsortedSegmentSumOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnsortedSegmentSumOptions>
CreateUnsortedSegmentSumOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  UnsortedSegmentSumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ATan2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ATan2OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ATan2OptionsBuilder
{
  typedef ATan2Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ATan2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ATan2Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ATan2Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ATan2Options>
CreateATan2Options(::flatbuffers::FlatBufferBuilder &_fbb)
{
  ATan2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnsortedSegmentMinOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef UnsortedSegmentMinOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct UnsortedSegmentMinOptionsBuilder
{
  typedef UnsortedSegmentMinOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentMinOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnsortedSegmentMinOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnsortedSegmentMinOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnsortedSegmentMinOptions>
CreateUnsortedSegmentMinOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  UnsortedSegmentMinOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SignOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SignOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SignOptionsBuilder
{
  typedef SignOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SignOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SignOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SignOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SignOptions> CreateSignOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  SignOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BitcastOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef BitcastOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct BitcastOptionsBuilder
{
  typedef BitcastOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BitcastOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BitcastOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BitcastOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BitcastOptions>
CreateBitcastOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  BitcastOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BitwiseXorOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef BitwiseXorOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct BitwiseXorOptionsBuilder
{
  typedef BitwiseXorOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BitwiseXorOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BitwiseXorOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BitwiseXorOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BitwiseXorOptions>
CreateBitwiseXorOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  BitwiseXorOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RightShiftOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef RightShiftOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct RightShiftOptionsBuilder
{
  typedef RightShiftOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RightShiftOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RightShiftOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RightShiftOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RightShiftOptions>
CreateRightShiftOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  RightShiftOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DilateOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef DilateOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct DilateOptionsBuilder
{
  typedef DilateOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit DilateOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DilateOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DilateOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DilateOptions>
CreateDilateOptions(::flatbuffers::FlatBufferBuilder &_fbb)
{
  DilateOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReduceWindowOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ReduceWindowOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_REDUCE_FUNCTION = 4
  };
  circle::ReduceWindowFunction reduce_function() const
  {
    return static_cast<circle::ReduceWindowFunction>(GetField<int32_t>(VT_REDUCE_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_REDUCE_FUNCTION, 4) &&
           verifier.EndTable();
  }
};

struct ReduceWindowOptionsBuilder
{
  typedef ReduceWindowOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reduce_function(circle::ReduceWindowFunction reduce_function)
  {
    fbb_.AddElement<int32_t>(ReduceWindowOptions::VT_REDUCE_FUNCTION,
                             static_cast<int32_t>(reduce_function), 0);
  }
  explicit ReduceWindowOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReduceWindowOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReduceWindowOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReduceWindowOptions> CreateReduceWindowOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ReduceWindowFunction reduce_function = circle::ReduceWindowFunction_UNSUPPORTED)
{
  ReduceWindowOptionsBuilder builder_(_fbb);
  builder_.add_reduce_function(reduce_function);
  return builder_.Finish();
}

struct GRUOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef GRUOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_RETURN_SEQUENCES = 6,
    VT_TIME_MAJOR = 8
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool return_sequences() const { return GetField<uint8_t>(VT_RETURN_SEQUENCES, 0) != 0; }
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0; }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_RETURN_SEQUENCES, 1) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR, 1) && verifier.EndTable();
  }
};

struct GRUOptionsBuilder
{
  typedef GRUOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(GRUOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_return_sequences(bool return_sequences)
  {
    fbb_.AddElement<uint8_t>(GRUOptions::VT_RETURN_SEQUENCES,
                             static_cast<uint8_t>(return_sequences), 0);
  }
  void add_time_major(bool time_major)
  {
    fbb_.AddElement<uint8_t>(GRUOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  explicit GRUOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GRUOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GRUOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GRUOptions> CreateGRUOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool return_sequences = false, bool time_major = false)
{
  GRUOptionsBuilder builder_(_fbb);
  builder_.add_time_major(time_major);
  builder_.add_return_sequences(return_sequences);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct BCQGatherOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef BCQGatherOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_INPUT_HIDDEN_SIZE = 4,
    VT_AXIS = 6
  };
  int32_t input_hidden_size() const { return GetField<int32_t>(VT_INPUT_HIDDEN_SIZE, 0); }
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_INPUT_HIDDEN_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) && verifier.EndTable();
  }
};

struct BCQGatherOptionsBuilder
{
  typedef BCQGatherOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_input_hidden_size(int32_t input_hidden_size)
  {
    fbb_.AddElement<int32_t>(BCQGatherOptions::VT_INPUT_HIDDEN_SIZE, input_hidden_size, 0);
  }
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(BCQGatherOptions::VT_AXIS, axis, 0); }
  explicit BCQGatherOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BCQGatherOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BCQGatherOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BCQGatherOptions>
CreateBCQGatherOptions(::flatbuffers::FlatBufferBuilder &_fbb, int32_t input_hidden_size = 0,
                       int32_t axis = 0)
{
  BCQGatherOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_input_hidden_size(input_hidden_size);
  return builder_.Finish();
}

struct BCQFullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef BCQFullyConnectedOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_WEIGHTS_HIDDEN_SIZE = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t weights_hidden_size() const { return GetField<int32_t>(VT_WEIGHTS_HIDDEN_SIZE, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTS_HIDDEN_SIZE, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) && verifier.EndTable();
  }
};

struct BCQFullyConnectedOptionsBuilder
{
  typedef BCQFullyConnectedOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_weights_hidden_size(int32_t weights_hidden_size)
  {
    fbb_.AddElement<int32_t>(BCQFullyConnectedOptions::VT_WEIGHTS_HIDDEN_SIZE, weights_hidden_size,
                             0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(BCQFullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit BCQFullyConnectedOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BCQFullyConnectedOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BCQFullyConnectedOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BCQFullyConnectedOptions> CreateBCQFullyConnectedOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, int32_t weights_hidden_size = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  BCQFullyConnectedOptionsBuilder builder_(_fbb);
  builder_.add_weights_hidden_size(weights_hidden_size);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct InstanceNormOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef InstanceNormOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_EPSILON = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  float epsilon() const { return GetField<float>(VT_EPSILON, 0.0f); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_EPSILON, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) && verifier.EndTable();
  }
};

struct InstanceNormOptionsBuilder
{
  typedef InstanceNormOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon)
  {
    fbb_.AddElement<float>(InstanceNormOptions::VT_EPSILON, epsilon, 0.0f);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(InstanceNormOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit InstanceNormOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InstanceNormOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InstanceNormOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InstanceNormOptions> CreateInstanceNormOptions(
  ::flatbuffers::FlatBufferBuilder &_fbb, float epsilon = 0.0f,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  InstanceNormOptionsBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct OperatorCode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef OperatorCodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_DEPRECATED_BUILTIN_CODE = 4,
    VT_CUSTOM_CODE = 6,
    VT_VERSION = 8,
    VT_BUILTIN_CODE = 10
  };
  int8_t deprecated_builtin_code() const { return GetField<int8_t>(VT_DEPRECATED_BUILTIN_CODE, 0); }
  const ::flatbuffers::String *custom_code() const
  {
    return GetPointer<const ::flatbuffers::String *>(VT_CUSTOM_CODE);
  }
  int32_t version() const { return GetField<int32_t>(VT_VERSION, 1); }
  circle::BuiltinOperator builtin_code() const
  {
    return static_cast<circle::BuiltinOperator>(GetField<int32_t>(VT_BUILTIN_CODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DEPRECATED_BUILTIN_CODE, 1) &&
           VerifyOffset(verifier, VT_CUSTOM_CODE) && verifier.VerifyString(custom_code()) &&
           VerifyField<int32_t>(verifier, VT_VERSION, 4) &&
           VerifyField<int32_t>(verifier, VT_BUILTIN_CODE, 4) && verifier.EndTable();
  }
};

struct OperatorCodeBuilder
{
  typedef OperatorCode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_deprecated_builtin_code(int8_t deprecated_builtin_code)
  {
    fbb_.AddElement<int8_t>(OperatorCode::VT_DEPRECATED_BUILTIN_CODE, deprecated_builtin_code, 0);
  }
  void add_custom_code(::flatbuffers::Offset<::flatbuffers::String> custom_code)
  {
    fbb_.AddOffset(OperatorCode::VT_CUSTOM_CODE, custom_code);
  }
  void add_version(int32_t version)
  {
    fbb_.AddElement<int32_t>(OperatorCode::VT_VERSION, version, 1);
  }
  void add_builtin_code(circle::BuiltinOperator builtin_code)
  {
    fbb_.AddElement<int32_t>(OperatorCode::VT_BUILTIN_CODE, static_cast<int32_t>(builtin_code), 0);
  }
  explicit OperatorCodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OperatorCode> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OperatorCode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OperatorCode>
CreateOperatorCode(::flatbuffers::FlatBufferBuilder &_fbb, int8_t deprecated_builtin_code = 0,
                   ::flatbuffers::Offset<::flatbuffers::String> custom_code = 0,
                   int32_t version = 1,
                   circle::BuiltinOperator builtin_code = circle::BuiltinOperator_ADD)
{
  OperatorCodeBuilder builder_(_fbb);
  builder_.add_builtin_code(builtin_code);
  builder_.add_version(version);
  builder_.add_custom_code(custom_code);
  builder_.add_deprecated_builtin_code(deprecated_builtin_code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OperatorCode>
CreateOperatorCodeDirect(::flatbuffers::FlatBufferBuilder &_fbb, int8_t deprecated_builtin_code = 0,
                         const char *custom_code = nullptr, int32_t version = 1,
                         circle::BuiltinOperator builtin_code = circle::BuiltinOperator_ADD)
{
  auto custom_code__ = custom_code ? _fbb.CreateString(custom_code) : 0;
  return circle::CreateOperatorCode(_fbb, deprecated_builtin_code, custom_code__, version,
                                    builtin_code);
}

struct Operator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef OperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_OPCODE_INDEX = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_BUILTIN_OPTIONS_TYPE = 10,
    VT_BUILTIN_OPTIONS = 12,
    VT_CUSTOM_OPTIONS = 14,
    VT_CUSTOM_OPTIONS_FORMAT = 16,
    VT_MUTATING_VARIABLE_INPUTS = 18,
    VT_INTERMEDIATES = 20,
    VT_LARGE_CUSTOM_OPTIONS_OFFSET = 22,
    VT_LARGE_CUSTOM_OPTIONS_SIZE = 24,
    VT_BUILTIN_OPTIONS_2_TYPE = 26,
    VT_BUILTIN_OPTIONS_2 = 28
  };
  uint32_t opcode_index() const { return GetField<uint32_t>(VT_OPCODE_INDEX, 0); }
  const ::flatbuffers::Vector<int32_t> *inputs() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<int32_t> *outputs() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  circle::BuiltinOptions builtin_options_type() const
  {
    return static_cast<circle::BuiltinOptions>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_TYPE, 0));
  }
  const void *builtin_options() const { return GetPointer<const void *>(VT_BUILTIN_OPTIONS); }
  template <typename T> const T *builtin_options_as() const;
  const circle::Conv2DOptions *builtin_options_as_Conv2DOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_Conv2DOptions
             ? static_cast<const circle::Conv2DOptions *>(builtin_options())
             : nullptr;
  }
  const circle::DepthwiseConv2DOptions *builtin_options_as_DepthwiseConv2DOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_DepthwiseConv2DOptions
             ? static_cast<const circle::DepthwiseConv2DOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ConcatEmbeddingsOptions *builtin_options_as_ConcatEmbeddingsOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ConcatEmbeddingsOptions
             ? static_cast<const circle::ConcatEmbeddingsOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LSHProjectionOptions *builtin_options_as_LSHProjectionOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LSHProjectionOptions
             ? static_cast<const circle::LSHProjectionOptions *>(builtin_options())
             : nullptr;
  }
  const circle::Pool2DOptions *builtin_options_as_Pool2DOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_Pool2DOptions
             ? static_cast<const circle::Pool2DOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SVDFOptions *builtin_options_as_SVDFOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SVDFOptions
             ? static_cast<const circle::SVDFOptions *>(builtin_options())
             : nullptr;
  }
  const circle::RNNOptions *builtin_options_as_RNNOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_RNNOptions
             ? static_cast<const circle::RNNOptions *>(builtin_options())
             : nullptr;
  }
  const circle::FullyConnectedOptions *builtin_options_as_FullyConnectedOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_FullyConnectedOptions
             ? static_cast<const circle::FullyConnectedOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SoftmaxOptions *builtin_options_as_SoftmaxOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SoftmaxOptions
             ? static_cast<const circle::SoftmaxOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ConcatenationOptions *builtin_options_as_ConcatenationOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ConcatenationOptions
             ? static_cast<const circle::ConcatenationOptions *>(builtin_options())
             : nullptr;
  }
  const circle::AddOptions *builtin_options_as_AddOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_AddOptions
             ? static_cast<const circle::AddOptions *>(builtin_options())
             : nullptr;
  }
  const circle::L2NormOptions *builtin_options_as_L2NormOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_L2NormOptions
             ? static_cast<const circle::L2NormOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LocalResponseNormalizationOptions *
  builtin_options_as_LocalResponseNormalizationOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LocalResponseNormalizationOptions
             ? static_cast<const circle::LocalResponseNormalizationOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LSTMOptions *builtin_options_as_LSTMOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LSTMOptions
             ? static_cast<const circle::LSTMOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ResizeBilinearOptions *builtin_options_as_ResizeBilinearOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ResizeBilinearOptions
             ? static_cast<const circle::ResizeBilinearOptions *>(builtin_options())
             : nullptr;
  }
  const circle::CallOptions *builtin_options_as_CallOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_CallOptions
             ? static_cast<const circle::CallOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ReshapeOptions *builtin_options_as_ReshapeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ReshapeOptions
             ? static_cast<const circle::ReshapeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SkipGramOptions *builtin_options_as_SkipGramOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SkipGramOptions
             ? static_cast<const circle::SkipGramOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SpaceToDepthOptions *builtin_options_as_SpaceToDepthOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SpaceToDepthOptions
             ? static_cast<const circle::SpaceToDepthOptions *>(builtin_options())
             : nullptr;
  }
  const circle::EmbeddingLookupSparseOptions *
  builtin_options_as_EmbeddingLookupSparseOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_EmbeddingLookupSparseOptions
             ? static_cast<const circle::EmbeddingLookupSparseOptions *>(builtin_options())
             : nullptr;
  }
  const circle::MulOptions *builtin_options_as_MulOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_MulOptions
             ? static_cast<const circle::MulOptions *>(builtin_options())
             : nullptr;
  }
  const circle::PadOptions *builtin_options_as_PadOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_PadOptions
             ? static_cast<const circle::PadOptions *>(builtin_options())
             : nullptr;
  }
  const circle::GatherOptions *builtin_options_as_GatherOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_GatherOptions
             ? static_cast<const circle::GatherOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BatchToSpaceNDOptions *builtin_options_as_BatchToSpaceNDOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BatchToSpaceNDOptions
             ? static_cast<const circle::BatchToSpaceNDOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SpaceToBatchNDOptions *builtin_options_as_SpaceToBatchNDOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SpaceToBatchNDOptions
             ? static_cast<const circle::SpaceToBatchNDOptions *>(builtin_options())
             : nullptr;
  }
  const circle::TransposeOptions *builtin_options_as_TransposeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_TransposeOptions
             ? static_cast<const circle::TransposeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ReducerOptions *builtin_options_as_ReducerOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ReducerOptions
             ? static_cast<const circle::ReducerOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SubOptions *builtin_options_as_SubOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SubOptions
             ? static_cast<const circle::SubOptions *>(builtin_options())
             : nullptr;
  }
  const circle::DivOptions *builtin_options_as_DivOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_DivOptions
             ? static_cast<const circle::DivOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SqueezeOptions *builtin_options_as_SqueezeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SqueezeOptions
             ? static_cast<const circle::SqueezeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SequenceRNNOptions *builtin_options_as_SequenceRNNOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SequenceRNNOptions
             ? static_cast<const circle::SequenceRNNOptions *>(builtin_options())
             : nullptr;
  }
  const circle::StridedSliceOptions *builtin_options_as_StridedSliceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_StridedSliceOptions
             ? static_cast<const circle::StridedSliceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ExpOptions *builtin_options_as_ExpOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ExpOptions
             ? static_cast<const circle::ExpOptions *>(builtin_options())
             : nullptr;
  }
  const circle::TopKV2Options *builtin_options_as_TopKV2Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_TopKV2Options
             ? static_cast<const circle::TopKV2Options *>(builtin_options())
             : nullptr;
  }
  const circle::SplitOptions *builtin_options_as_SplitOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SplitOptions
             ? static_cast<const circle::SplitOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LogSoftmaxOptions *builtin_options_as_LogSoftmaxOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LogSoftmaxOptions
             ? static_cast<const circle::LogSoftmaxOptions *>(builtin_options())
             : nullptr;
  }
  const circle::CastOptions *builtin_options_as_CastOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_CastOptions
             ? static_cast<const circle::CastOptions *>(builtin_options())
             : nullptr;
  }
  const circle::DequantizeOptions *builtin_options_as_DequantizeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_DequantizeOptions
             ? static_cast<const circle::DequantizeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::MaximumMinimumOptions *builtin_options_as_MaximumMinimumOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_MaximumMinimumOptions
             ? static_cast<const circle::MaximumMinimumOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ArgMaxOptions *builtin_options_as_ArgMaxOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ArgMaxOptions
             ? static_cast<const circle::ArgMaxOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LessOptions *builtin_options_as_LessOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LessOptions
             ? static_cast<const circle::LessOptions *>(builtin_options())
             : nullptr;
  }
  const circle::NegOptions *builtin_options_as_NegOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_NegOptions
             ? static_cast<const circle::NegOptions *>(builtin_options())
             : nullptr;
  }
  const circle::PadV2Options *builtin_options_as_PadV2Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_PadV2Options
             ? static_cast<const circle::PadV2Options *>(builtin_options())
             : nullptr;
  }
  const circle::GreaterOptions *builtin_options_as_GreaterOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_GreaterOptions
             ? static_cast<const circle::GreaterOptions *>(builtin_options())
             : nullptr;
  }
  const circle::GreaterEqualOptions *builtin_options_as_GreaterEqualOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_GreaterEqualOptions
             ? static_cast<const circle::GreaterEqualOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LessEqualOptions *builtin_options_as_LessEqualOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LessEqualOptions
             ? static_cast<const circle::LessEqualOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SelectOptions *builtin_options_as_SelectOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SelectOptions
             ? static_cast<const circle::SelectOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SliceOptions *builtin_options_as_SliceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SliceOptions
             ? static_cast<const circle::SliceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::TransposeConvOptions *builtin_options_as_TransposeConvOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_TransposeConvOptions
             ? static_cast<const circle::TransposeConvOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SparseToDenseOptions *builtin_options_as_SparseToDenseOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SparseToDenseOptions
             ? static_cast<const circle::SparseToDenseOptions *>(builtin_options())
             : nullptr;
  }
  const circle::TileOptions *builtin_options_as_TileOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_TileOptions
             ? static_cast<const circle::TileOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ExpandDimsOptions *builtin_options_as_ExpandDimsOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ExpandDimsOptions
             ? static_cast<const circle::ExpandDimsOptions *>(builtin_options())
             : nullptr;
  }
  const circle::EqualOptions *builtin_options_as_EqualOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_EqualOptions
             ? static_cast<const circle::EqualOptions *>(builtin_options())
             : nullptr;
  }
  const circle::NotEqualOptions *builtin_options_as_NotEqualOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_NotEqualOptions
             ? static_cast<const circle::NotEqualOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ShapeOptions *builtin_options_as_ShapeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ShapeOptions
             ? static_cast<const circle::ShapeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::PowOptions *builtin_options_as_PowOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_PowOptions
             ? static_cast<const circle::PowOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ArgMinOptions *builtin_options_as_ArgMinOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ArgMinOptions
             ? static_cast<const circle::ArgMinOptions *>(builtin_options())
             : nullptr;
  }
  const circle::FakeQuantOptions *builtin_options_as_FakeQuantOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_FakeQuantOptions
             ? static_cast<const circle::FakeQuantOptions *>(builtin_options())
             : nullptr;
  }
  const circle::PackOptions *builtin_options_as_PackOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_PackOptions
             ? static_cast<const circle::PackOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LogicalOrOptions *builtin_options_as_LogicalOrOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LogicalOrOptions
             ? static_cast<const circle::LogicalOrOptions *>(builtin_options())
             : nullptr;
  }
  const circle::OneHotOptions *builtin_options_as_OneHotOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_OneHotOptions
             ? static_cast<const circle::OneHotOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LogicalAndOptions *builtin_options_as_LogicalAndOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LogicalAndOptions
             ? static_cast<const circle::LogicalAndOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LogicalNotOptions *builtin_options_as_LogicalNotOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LogicalNotOptions
             ? static_cast<const circle::LogicalNotOptions *>(builtin_options())
             : nullptr;
  }
  const circle::UnpackOptions *builtin_options_as_UnpackOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_UnpackOptions
             ? static_cast<const circle::UnpackOptions *>(builtin_options())
             : nullptr;
  }
  const circle::FloorDivOptions *builtin_options_as_FloorDivOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_FloorDivOptions
             ? static_cast<const circle::FloorDivOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SquareOptions *builtin_options_as_SquareOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SquareOptions
             ? static_cast<const circle::SquareOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ZerosLikeOptions *builtin_options_as_ZerosLikeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ZerosLikeOptions
             ? static_cast<const circle::ZerosLikeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::FillOptions *builtin_options_as_FillOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_FillOptions
             ? static_cast<const circle::FillOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BidirectionalSequenceLSTMOptions *
  builtin_options_as_BidirectionalSequenceLSTMOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BidirectionalSequenceLSTMOptions
             ? static_cast<const circle::BidirectionalSequenceLSTMOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BidirectionalSequenceRNNOptions *
  builtin_options_as_BidirectionalSequenceRNNOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BidirectionalSequenceRNNOptions
             ? static_cast<const circle::BidirectionalSequenceRNNOptions *>(builtin_options())
             : nullptr;
  }
  const circle::UnidirectionalSequenceLSTMOptions *
  builtin_options_as_UnidirectionalSequenceLSTMOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_UnidirectionalSequenceLSTMOptions
             ? static_cast<const circle::UnidirectionalSequenceLSTMOptions *>(builtin_options())
             : nullptr;
  }
  const circle::FloorModOptions *builtin_options_as_FloorModOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_FloorModOptions
             ? static_cast<const circle::FloorModOptions *>(builtin_options())
             : nullptr;
  }
  const circle::RangeOptions *builtin_options_as_RangeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_RangeOptions
             ? static_cast<const circle::RangeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ResizeNearestNeighborOptions *
  builtin_options_as_ResizeNearestNeighborOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ResizeNearestNeighborOptions
             ? static_cast<const circle::ResizeNearestNeighborOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LeakyReluOptions *builtin_options_as_LeakyReluOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LeakyReluOptions
             ? static_cast<const circle::LeakyReluOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SquaredDifferenceOptions *builtin_options_as_SquaredDifferenceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SquaredDifferenceOptions
             ? static_cast<const circle::SquaredDifferenceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::MirrorPadOptions *builtin_options_as_MirrorPadOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_MirrorPadOptions
             ? static_cast<const circle::MirrorPadOptions *>(builtin_options())
             : nullptr;
  }
  const circle::AbsOptions *builtin_options_as_AbsOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_AbsOptions
             ? static_cast<const circle::AbsOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SplitVOptions *builtin_options_as_SplitVOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SplitVOptions
             ? static_cast<const circle::SplitVOptions *>(builtin_options())
             : nullptr;
  }
  const circle::UniqueOptions *builtin_options_as_UniqueOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_UniqueOptions
             ? static_cast<const circle::UniqueOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ReverseV2Options *builtin_options_as_ReverseV2Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ReverseV2Options
             ? static_cast<const circle::ReverseV2Options *>(builtin_options())
             : nullptr;
  }
  const circle::AddNOptions *builtin_options_as_AddNOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_AddNOptions
             ? static_cast<const circle::AddNOptions *>(builtin_options())
             : nullptr;
  }
  const circle::GatherNdOptions *builtin_options_as_GatherNdOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_GatherNdOptions
             ? static_cast<const circle::GatherNdOptions *>(builtin_options())
             : nullptr;
  }
  const circle::CosOptions *builtin_options_as_CosOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_CosOptions
             ? static_cast<const circle::CosOptions *>(builtin_options())
             : nullptr;
  }
  const circle::WhereOptions *builtin_options_as_WhereOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_WhereOptions
             ? static_cast<const circle::WhereOptions *>(builtin_options())
             : nullptr;
  }
  const circle::RankOptions *builtin_options_as_RankOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_RankOptions
             ? static_cast<const circle::RankOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ReverseSequenceOptions *builtin_options_as_ReverseSequenceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ReverseSequenceOptions
             ? static_cast<const circle::ReverseSequenceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::MatrixDiagOptions *builtin_options_as_MatrixDiagOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_MatrixDiagOptions
             ? static_cast<const circle::MatrixDiagOptions *>(builtin_options())
             : nullptr;
  }
  const circle::QuantizeOptions *builtin_options_as_QuantizeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_QuantizeOptions
             ? static_cast<const circle::QuantizeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::MatrixSetDiagOptions *builtin_options_as_MatrixSetDiagOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_MatrixSetDiagOptions
             ? static_cast<const circle::MatrixSetDiagOptions *>(builtin_options())
             : nullptr;
  }
  const circle::HardSwishOptions *builtin_options_as_HardSwishOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_HardSwishOptions
             ? static_cast<const circle::HardSwishOptions *>(builtin_options())
             : nullptr;
  }
  const circle::IfOptions *builtin_options_as_IfOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_IfOptions
             ? static_cast<const circle::IfOptions *>(builtin_options())
             : nullptr;
  }
  const circle::WhileOptions *builtin_options_as_WhileOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_WhileOptions
             ? static_cast<const circle::WhileOptions *>(builtin_options())
             : nullptr;
  }
  const circle::DepthToSpaceOptions *builtin_options_as_DepthToSpaceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_DepthToSpaceOptions
             ? static_cast<const circle::DepthToSpaceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::NonMaxSuppressionV4Options *builtin_options_as_NonMaxSuppressionV4Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_NonMaxSuppressionV4Options
             ? static_cast<const circle::NonMaxSuppressionV4Options *>(builtin_options())
             : nullptr;
  }
  const circle::NonMaxSuppressionV5Options *builtin_options_as_NonMaxSuppressionV5Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_NonMaxSuppressionV5Options
             ? static_cast<const circle::NonMaxSuppressionV5Options *>(builtin_options())
             : nullptr;
  }
  const circle::ScatterNdOptions *builtin_options_as_ScatterNdOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ScatterNdOptions
             ? static_cast<const circle::ScatterNdOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SelectV2Options *builtin_options_as_SelectV2Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SelectV2Options
             ? static_cast<const circle::SelectV2Options *>(builtin_options())
             : nullptr;
  }
  const circle::DensifyOptions *builtin_options_as_DensifyOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_DensifyOptions
             ? static_cast<const circle::DensifyOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SegmentSumOptions *builtin_options_as_SegmentSumOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SegmentSumOptions
             ? static_cast<const circle::SegmentSumOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BatchMatMulOptions *builtin_options_as_BatchMatMulOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BatchMatMulOptions
             ? static_cast<const circle::BatchMatMulOptions *>(builtin_options())
             : nullptr;
  }
  const circle::CumsumOptions *builtin_options_as_CumsumOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_CumsumOptions
             ? static_cast<const circle::CumsumOptions *>(builtin_options())
             : nullptr;
  }
  const circle::CallOnceOptions *builtin_options_as_CallOnceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_CallOnceOptions
             ? static_cast<const circle::CallOnceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BroadcastToOptions *builtin_options_as_BroadcastToOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BroadcastToOptions
             ? static_cast<const circle::BroadcastToOptions *>(builtin_options())
             : nullptr;
  }
  const circle::Rfft2dOptions *builtin_options_as_Rfft2dOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_Rfft2dOptions
             ? static_cast<const circle::Rfft2dOptions *>(builtin_options())
             : nullptr;
  }
  const circle::Conv3DOptions *builtin_options_as_Conv3DOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_Conv3DOptions
             ? static_cast<const circle::Conv3DOptions *>(builtin_options())
             : nullptr;
  }
  const circle::HashtableOptions *builtin_options_as_HashtableOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_HashtableOptions
             ? static_cast<const circle::HashtableOptions *>(builtin_options())
             : nullptr;
  }
  const circle::HashtableFindOptions *builtin_options_as_HashtableFindOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_HashtableFindOptions
             ? static_cast<const circle::HashtableFindOptions *>(builtin_options())
             : nullptr;
  }
  const circle::HashtableImportOptions *builtin_options_as_HashtableImportOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_HashtableImportOptions
             ? static_cast<const circle::HashtableImportOptions *>(builtin_options())
             : nullptr;
  }
  const circle::HashtableSizeOptions *builtin_options_as_HashtableSizeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_HashtableSizeOptions
             ? static_cast<const circle::HashtableSizeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::VarHandleOptions *builtin_options_as_VarHandleOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_VarHandleOptions
             ? static_cast<const circle::VarHandleOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ReadVariableOptions *builtin_options_as_ReadVariableOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ReadVariableOptions
             ? static_cast<const circle::ReadVariableOptions *>(builtin_options())
             : nullptr;
  }
  const circle::AssignVariableOptions *builtin_options_as_AssignVariableOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_AssignVariableOptions
             ? static_cast<const circle::AssignVariableOptions *>(builtin_options())
             : nullptr;
  }
  const circle::RandomOptions *builtin_options_as_RandomOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_RandomOptions
             ? static_cast<const circle::RandomOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BucketizeOptions *builtin_options_as_BucketizeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BucketizeOptions
             ? static_cast<const circle::BucketizeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::GeluOptions *builtin_options_as_GeluOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_GeluOptions
             ? static_cast<const circle::GeluOptions *>(builtin_options())
             : nullptr;
  }
  const circle::DynamicUpdateSliceOptions *builtin_options_as_DynamicUpdateSliceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_DynamicUpdateSliceOptions
             ? static_cast<const circle::DynamicUpdateSliceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::UnsortedSegmentProdOptions *builtin_options_as_UnsortedSegmentProdOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_UnsortedSegmentProdOptions
             ? static_cast<const circle::UnsortedSegmentProdOptions *>(builtin_options())
             : nullptr;
  }
  const circle::UnsortedSegmentMaxOptions *builtin_options_as_UnsortedSegmentMaxOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_UnsortedSegmentMaxOptions
             ? static_cast<const circle::UnsortedSegmentMaxOptions *>(builtin_options())
             : nullptr;
  }
  const circle::UnsortedSegmentMinOptions *builtin_options_as_UnsortedSegmentMinOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_UnsortedSegmentMinOptions
             ? static_cast<const circle::UnsortedSegmentMinOptions *>(builtin_options())
             : nullptr;
  }
  const circle::UnsortedSegmentSumOptions *builtin_options_as_UnsortedSegmentSumOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_UnsortedSegmentSumOptions
             ? static_cast<const circle::UnsortedSegmentSumOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ATan2Options *builtin_options_as_ATan2Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ATan2Options
             ? static_cast<const circle::ATan2Options *>(builtin_options())
             : nullptr;
  }
  const circle::SignOptions *builtin_options_as_SignOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SignOptions
             ? static_cast<const circle::SignOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BitcastOptions *builtin_options_as_BitcastOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BitcastOptions
             ? static_cast<const circle::BitcastOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BitwiseXorOptions *builtin_options_as_BitwiseXorOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BitwiseXorOptions
             ? static_cast<const circle::BitwiseXorOptions *>(builtin_options())
             : nullptr;
  }
  const circle::RightShiftOptions *builtin_options_as_RightShiftOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_RightShiftOptions
             ? static_cast<const circle::RightShiftOptions *>(builtin_options())
             : nullptr;
  }
  const circle::GRUOptions *builtin_options_as_GRUOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_GRUOptions
             ? static_cast<const circle::GRUOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BCQGatherOptions *builtin_options_as_BCQGatherOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BCQGatherOptions
             ? static_cast<const circle::BCQGatherOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BCQFullyConnectedOptions *builtin_options_as_BCQFullyConnectedOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BCQFullyConnectedOptions
             ? static_cast<const circle::BCQFullyConnectedOptions *>(builtin_options())
             : nullptr;
  }
  const circle::InstanceNormOptions *builtin_options_as_InstanceNormOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_InstanceNormOptions
             ? static_cast<const circle::InstanceNormOptions *>(builtin_options())
             : nullptr;
  }
  const ::flatbuffers::Vector<uint8_t> *custom_options() const
  {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);
  }
  circle::CustomOptionsFormat custom_options_format() const
  {
    return static_cast<circle::CustomOptionsFormat>(GetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const
  {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);
  }
  const ::flatbuffers::Vector<int32_t> *intermediates() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INTERMEDIATES);
  }
  uint64_t large_custom_options_offset() const
  {
    return GetField<uint64_t>(VT_LARGE_CUSTOM_OPTIONS_OFFSET, 0);
  }
  uint64_t large_custom_options_size() const
  {
    return GetField<uint64_t>(VT_LARGE_CUSTOM_OPTIONS_SIZE, 0);
  }
  circle::BuiltinOptions2 builtin_options_2_type() const
  {
    return static_cast<circle::BuiltinOptions2>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_2_TYPE, 0));
  }
  const void *builtin_options_2() const { return GetPointer<const void *>(VT_BUILTIN_OPTIONS_2); }
  template <typename T> const T *builtin_options_2_as() const;
  const circle::StablehloConcatenateOptions *
  builtin_options_2_as_StablehloConcatenateOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloConcatenateOptions
             ? static_cast<const circle::StablehloConcatenateOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloBroadcastInDimOptions *
  builtin_options_2_as_StablehloBroadcastInDimOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloBroadcastInDimOptions
             ? static_cast<const circle::StablehloBroadcastInDimOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloSliceOptions *builtin_options_2_as_StablehloSliceOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloSliceOptions
             ? static_cast<const circle::StablehloSliceOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloConvolutionOptions *
  builtin_options_2_as_StablehloConvolutionOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloConvolutionOptions
             ? static_cast<const circle::StablehloConvolutionOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloCustomCallOptions *builtin_options_2_as_StablehloCustomCallOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloCustomCallOptions
             ? static_cast<const circle::StablehloCustomCallOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloReduceOptions *builtin_options_2_as_StablehloReduceOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloReduceOptions
             ? static_cast<const circle::StablehloReduceOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloScatterOptions *builtin_options_2_as_StablehloScatterOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloScatterOptions
             ? static_cast<const circle::StablehloScatterOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloCompareOptions *builtin_options_2_as_StablehloCompareOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloCompareOptions
             ? static_cast<const circle::StablehloCompareOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloDynamicSliceOptions *
  builtin_options_2_as_StablehloDynamicSliceOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloDynamicSliceOptions
             ? static_cast<const circle::StablehloDynamicSliceOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloPadOptions *builtin_options_2_as_StablehloPadOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloPadOptions
             ? static_cast<const circle::StablehloPadOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloIotaOptions *builtin_options_2_as_StablehloIotaOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloIotaOptions
             ? static_cast<const circle::StablehloIotaOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloDotGeneralOptions *builtin_options_2_as_StablehloDotGeneralOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloDotGeneralOptions
             ? static_cast<const circle::StablehloDotGeneralOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloReduceWindowOptions *
  builtin_options_2_as_StablehloReduceWindowOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloReduceWindowOptions
             ? static_cast<const circle::StablehloReduceWindowOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloSortOptions *builtin_options_2_as_StablehloSortOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloSortOptions
             ? static_cast<const circle::StablehloSortOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloWhileOptions *builtin_options_2_as_StablehloWhileOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloWhileOptions
             ? static_cast<const circle::StablehloWhileOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloGatherOptions *builtin_options_2_as_StablehloGatherOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloGatherOptions
             ? static_cast<const circle::StablehloGatherOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloTransposeOptions *builtin_options_2_as_StablehloTransposeOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloTransposeOptions
             ? static_cast<const circle::StablehloTransposeOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::DilateOptions *builtin_options_2_as_DilateOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_DilateOptions
             ? static_cast<const circle::DilateOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::StablehloRngBitGeneratorOptions *
  builtin_options_2_as_StablehloRngBitGeneratorOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_StablehloRngBitGeneratorOptions
             ? static_cast<const circle::StablehloRngBitGeneratorOptions *>(builtin_options_2())
             : nullptr;
  }
  const circle::ReduceWindowOptions *builtin_options_2_as_ReduceWindowOptions() const
  {
    return builtin_options_2_type() == circle::BuiltinOptions2_ReduceWindowOptions
             ? static_cast<const circle::ReduceWindowOptions *>(builtin_options_2())
             : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_OPCODE_INDEX, 4) &&
           VerifyOffset(verifier, VT_INPUTS) && verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) && verifier.VerifyVector(outputs()) &&
           VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_TYPE, 1) &&
           VerifyOffset(verifier, VT_BUILTIN_OPTIONS) &&
           VerifyBuiltinOptions(verifier, builtin_options(), builtin_options_type()) &&
           VerifyOffset(verifier, VT_CUSTOM_OPTIONS) && verifier.VerifyVector(custom_options()) &&
           VerifyField<int8_t>(verifier, VT_CUSTOM_OPTIONS_FORMAT, 1) &&
           VerifyOffset(verifier, VT_MUTATING_VARIABLE_INPUTS) &&
           verifier.VerifyVector(mutating_variable_inputs()) &&
           VerifyOffset(verifier, VT_INTERMEDIATES) && verifier.VerifyVector(intermediates()) &&
           VerifyField<uint64_t>(verifier, VT_LARGE_CUSTOM_OPTIONS_OFFSET, 8) &&
           VerifyField<uint64_t>(verifier, VT_LARGE_CUSTOM_OPTIONS_SIZE, 8) &&
           VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_2_TYPE, 1) &&
           VerifyOffset(verifier, VT_BUILTIN_OPTIONS_2) &&
           VerifyBuiltinOptions2(verifier, builtin_options_2(), builtin_options_2_type()) &&
           verifier.EndTable();
  }
};

template <>
inline const circle::Conv2DOptions *Operator::builtin_options_as<circle::Conv2DOptions>() const
{
  return builtin_options_as_Conv2DOptions();
}

template <>
inline const circle::DepthwiseConv2DOptions *
Operator::builtin_options_as<circle::DepthwiseConv2DOptions>() const
{
  return builtin_options_as_DepthwiseConv2DOptions();
}

template <>
inline const circle::ConcatEmbeddingsOptions *
Operator::builtin_options_as<circle::ConcatEmbeddingsOptions>() const
{
  return builtin_options_as_ConcatEmbeddingsOptions();
}

template <>
inline const circle::LSHProjectionOptions *
Operator::builtin_options_as<circle::LSHProjectionOptions>() const
{
  return builtin_options_as_LSHProjectionOptions();
}

template <>
inline const circle::Pool2DOptions *Operator::builtin_options_as<circle::Pool2DOptions>() const
{
  return builtin_options_as_Pool2DOptions();
}

template <>
inline const circle::SVDFOptions *Operator::builtin_options_as<circle::SVDFOptions>() const
{
  return builtin_options_as_SVDFOptions();
}

template <>
inline const circle::RNNOptions *Operator::builtin_options_as<circle::RNNOptions>() const
{
  return builtin_options_as_RNNOptions();
}

template <>
inline const circle::FullyConnectedOptions *
Operator::builtin_options_as<circle::FullyConnectedOptions>() const
{
  return builtin_options_as_FullyConnectedOptions();
}

template <>
inline const circle::SoftmaxOptions *Operator::builtin_options_as<circle::SoftmaxOptions>() const
{
  return builtin_options_as_SoftmaxOptions();
}

template <>
inline const circle::ConcatenationOptions *
Operator::builtin_options_as<circle::ConcatenationOptions>() const
{
  return builtin_options_as_ConcatenationOptions();
}

template <>
inline const circle::AddOptions *Operator::builtin_options_as<circle::AddOptions>() const
{
  return builtin_options_as_AddOptions();
}

template <>
inline const circle::L2NormOptions *Operator::builtin_options_as<circle::L2NormOptions>() const
{
  return builtin_options_as_L2NormOptions();
}

template <>
inline const circle::LocalResponseNormalizationOptions *
Operator::builtin_options_as<circle::LocalResponseNormalizationOptions>() const
{
  return builtin_options_as_LocalResponseNormalizationOptions();
}

template <>
inline const circle::LSTMOptions *Operator::builtin_options_as<circle::LSTMOptions>() const
{
  return builtin_options_as_LSTMOptions();
}

template <>
inline const circle::ResizeBilinearOptions *
Operator::builtin_options_as<circle::ResizeBilinearOptions>() const
{
  return builtin_options_as_ResizeBilinearOptions();
}

template <>
inline const circle::CallOptions *Operator::builtin_options_as<circle::CallOptions>() const
{
  return builtin_options_as_CallOptions();
}

template <>
inline const circle::ReshapeOptions *Operator::builtin_options_as<circle::ReshapeOptions>() const
{
  return builtin_options_as_ReshapeOptions();
}

template <>
inline const circle::SkipGramOptions *Operator::builtin_options_as<circle::SkipGramOptions>() const
{
  return builtin_options_as_SkipGramOptions();
}

template <>
inline const circle::SpaceToDepthOptions *
Operator::builtin_options_as<circle::SpaceToDepthOptions>() const
{
  return builtin_options_as_SpaceToDepthOptions();
}

template <>
inline const circle::EmbeddingLookupSparseOptions *
Operator::builtin_options_as<circle::EmbeddingLookupSparseOptions>() const
{
  return builtin_options_as_EmbeddingLookupSparseOptions();
}

template <>
inline const circle::MulOptions *Operator::builtin_options_as<circle::MulOptions>() const
{
  return builtin_options_as_MulOptions();
}

template <>
inline const circle::PadOptions *Operator::builtin_options_as<circle::PadOptions>() const
{
  return builtin_options_as_PadOptions();
}

template <>
inline const circle::GatherOptions *Operator::builtin_options_as<circle::GatherOptions>() const
{
  return builtin_options_as_GatherOptions();
}

template <>
inline const circle::BatchToSpaceNDOptions *
Operator::builtin_options_as<circle::BatchToSpaceNDOptions>() const
{
  return builtin_options_as_BatchToSpaceNDOptions();
}

template <>
inline const circle::SpaceToBatchNDOptions *
Operator::builtin_options_as<circle::SpaceToBatchNDOptions>() const
{
  return builtin_options_as_SpaceToBatchNDOptions();
}

template <>
inline const circle::TransposeOptions *
Operator::builtin_options_as<circle::TransposeOptions>() const
{
  return builtin_options_as_TransposeOptions();
}

template <>
inline const circle::ReducerOptions *Operator::builtin_options_as<circle::ReducerOptions>() const
{
  return builtin_options_as_ReducerOptions();
}

template <>
inline const circle::SubOptions *Operator::builtin_options_as<circle::SubOptions>() const
{
  return builtin_options_as_SubOptions();
}

template <>
inline const circle::DivOptions *Operator::builtin_options_as<circle::DivOptions>() const
{
  return builtin_options_as_DivOptions();
}

template <>
inline const circle::SqueezeOptions *Operator::builtin_options_as<circle::SqueezeOptions>() const
{
  return builtin_options_as_SqueezeOptions();
}

template <>
inline const circle::SequenceRNNOptions *
Operator::builtin_options_as<circle::SequenceRNNOptions>() const
{
  return builtin_options_as_SequenceRNNOptions();
}

template <>
inline const circle::StridedSliceOptions *
Operator::builtin_options_as<circle::StridedSliceOptions>() const
{
  return builtin_options_as_StridedSliceOptions();
}

template <>
inline const circle::ExpOptions *Operator::builtin_options_as<circle::ExpOptions>() const
{
  return builtin_options_as_ExpOptions();
}

template <>
inline const circle::TopKV2Options *Operator::builtin_options_as<circle::TopKV2Options>() const
{
  return builtin_options_as_TopKV2Options();
}

template <>
inline const circle::SplitOptions *Operator::builtin_options_as<circle::SplitOptions>() const
{
  return builtin_options_as_SplitOptions();
}

template <>
inline const circle::LogSoftmaxOptions *
Operator::builtin_options_as<circle::LogSoftmaxOptions>() const
{
  return builtin_options_as_LogSoftmaxOptions();
}

template <>
inline const circle::CastOptions *Operator::builtin_options_as<circle::CastOptions>() const
{
  return builtin_options_as_CastOptions();
}

template <>
inline const circle::DequantizeOptions *
Operator::builtin_options_as<circle::DequantizeOptions>() const
{
  return builtin_options_as_DequantizeOptions();
}

template <>
inline const circle::MaximumMinimumOptions *
Operator::builtin_options_as<circle::MaximumMinimumOptions>() const
{
  return builtin_options_as_MaximumMinimumOptions();
}

template <>
inline const circle::ArgMaxOptions *Operator::builtin_options_as<circle::ArgMaxOptions>() const
{
  return builtin_options_as_ArgMaxOptions();
}

template <>
inline const circle::LessOptions *Operator::builtin_options_as<circle::LessOptions>() const
{
  return builtin_options_as_LessOptions();
}

template <>
inline const circle::NegOptions *Operator::builtin_options_as<circle::NegOptions>() const
{
  return builtin_options_as_NegOptions();
}

template <>
inline const circle::PadV2Options *Operator::builtin_options_as<circle::PadV2Options>() const
{
  return builtin_options_as_PadV2Options();
}

template <>
inline const circle::GreaterOptions *Operator::builtin_options_as<circle::GreaterOptions>() const
{
  return builtin_options_as_GreaterOptions();
}

template <>
inline const circle::GreaterEqualOptions *
Operator::builtin_options_as<circle::GreaterEqualOptions>() const
{
  return builtin_options_as_GreaterEqualOptions();
}

template <>
inline const circle::LessEqualOptions *
Operator::builtin_options_as<circle::LessEqualOptions>() const
{
  return builtin_options_as_LessEqualOptions();
}

template <>
inline const circle::SelectOptions *Operator::builtin_options_as<circle::SelectOptions>() const
{
  return builtin_options_as_SelectOptions();
}

template <>
inline const circle::SliceOptions *Operator::builtin_options_as<circle::SliceOptions>() const
{
  return builtin_options_as_SliceOptions();
}

template <>
inline const circle::TransposeConvOptions *
Operator::builtin_options_as<circle::TransposeConvOptions>() const
{
  return builtin_options_as_TransposeConvOptions();
}

template <>
inline const circle::SparseToDenseOptions *
Operator::builtin_options_as<circle::SparseToDenseOptions>() const
{
  return builtin_options_as_SparseToDenseOptions();
}

template <>
inline const circle::TileOptions *Operator::builtin_options_as<circle::TileOptions>() const
{
  return builtin_options_as_TileOptions();
}

template <>
inline const circle::ExpandDimsOptions *
Operator::builtin_options_as<circle::ExpandDimsOptions>() const
{
  return builtin_options_as_ExpandDimsOptions();
}

template <>
inline const circle::EqualOptions *Operator::builtin_options_as<circle::EqualOptions>() const
{
  return builtin_options_as_EqualOptions();
}

template <>
inline const circle::NotEqualOptions *Operator::builtin_options_as<circle::NotEqualOptions>() const
{
  return builtin_options_as_NotEqualOptions();
}

template <>
inline const circle::ShapeOptions *Operator::builtin_options_as<circle::ShapeOptions>() const
{
  return builtin_options_as_ShapeOptions();
}

template <>
inline const circle::PowOptions *Operator::builtin_options_as<circle::PowOptions>() const
{
  return builtin_options_as_PowOptions();
}

template <>
inline const circle::ArgMinOptions *Operator::builtin_options_as<circle::ArgMinOptions>() const
{
  return builtin_options_as_ArgMinOptions();
}

template <>
inline const circle::FakeQuantOptions *
Operator::builtin_options_as<circle::FakeQuantOptions>() const
{
  return builtin_options_as_FakeQuantOptions();
}

template <>
inline const circle::PackOptions *Operator::builtin_options_as<circle::PackOptions>() const
{
  return builtin_options_as_PackOptions();
}

template <>
inline const circle::LogicalOrOptions *
Operator::builtin_options_as<circle::LogicalOrOptions>() const
{
  return builtin_options_as_LogicalOrOptions();
}

template <>
inline const circle::OneHotOptions *Operator::builtin_options_as<circle::OneHotOptions>() const
{
  return builtin_options_as_OneHotOptions();
}

template <>
inline const circle::LogicalAndOptions *
Operator::builtin_options_as<circle::LogicalAndOptions>() const
{
  return builtin_options_as_LogicalAndOptions();
}

template <>
inline const circle::LogicalNotOptions *
Operator::builtin_options_as<circle::LogicalNotOptions>() const
{
  return builtin_options_as_LogicalNotOptions();
}

template <>
inline const circle::UnpackOptions *Operator::builtin_options_as<circle::UnpackOptions>() const
{
  return builtin_options_as_UnpackOptions();
}

template <>
inline const circle::FloorDivOptions *Operator::builtin_options_as<circle::FloorDivOptions>() const
{
  return builtin_options_as_FloorDivOptions();
}

template <>
inline const circle::SquareOptions *Operator::builtin_options_as<circle::SquareOptions>() const
{
  return builtin_options_as_SquareOptions();
}

template <>
inline const circle::ZerosLikeOptions *
Operator::builtin_options_as<circle::ZerosLikeOptions>() const
{
  return builtin_options_as_ZerosLikeOptions();
}

template <>
inline const circle::FillOptions *Operator::builtin_options_as<circle::FillOptions>() const
{
  return builtin_options_as_FillOptions();
}

template <>
inline const circle::BidirectionalSequenceLSTMOptions *
Operator::builtin_options_as<circle::BidirectionalSequenceLSTMOptions>() const
{
  return builtin_options_as_BidirectionalSequenceLSTMOptions();
}

template <>
inline const circle::BidirectionalSequenceRNNOptions *
Operator::builtin_options_as<circle::BidirectionalSequenceRNNOptions>() const
{
  return builtin_options_as_BidirectionalSequenceRNNOptions();
}

template <>
inline const circle::UnidirectionalSequenceLSTMOptions *
Operator::builtin_options_as<circle::UnidirectionalSequenceLSTMOptions>() const
{
  return builtin_options_as_UnidirectionalSequenceLSTMOptions();
}

template <>
inline const circle::FloorModOptions *Operator::builtin_options_as<circle::FloorModOptions>() const
{
  return builtin_options_as_FloorModOptions();
}

template <>
inline const circle::RangeOptions *Operator::builtin_options_as<circle::RangeOptions>() const
{
  return builtin_options_as_RangeOptions();
}

template <>
inline const circle::ResizeNearestNeighborOptions *
Operator::builtin_options_as<circle::ResizeNearestNeighborOptions>() const
{
  return builtin_options_as_ResizeNearestNeighborOptions();
}

template <>
inline const circle::LeakyReluOptions *
Operator::builtin_options_as<circle::LeakyReluOptions>() const
{
  return builtin_options_as_LeakyReluOptions();
}

template <>
inline const circle::SquaredDifferenceOptions *
Operator::builtin_options_as<circle::SquaredDifferenceOptions>() const
{
  return builtin_options_as_SquaredDifferenceOptions();
}

template <>
inline const circle::MirrorPadOptions *
Operator::builtin_options_as<circle::MirrorPadOptions>() const
{
  return builtin_options_as_MirrorPadOptions();
}

template <>
inline const circle::AbsOptions *Operator::builtin_options_as<circle::AbsOptions>() const
{
  return builtin_options_as_AbsOptions();
}

template <>
inline const circle::SplitVOptions *Operator::builtin_options_as<circle::SplitVOptions>() const
{
  return builtin_options_as_SplitVOptions();
}

template <>
inline const circle::UniqueOptions *Operator::builtin_options_as<circle::UniqueOptions>() const
{
  return builtin_options_as_UniqueOptions();
}

template <>
inline const circle::ReverseV2Options *
Operator::builtin_options_as<circle::ReverseV2Options>() const
{
  return builtin_options_as_ReverseV2Options();
}

template <>
inline const circle::AddNOptions *Operator::builtin_options_as<circle::AddNOptions>() const
{
  return builtin_options_as_AddNOptions();
}

template <>
inline const circle::GatherNdOptions *Operator::builtin_options_as<circle::GatherNdOptions>() const
{
  return builtin_options_as_GatherNdOptions();
}

template <>
inline const circle::CosOptions *Operator::builtin_options_as<circle::CosOptions>() const
{
  return builtin_options_as_CosOptions();
}

template <>
inline const circle::WhereOptions *Operator::builtin_options_as<circle::WhereOptions>() const
{
  return builtin_options_as_WhereOptions();
}

template <>
inline const circle::RankOptions *Operator::builtin_options_as<circle::RankOptions>() const
{
  return builtin_options_as_RankOptions();
}

template <>
inline const circle::ReverseSequenceOptions *
Operator::builtin_options_as<circle::ReverseSequenceOptions>() const
{
  return builtin_options_as_ReverseSequenceOptions();
}

template <>
inline const circle::MatrixDiagOptions *
Operator::builtin_options_as<circle::MatrixDiagOptions>() const
{
  return builtin_options_as_MatrixDiagOptions();
}

template <>
inline const circle::QuantizeOptions *Operator::builtin_options_as<circle::QuantizeOptions>() const
{
  return builtin_options_as_QuantizeOptions();
}

template <>
inline const circle::MatrixSetDiagOptions *
Operator::builtin_options_as<circle::MatrixSetDiagOptions>() const
{
  return builtin_options_as_MatrixSetDiagOptions();
}

template <>
inline const circle::HardSwishOptions *
Operator::builtin_options_as<circle::HardSwishOptions>() const
{
  return builtin_options_as_HardSwishOptions();
}

template <> inline const circle::IfOptions *Operator::builtin_options_as<circle::IfOptions>() const
{
  return builtin_options_as_IfOptions();
}

template <>
inline const circle::WhileOptions *Operator::builtin_options_as<circle::WhileOptions>() const
{
  return builtin_options_as_WhileOptions();
}

template <>
inline const circle::DepthToSpaceOptions *
Operator::builtin_options_as<circle::DepthToSpaceOptions>() const
{
  return builtin_options_as_DepthToSpaceOptions();
}

template <>
inline const circle::NonMaxSuppressionV4Options *
Operator::builtin_options_as<circle::NonMaxSuppressionV4Options>() const
{
  return builtin_options_as_NonMaxSuppressionV4Options();
}

template <>
inline const circle::NonMaxSuppressionV5Options *
Operator::builtin_options_as<circle::NonMaxSuppressionV5Options>() const
{
  return builtin_options_as_NonMaxSuppressionV5Options();
}

template <>
inline const circle::ScatterNdOptions *
Operator::builtin_options_as<circle::ScatterNdOptions>() const
{
  return builtin_options_as_ScatterNdOptions();
}

template <>
inline const circle::SelectV2Options *Operator::builtin_options_as<circle::SelectV2Options>() const
{
  return builtin_options_as_SelectV2Options();
}

template <>
inline const circle::DensifyOptions *Operator::builtin_options_as<circle::DensifyOptions>() const
{
  return builtin_options_as_DensifyOptions();
}

template <>
inline const circle::SegmentSumOptions *
Operator::builtin_options_as<circle::SegmentSumOptions>() const
{
  return builtin_options_as_SegmentSumOptions();
}

template <>
inline const circle::BatchMatMulOptions *
Operator::builtin_options_as<circle::BatchMatMulOptions>() const
{
  return builtin_options_as_BatchMatMulOptions();
}

template <>
inline const circle::CumsumOptions *Operator::builtin_options_as<circle::CumsumOptions>() const
{
  return builtin_options_as_CumsumOptions();
}

template <>
inline const circle::CallOnceOptions *Operator::builtin_options_as<circle::CallOnceOptions>() const
{
  return builtin_options_as_CallOnceOptions();
}

template <>
inline const circle::BroadcastToOptions *
Operator::builtin_options_as<circle::BroadcastToOptions>() const
{
  return builtin_options_as_BroadcastToOptions();
}

template <>
inline const circle::Rfft2dOptions *Operator::builtin_options_as<circle::Rfft2dOptions>() const
{
  return builtin_options_as_Rfft2dOptions();
}

template <>
inline const circle::Conv3DOptions *Operator::builtin_options_as<circle::Conv3DOptions>() const
{
  return builtin_options_as_Conv3DOptions();
}

template <>
inline const circle::HashtableOptions *
Operator::builtin_options_as<circle::HashtableOptions>() const
{
  return builtin_options_as_HashtableOptions();
}

template <>
inline const circle::HashtableFindOptions *
Operator::builtin_options_as<circle::HashtableFindOptions>() const
{
  return builtin_options_as_HashtableFindOptions();
}

template <>
inline const circle::HashtableImportOptions *
Operator::builtin_options_as<circle::HashtableImportOptions>() const
{
  return builtin_options_as_HashtableImportOptions();
}

template <>
inline const circle::HashtableSizeOptions *
Operator::builtin_options_as<circle::HashtableSizeOptions>() const
{
  return builtin_options_as_HashtableSizeOptions();
}

template <>
inline const circle::VarHandleOptions *
Operator::builtin_options_as<circle::VarHandleOptions>() const
{
  return builtin_options_as_VarHandleOptions();
}

template <>
inline const circle::ReadVariableOptions *
Operator::builtin_options_as<circle::ReadVariableOptions>() const
{
  return builtin_options_as_ReadVariableOptions();
}

template <>
inline const circle::AssignVariableOptions *
Operator::builtin_options_as<circle::AssignVariableOptions>() const
{
  return builtin_options_as_AssignVariableOptions();
}

template <>
inline const circle::RandomOptions *Operator::builtin_options_as<circle::RandomOptions>() const
{
  return builtin_options_as_RandomOptions();
}

template <>
inline const circle::BucketizeOptions *
Operator::builtin_options_as<circle::BucketizeOptions>() const
{
  return builtin_options_as_BucketizeOptions();
}

template <>
inline const circle::GeluOptions *Operator::builtin_options_as<circle::GeluOptions>() const
{
  return builtin_options_as_GeluOptions();
}

template <>
inline const circle::DynamicUpdateSliceOptions *
Operator::builtin_options_as<circle::DynamicUpdateSliceOptions>() const
{
  return builtin_options_as_DynamicUpdateSliceOptions();
}

template <>
inline const circle::UnsortedSegmentProdOptions *
Operator::builtin_options_as<circle::UnsortedSegmentProdOptions>() const
{
  return builtin_options_as_UnsortedSegmentProdOptions();
}

template <>
inline const circle::UnsortedSegmentMaxOptions *
Operator::builtin_options_as<circle::UnsortedSegmentMaxOptions>() const
{
  return builtin_options_as_UnsortedSegmentMaxOptions();
}

template <>
inline const circle::UnsortedSegmentMinOptions *
Operator::builtin_options_as<circle::UnsortedSegmentMinOptions>() const
{
  return builtin_options_as_UnsortedSegmentMinOptions();
}

template <>
inline const circle::UnsortedSegmentSumOptions *
Operator::builtin_options_as<circle::UnsortedSegmentSumOptions>() const
{
  return builtin_options_as_UnsortedSegmentSumOptions();
}

template <>
inline const circle::ATan2Options *Operator::builtin_options_as<circle::ATan2Options>() const
{
  return builtin_options_as_ATan2Options();
}

template <>
inline const circle::SignOptions *Operator::builtin_options_as<circle::SignOptions>() const
{
  return builtin_options_as_SignOptions();
}

template <>
inline const circle::BitcastOptions *Operator::builtin_options_as<circle::BitcastOptions>() const
{
  return builtin_options_as_BitcastOptions();
}

template <>
inline const circle::BitwiseXorOptions *
Operator::builtin_options_as<circle::BitwiseXorOptions>() const
{
  return builtin_options_as_BitwiseXorOptions();
}

template <>
inline const circle::RightShiftOptions *
Operator::builtin_options_as<circle::RightShiftOptions>() const
{
  return builtin_options_as_RightShiftOptions();
}

template <>
inline const circle::GRUOptions *Operator::builtin_options_as<circle::GRUOptions>() const
{
  return builtin_options_as_GRUOptions();
}

template <>
inline const circle::BCQGatherOptions *
Operator::builtin_options_as<circle::BCQGatherOptions>() const
{
  return builtin_options_as_BCQGatherOptions();
}

template <>
inline const circle::BCQFullyConnectedOptions *
Operator::builtin_options_as<circle::BCQFullyConnectedOptions>() const
{
  return builtin_options_as_BCQFullyConnectedOptions();
}

template <>
inline const circle::InstanceNormOptions *
Operator::builtin_options_as<circle::InstanceNormOptions>() const
{
  return builtin_options_as_InstanceNormOptions();
}

template <>
inline const circle::StablehloConcatenateOptions *
Operator::builtin_options_2_as<circle::StablehloConcatenateOptions>() const
{
  return builtin_options_2_as_StablehloConcatenateOptions();
}

template <>
inline const circle::StablehloBroadcastInDimOptions *
Operator::builtin_options_2_as<circle::StablehloBroadcastInDimOptions>() const
{
  return builtin_options_2_as_StablehloBroadcastInDimOptions();
}

template <>
inline const circle::StablehloSliceOptions *
Operator::builtin_options_2_as<circle::StablehloSliceOptions>() const
{
  return builtin_options_2_as_StablehloSliceOptions();
}

template <>
inline const circle::StablehloConvolutionOptions *
Operator::builtin_options_2_as<circle::StablehloConvolutionOptions>() const
{
  return builtin_options_2_as_StablehloConvolutionOptions();
}

template <>
inline const circle::StablehloCustomCallOptions *
Operator::builtin_options_2_as<circle::StablehloCustomCallOptions>() const
{
  return builtin_options_2_as_StablehloCustomCallOptions();
}

template <>
inline const circle::StablehloReduceOptions *
Operator::builtin_options_2_as<circle::StablehloReduceOptions>() const
{
  return builtin_options_2_as_StablehloReduceOptions();
}

template <>
inline const circle::StablehloScatterOptions *
Operator::builtin_options_2_as<circle::StablehloScatterOptions>() const
{
  return builtin_options_2_as_StablehloScatterOptions();
}

template <>
inline const circle::StablehloCompareOptions *
Operator::builtin_options_2_as<circle::StablehloCompareOptions>() const
{
  return builtin_options_2_as_StablehloCompareOptions();
}

template <>
inline const circle::StablehloDynamicSliceOptions *
Operator::builtin_options_2_as<circle::StablehloDynamicSliceOptions>() const
{
  return builtin_options_2_as_StablehloDynamicSliceOptions();
}

template <>
inline const circle::StablehloPadOptions *
Operator::builtin_options_2_as<circle::StablehloPadOptions>() const
{
  return builtin_options_2_as_StablehloPadOptions();
}

template <>
inline const circle::StablehloIotaOptions *
Operator::builtin_options_2_as<circle::StablehloIotaOptions>() const
{
  return builtin_options_2_as_StablehloIotaOptions();
}

template <>
inline const circle::StablehloDotGeneralOptions *
Operator::builtin_options_2_as<circle::StablehloDotGeneralOptions>() const
{
  return builtin_options_2_as_StablehloDotGeneralOptions();
}

template <>
inline const circle::StablehloReduceWindowOptions *
Operator::builtin_options_2_as<circle::StablehloReduceWindowOptions>() const
{
  return builtin_options_2_as_StablehloReduceWindowOptions();
}

template <>
inline const circle::StablehloSortOptions *
Operator::builtin_options_2_as<circle::StablehloSortOptions>() const
{
  return builtin_options_2_as_StablehloSortOptions();
}

template <>
inline const circle::StablehloWhileOptions *
Operator::builtin_options_2_as<circle::StablehloWhileOptions>() const
{
  return builtin_options_2_as_StablehloWhileOptions();
}

template <>
inline const circle::StablehloGatherOptions *
Operator::builtin_options_2_as<circle::StablehloGatherOptions>() const
{
  return builtin_options_2_as_StablehloGatherOptions();
}

template <>
inline const circle::StablehloTransposeOptions *
Operator::builtin_options_2_as<circle::StablehloTransposeOptions>() const
{
  return builtin_options_2_as_StablehloTransposeOptions();
}

template <>
inline const circle::DilateOptions *Operator::builtin_options_2_as<circle::DilateOptions>() const
{
  return builtin_options_2_as_DilateOptions();
}

template <>
inline const circle::StablehloRngBitGeneratorOptions *
Operator::builtin_options_2_as<circle::StablehloRngBitGeneratorOptions>() const
{
  return builtin_options_2_as_StablehloRngBitGeneratorOptions();
}

template <>
inline const circle::ReduceWindowOptions *
Operator::builtin_options_2_as<circle::ReduceWindowOptions>() const
{
  return builtin_options_2_as_ReduceWindowOptions();
}

struct OperatorBuilder
{
  typedef Operator Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_opcode_index(uint32_t opcode_index)
  {
    fbb_.AddElement<uint32_t>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs)
  {
    fbb_.AddOffset(Operator::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs)
  {
    fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
  }
  void add_builtin_options_type(circle::BuiltinOptions builtin_options_type)
  {
    fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_TYPE,
                             static_cast<uint8_t>(builtin_options_type), 0);
  }
  void add_builtin_options(::flatbuffers::Offset<void> builtin_options)
  {
    fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS, builtin_options);
  }
  void add_custom_options(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom_options)
  {
    fbb_.AddOffset(Operator::VT_CUSTOM_OPTIONS, custom_options);
  }
  void add_custom_options_format(circle::CustomOptionsFormat custom_options_format)
  {
    fbb_.AddElement<int8_t>(Operator::VT_CUSTOM_OPTIONS_FORMAT,
                            static_cast<int8_t>(custom_options_format), 0);
  }
  void add_mutating_variable_inputs(
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mutating_variable_inputs)
  {
    fbb_.AddOffset(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);
  }
  void add_intermediates(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> intermediates)
  {
    fbb_.AddOffset(Operator::VT_INTERMEDIATES, intermediates);
  }
  void add_large_custom_options_offset(uint64_t large_custom_options_offset)
  {
    fbb_.AddElement<uint64_t>(Operator::VT_LARGE_CUSTOM_OPTIONS_OFFSET, large_custom_options_offset,
                              0);
  }
  void add_large_custom_options_size(uint64_t large_custom_options_size)
  {
    fbb_.AddElement<uint64_t>(Operator::VT_LARGE_CUSTOM_OPTIONS_SIZE, large_custom_options_size, 0);
  }
  void add_builtin_options_2_type(circle::BuiltinOptions2 builtin_options_2_type)
  {
    fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_2_TYPE,
                             static_cast<uint8_t>(builtin_options_2_type), 0);
  }
  void add_builtin_options_2(::flatbuffers::Offset<void> builtin_options_2)
  {
    fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS_2, builtin_options_2);
  }
  explicit OperatorBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Operator> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Operator> CreateOperator(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint32_t opcode_index = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,
  circle::BuiltinOptions builtin_options_type = circle::BuiltinOptions_NONE,
  ::flatbuffers::Offset<void> builtin_options = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom_options = 0,
  circle::CustomOptionsFormat custom_options_format = circle::CustomOptionsFormat_FLEXBUFFERS,
  ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> intermediates = 0,
  uint64_t large_custom_options_offset = 0, uint64_t large_custom_options_size = 0,
  circle::BuiltinOptions2 builtin_options_2_type = circle::BuiltinOptions2_NONE,
  ::flatbuffers::Offset<void> builtin_options_2 = 0)
{
  OperatorBuilder builder_(_fbb);
  builder_.add_large_custom_options_size(large_custom_options_size);
  builder_.add_large_custom_options_offset(large_custom_options_offset);
  builder_.add_builtin_options_2(builtin_options_2);
  builder_.add_intermediates(intermediates);
  builder_.add_mutating_variable_inputs(mutating_variable_inputs);
  builder_.add_custom_options(custom_options);
  builder_.add_builtin_options(builtin_options);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_opcode_index(opcode_index);
  builder_.add_builtin_options_2_type(builtin_options_2_type);
  builder_.add_custom_options_format(custom_options_format);
  builder_.add_builtin_options_type(builtin_options_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Operator> CreateOperatorDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint32_t opcode_index = 0,
  const std::vector<int32_t> *inputs = nullptr, const std::vector<int32_t> *outputs = nullptr,
  circle::BuiltinOptions builtin_options_type = circle::BuiltinOptions_NONE,
  ::flatbuffers::Offset<void> builtin_options = 0,
  const std::vector<uint8_t> *custom_options = nullptr,
  circle::CustomOptionsFormat custom_options_format = circle::CustomOptionsFormat_FLEXBUFFERS,
  const std::vector<uint8_t> *mutating_variable_inputs = nullptr,
  const std::vector<int32_t> *intermediates = nullptr, uint64_t large_custom_options_offset = 0,
  uint64_t large_custom_options_size = 0,
  circle::BuiltinOptions2 builtin_options_2_type = circle::BuiltinOptions2_NONE,
  ::flatbuffers::Offset<void> builtin_options_2 = 0)
{
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto custom_options__ = custom_options ? _fbb.CreateVector<uint8_t>(*custom_options) : 0;
  auto mutating_variable_inputs__ =
    mutating_variable_inputs ? _fbb.CreateVector<uint8_t>(*mutating_variable_inputs) : 0;
  auto intermediates__ = intermediates ? _fbb.CreateVector<int32_t>(*intermediates) : 0;
  return circle::CreateOperator(_fbb, opcode_index, inputs__, outputs__, builtin_options_type,
                                builtin_options, custom_options__, custom_options_format,
                                mutating_variable_inputs__, intermediates__,
                                large_custom_options_offset, large_custom_options_size,
                                builtin_options_2_type, builtin_options_2);
}

struct SubGraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SubGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TENSORS = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_OPERATORS = 10,
    VT_NAME = 12
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<circle::Tensor>> *tensors() const
  {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<circle::Tensor>> *>(
      VT_TENSORS);
  }
  const ::flatbuffers::Vector<int32_t> *inputs() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<int32_t> *outputs() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<circle::Operator>> *operators() const
  {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<circle::Operator>> *>(
      VT_OPERATORS);
  }
  const ::flatbuffers::String *name() const
  {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) && verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_INPUTS) && verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) && verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_OPERATORS) && verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) && verifier.EndTable();
  }
};

struct SubGraphBuilder
{
  typedef SubGraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tensors(
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::Tensor>>> tensors)
  {
    fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs)
  {
    fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs)
  {
    fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
  }
  void add_operators(
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::Operator>>> operators)
  {
    fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
  {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  explicit SubGraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubGraph> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubGraph> CreateSubGraph(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::Tensor>>> tensors = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::Operator>>> operators =
    0,
  ::flatbuffers::Offset<::flatbuffers::String> name = 0)
{
  SubGraphBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_operators(operators);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tensors(tensors);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  const std::vector<::flatbuffers::Offset<circle::Tensor>> *tensors = nullptr,
  const std::vector<int32_t> *inputs = nullptr, const std::vector<int32_t> *outputs = nullptr,
  const std::vector<::flatbuffers::Offset<circle::Operator>> *operators = nullptr,
  const char *name = nullptr)
{
  auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<circle::Tensor>>(*tensors) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto operators__ =
    operators ? _fbb.CreateVector<::flatbuffers::Offset<circle::Operator>>(*operators) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return circle::CreateSubGraph(_fbb, tensors__, inputs__, outputs__, operators__, name__);
}

struct Buffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_DATA = 4,
    VT_OFFSET = 6,
    VT_SIZE = 8
  };
  const ::flatbuffers::Vector<uint8_t> *data() const
  {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  uint64_t offset() const { return GetField<uint64_t>(VT_OFFSET, 0); }
  uint64_t size() const { return GetField<uint64_t>(VT_SIZE, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) && VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) && verifier.EndTable();
  }
};

struct BufferBuilder
{
  typedef Buffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data)
  {
    fbb_.AddOffset(Buffer::VT_DATA, data);
  }
  void add_offset(uint64_t offset) { fbb_.AddElement<uint64_t>(Buffer::VT_OFFSET, offset, 0); }
  void add_size(uint64_t size) { fbb_.AddElement<uint64_t>(Buffer::VT_SIZE, size, 0); }
  explicit BufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Buffer> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Buffer>
CreateBuffer(::flatbuffers::FlatBufferBuilder &_fbb,
             ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0, uint64_t offset = 0,
             uint64_t size = 0)
{
  BufferBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_offset(offset);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Buffer> CreateBufferDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                                        const std::vector<uint8_t> *data = nullptr,
                                                        uint64_t offset = 0, uint64_t size = 0)
{
  if (data)
  {
    _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16);
  }
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return circle::CreateBuffer(_fbb, data__, offset, size);
}

struct Metadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NAME = 4,
    VT_BUFFER = 6
  };
  const ::flatbuffers::String *name() const
  {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t buffer() const { return GetField<uint32_t>(VT_BUFFER, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) && VerifyField<uint32_t>(verifier, VT_BUFFER, 4) &&
           verifier.EndTable();
  }
};

struct MetadataBuilder
{
  typedef Metadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
  {
    fbb_.AddOffset(Metadata::VT_NAME, name);
  }
  void add_buffer(uint32_t buffer) { fbb_.AddElement<uint32_t>(Metadata::VT_BUFFER, buffer, 0); }
  explicit MetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Metadata> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Metadata>
CreateMetadata(::flatbuffers::FlatBufferBuilder &_fbb,
               ::flatbuffers::Offset<::flatbuffers::String> name = 0, uint32_t buffer = 0)
{
  MetadataBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Metadata> CreateMetadataDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                                            const char *name = nullptr,
                                                            uint32_t buffer = 0)
{
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return circle::CreateMetadata(_fbb, name__, buffer);
}

struct TensorMap FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef TensorMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NAME = 4,
    VT_TENSOR_INDEX = 6
  };
  const ::flatbuffers::String *name() const
  {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t tensor_index() const { return GetField<uint32_t>(VT_TENSOR_INDEX, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) && VerifyField<uint32_t>(verifier, VT_TENSOR_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct TensorMapBuilder
{
  typedef TensorMap Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
  {
    fbb_.AddOffset(TensorMap::VT_NAME, name);
  }
  void add_tensor_index(uint32_t tensor_index)
  {
    fbb_.AddElement<uint32_t>(TensorMap::VT_TENSOR_INDEX, tensor_index, 0);
  }
  explicit TensorMapBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorMap> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorMap>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorMap>
CreateTensorMap(::flatbuffers::FlatBufferBuilder &_fbb,
                ::flatbuffers::Offset<::flatbuffers::String> name = 0, uint32_t tensor_index = 0)
{
  TensorMapBuilder builder_(_fbb);
  builder_.add_tensor_index(tensor_index);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorMap>
CreateTensorMapDirect(::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
                      uint32_t tensor_index = 0)
{
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return circle::CreateTensorMap(_fbb, name__, tensor_index);
}

struct SignatureDef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef SignatureDefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_INPUTS = 4,
    VT_OUTPUTS = 6,
    VT_SIGNATURE_KEY = 8,
    VT_SUBGRAPH_INDEX = 12
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<circle::TensorMap>> *inputs() const
  {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<circle::TensorMap>> *>(
      VT_INPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<circle::TensorMap>> *outputs() const
  {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<circle::TensorMap>> *>(
      VT_OUTPUTS);
  }
  const ::flatbuffers::String *signature_key() const
  {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE_KEY);
  }
  uint32_t subgraph_index() const { return GetField<uint32_t>(VT_SUBGRAPH_INDEX, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) && verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) && verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) && VerifyOffset(verifier, VT_SIGNATURE_KEY) &&
           verifier.VerifyString(signature_key()) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH_INDEX, 4) && verifier.EndTable();
  }
};

struct SignatureDefBuilder
{
  typedef SignatureDef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inputs(
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::TensorMap>>> inputs)
  {
    fbb_.AddOffset(SignatureDef::VT_INPUTS, inputs);
  }
  void add_outputs(
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::TensorMap>>> outputs)
  {
    fbb_.AddOffset(SignatureDef::VT_OUTPUTS, outputs);
  }
  void add_signature_key(::flatbuffers::Offset<::flatbuffers::String> signature_key)
  {
    fbb_.AddOffset(SignatureDef::VT_SIGNATURE_KEY, signature_key);
  }
  void add_subgraph_index(uint32_t subgraph_index)
  {
    fbb_.AddElement<uint32_t>(SignatureDef::VT_SUBGRAPH_INDEX, subgraph_index, 0);
  }
  explicit SignatureDefBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SignatureDef> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SignatureDef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SignatureDef> CreateSignatureDef(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::TensorMap>>> inputs = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::TensorMap>>> outputs =
    0,
  ::flatbuffers::Offset<::flatbuffers::String> signature_key = 0, uint32_t subgraph_index = 0)
{
  SignatureDefBuilder builder_(_fbb);
  builder_.add_subgraph_index(subgraph_index);
  builder_.add_signature_key(signature_key);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SignatureDef> CreateSignatureDefDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb,
  const std::vector<::flatbuffers::Offset<circle::TensorMap>> *inputs = nullptr,
  const std::vector<::flatbuffers::Offset<circle::TensorMap>> *outputs = nullptr,
  const char *signature_key = nullptr, uint32_t subgraph_index = 0)
{
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<circle::TensorMap>>(*inputs) : 0;
  auto outputs__ =
    outputs ? _fbb.CreateVector<::flatbuffers::Offset<circle::TensorMap>>(*outputs) : 0;
  auto signature_key__ = signature_key ? _fbb.CreateString(signature_key) : 0;
  return circle::CreateSignatureDef(_fbb, inputs__, outputs__, signature_key__, subgraph_index);
}

struct Model FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
  typedef ModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VERSION = 4,
    VT_OPERATOR_CODES = 6,
    VT_SUBGRAPHS = 8,
    VT_DESCRIPTION = 10,
    VT_BUFFERS = 12,
    VT_METADATA_BUFFER = 14,
    VT_METADATA = 16,
    VT_SIGNATURE_DEFS = 18
  };
  uint32_t version() const { return GetField<uint32_t>(VT_VERSION, 0); }
  const ::flatbuffers::Vector<::flatbuffers::Offset<circle::OperatorCode>> *operator_codes() const
  {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<circle::OperatorCode>> *>(
      VT_OPERATOR_CODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<circle::SubGraph>> *subgraphs() const
  {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<circle::SubGraph>> *>(
      VT_SUBGRAPHS);
  }
  const ::flatbuffers::String *description() const
  {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<circle::Buffer>> *buffers() const
  {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<circle::Buffer>> *>(
      VT_BUFFERS);
  }
  const ::flatbuffers::Vector<int32_t> *metadata_buffer() const
  {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<circle::Metadata>> *metadata() const
  {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<circle::Metadata>> *>(
      VT_METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<circle::SignatureDef>> *signature_defs() const
  {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<circle::SignatureDef>> *>(
      VT_SIGNATURE_DEFS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_OPERATOR_CODES) && verifier.VerifyVector(operator_codes()) &&
           verifier.VerifyVectorOfTables(operator_codes()) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) && verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) && VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) && VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) && verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, VT_METADATA_BUFFER) && verifier.VerifyVector(metadata_buffer()) &&
           VerifyOffset(verifier, VT_METADATA) && verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) && VerifyOffset(verifier, VT_SIGNATURE_DEFS) &&
           verifier.VerifyVector(signature_defs()) &&
           verifier.VerifyVectorOfTables(signature_defs()) && verifier.EndTable();
  }
};

struct ModelBuilder
{
  typedef Model Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) { fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0); }
  void add_operator_codes(
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::OperatorCode>>>
      operator_codes)
  {
    fbb_.AddOffset(Model::VT_OPERATOR_CODES, operator_codes);
  }
  void add_subgraphs(
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::SubGraph>>> subgraphs)
  {
    fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description)
  {
    fbb_.AddOffset(Model::VT_DESCRIPTION, description);
  }
  void add_buffers(
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::Buffer>>> buffers)
  {
    fbb_.AddOffset(Model::VT_BUFFERS, buffers);
  }
  void add_metadata_buffer(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> metadata_buffer)
  {
    fbb_.AddOffset(Model::VT_METADATA_BUFFER, metadata_buffer);
  }
  void add_metadata(
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::Metadata>>> metadata)
  {
    fbb_.AddOffset(Model::VT_METADATA, metadata);
  }
  void add_signature_defs(
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::SignatureDef>>>
      signature_defs)
  {
    fbb_.AddOffset(Model::VT_SIGNATURE_DEFS, signature_defs);
  }
  explicit ModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Model> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Model> CreateModel(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint32_t version = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::OperatorCode>>>
    operator_codes = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::SubGraph>>> subgraphs =
    0,
  ::flatbuffers::Offset<::flatbuffers::String> description = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::Buffer>>> buffers = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> metadata_buffer = 0,
  ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::Metadata>>> metadata =
    0,
  ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<circle::SignatureDef>>>
    signature_defs = 0)
{
  ModelBuilder builder_(_fbb);
  builder_.add_signature_defs(signature_defs);
  builder_.add_metadata(metadata);
  builder_.add_metadata_buffer(metadata_buffer);
  builder_.add_buffers(buffers);
  builder_.add_description(description);
  builder_.add_subgraphs(subgraphs);
  builder_.add_operator_codes(operator_codes);
  builder_.add_version(version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Model> CreateModelDirect(
  ::flatbuffers::FlatBufferBuilder &_fbb, uint32_t version = 0,
  const std::vector<::flatbuffers::Offset<circle::OperatorCode>> *operator_codes = nullptr,
  const std::vector<::flatbuffers::Offset<circle::SubGraph>> *subgraphs = nullptr,
  const char *description = nullptr,
  const std::vector<::flatbuffers::Offset<circle::Buffer>> *buffers = nullptr,
  const std::vector<int32_t> *metadata_buffer = nullptr,
  const std::vector<::flatbuffers::Offset<circle::Metadata>> *metadata = nullptr,
  const std::vector<::flatbuffers::Offset<circle::SignatureDef>> *signature_defs = nullptr)
{
  auto operator_codes__ =
    operator_codes ? _fbb.CreateVector<::flatbuffers::Offset<circle::OperatorCode>>(*operator_codes)
                   : 0;
  auto subgraphs__ =
    subgraphs ? _fbb.CreateVector<::flatbuffers::Offset<circle::SubGraph>>(*subgraphs) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto buffers__ = buffers ? _fbb.CreateVector<::flatbuffers::Offset<circle::Buffer>>(*buffers) : 0;
  auto metadata_buffer__ = metadata_buffer ? _fbb.CreateVector<int32_t>(*metadata_buffer) : 0;
  auto metadata__ =
    metadata ? _fbb.CreateVector<::flatbuffers::Offset<circle::Metadata>>(*metadata) : 0;
  auto signature_defs__ =
    signature_defs ? _fbb.CreateVector<::flatbuffers::Offset<circle::SignatureDef>>(*signature_defs)
                   : 0;
  return circle::CreateModel(_fbb, version, operator_codes__, subgraphs__, description__, buffers__,
                             metadata_buffer__, metadata__, signature_defs__);
}

inline bool VerifyQuantizationDetails(::flatbuffers::Verifier &verifier, const void *obj,
                                      QuantizationDetails type)
{
  switch (type)
  {
    case QuantizationDetails_NONE:
    {
      return true;
    }
    case QuantizationDetails_CustomQuantization:
    {
      auto ptr = reinterpret_cast<const circle::CustomQuantization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool
VerifyQuantizationDetailsVector(::flatbuffers::Verifier &verifier,
                                const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
                                const ::flatbuffers::Vector<uint8_t> *types)
{
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
  {
    if (!VerifyQuantizationDetails(verifier, values->Get(i),
                                   types->GetEnum<QuantizationDetails>(i)))
    {
      return false;
    }
  }
  return true;
}

inline bool VerifySparseIndexVector(::flatbuffers::Verifier &verifier, const void *obj,
                                    SparseIndexVector type)
{
  switch (type)
  {
    case SparseIndexVector_NONE:
    {
      return true;
    }
    case SparseIndexVector_Int32Vector:
    {
      auto ptr = reinterpret_cast<const circle::Int32Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint16Vector:
    {
      auto ptr = reinterpret_cast<const circle::Uint16Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint8Vector:
    {
      auto ptr = reinterpret_cast<const circle::Uint8Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool
VerifySparseIndexVectorVector(::flatbuffers::Verifier &verifier,
                              const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
                              const ::flatbuffers::Vector<uint8_t> *types)
{
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
  {
    if (!VerifySparseIndexVector(verifier, values->Get(i), types->GetEnum<SparseIndexVector>(i)))
    {
      return false;
    }
  }
  return true;
}

inline bool VerifyBuiltinOptions(::flatbuffers::Verifier &verifier, const void *obj,
                                 BuiltinOptions type)
{
  switch (type)
  {
    case BuiltinOptions_NONE:
    {
      return true;
    }
    case BuiltinOptions_Conv2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Conv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthwiseConv2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::DepthwiseConv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions:
    {
      auto ptr = reinterpret_cast<const circle::ConcatEmbeddingsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSHProjectionOptions:
    {
      auto ptr = reinterpret_cast<const circle::LSHProjectionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Pool2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Pool2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SVDFOptions:
    {
      auto ptr = reinterpret_cast<const circle::SVDFOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::RNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FullyConnectedOptions:
    {
      auto ptr = reinterpret_cast<const circle::FullyConnectedOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SoftmaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::SoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatenationOptions:
    {
      auto ptr = reinterpret_cast<const circle::ConcatenationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddOptions:
    {
      auto ptr = reinterpret_cast<const circle::AddOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_L2NormOptions:
    {
      auto ptr = reinterpret_cast<const circle::L2NormOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions:
    {
      auto ptr = reinterpret_cast<const circle::LocalResponseNormalizationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::LSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeBilinearOptions:
    {
      auto ptr = reinterpret_cast<const circle::ResizeBilinearOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOptions:
    {
      auto ptr = reinterpret_cast<const circle::CallOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReshapeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReshapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SkipGramOptions:
    {
      auto ptr = reinterpret_cast<const circle::SkipGramOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToDepthOptions:
    {
      auto ptr = reinterpret_cast<const circle::SpaceToDepthOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions:
    {
      auto ptr = reinterpret_cast<const circle::EmbeddingLookupSparseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MulOptions:
    {
      auto ptr = reinterpret_cast<const circle::MulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadOptions:
    {
      auto ptr = reinterpret_cast<const circle::PadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherOptions:
    {
      auto ptr = reinterpret_cast<const circle::GatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchToSpaceNDOptions:
    {
      auto ptr = reinterpret_cast<const circle::BatchToSpaceNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToBatchNDOptions:
    {
      auto ptr = reinterpret_cast<const circle::SpaceToBatchNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeOptions:
    {
      auto ptr = reinterpret_cast<const circle::TransposeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReducerOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReducerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SubOptions:
    {
      auto ptr = reinterpret_cast<const circle::SubOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DivOptions:
    {
      auto ptr = reinterpret_cast<const circle::DivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SqueezeOptions:
    {
      auto ptr = reinterpret_cast<const circle::SqueezeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SequenceRNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::SequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_StridedSliceOptions:
    {
      auto ptr = reinterpret_cast<const circle::StridedSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpOptions:
    {
      auto ptr = reinterpret_cast<const circle::ExpOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TopKV2Options:
    {
      auto ptr = reinterpret_cast<const circle::TopKV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitOptions:
    {
      auto ptr = reinterpret_cast<const circle::SplitOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogSoftmaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogSoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CastOptions:
    {
      auto ptr = reinterpret_cast<const circle::CastOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DequantizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::DequantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MaximumMinimumOptions:
    {
      auto ptr = reinterpret_cast<const circle::MaximumMinimumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::ArgMaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessOptions:
    {
      auto ptr = reinterpret_cast<const circle::LessOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NegOptions:
    {
      auto ptr = reinterpret_cast<const circle::NegOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadV2Options:
    {
      auto ptr = reinterpret_cast<const circle::PadV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterOptions:
    {
      auto ptr = reinterpret_cast<const circle::GreaterOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::GreaterEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::LessEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectOptions:
    {
      auto ptr = reinterpret_cast<const circle::SelectOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SliceOptions:
    {
      auto ptr = reinterpret_cast<const circle::SliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeConvOptions:
    {
      auto ptr = reinterpret_cast<const circle::TransposeConvOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SparseToDenseOptions:
    {
      auto ptr = reinterpret_cast<const circle::SparseToDenseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TileOptions:
    {
      auto ptr = reinterpret_cast<const circle::TileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpandDimsOptions:
    {
      auto ptr = reinterpret_cast<const circle::ExpandDimsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::EqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NotEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::NotEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ShapeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ShapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PowOptions:
    {
      auto ptr = reinterpret_cast<const circle::PowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMinOptions:
    {
      auto ptr = reinterpret_cast<const circle::ArgMinOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FakeQuantOptions:
    {
      auto ptr = reinterpret_cast<const circle::FakeQuantOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PackOptions:
    {
      auto ptr = reinterpret_cast<const circle::PackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalOrOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalOrOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_OneHotOptions:
    {
      auto ptr = reinterpret_cast<const circle::OneHotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalAndOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalAndOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalNotOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalNotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnpackOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnpackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorDivOptions:
    {
      auto ptr = reinterpret_cast<const circle::FloorDivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquareOptions:
    {
      auto ptr = reinterpret_cast<const circle::SquareOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ZerosLikeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ZerosLikeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FillOptions:
    {
      auto ptr = reinterpret_cast<const circle::FillOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::BidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::BidirectionalSequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorModOptions:
    {
      auto ptr = reinterpret_cast<const circle::FloorModOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RangeOptions:
    {
      auto ptr = reinterpret_cast<const circle::RangeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions:
    {
      auto ptr = reinterpret_cast<const circle::ResizeNearestNeighborOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LeakyReluOptions:
    {
      auto ptr = reinterpret_cast<const circle::LeakyReluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquaredDifferenceOptions:
    {
      auto ptr = reinterpret_cast<const circle::SquaredDifferenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MirrorPadOptions:
    {
      auto ptr = reinterpret_cast<const circle::MirrorPadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AbsOptions:
    {
      auto ptr = reinterpret_cast<const circle::AbsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitVOptions:
    {
      auto ptr = reinterpret_cast<const circle::SplitVOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UniqueOptions:
    {
      auto ptr = reinterpret_cast<const circle::UniqueOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseV2Options:
    {
      auto ptr = reinterpret_cast<const circle::ReverseV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddNOptions:
    {
      auto ptr = reinterpret_cast<const circle::AddNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherNdOptions:
    {
      auto ptr = reinterpret_cast<const circle::GatherNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CosOptions:
    {
      auto ptr = reinterpret_cast<const circle::CosOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhereOptions:
    {
      auto ptr = reinterpret_cast<const circle::WhereOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RankOptions:
    {
      auto ptr = reinterpret_cast<const circle::RankOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseSequenceOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReverseSequenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixDiagOptions:
    {
      auto ptr = reinterpret_cast<const circle::MatrixDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_QuantizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::QuantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixSetDiagOptions:
    {
      auto ptr = reinterpret_cast<const circle::MatrixSetDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HardSwishOptions:
    {
      auto ptr = reinterpret_cast<const circle::HardSwishOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_IfOptions:
    {
      auto ptr = reinterpret_cast<const circle::IfOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhileOptions:
    {
      auto ptr = reinterpret_cast<const circle::WhileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthToSpaceOptions:
    {
      auto ptr = reinterpret_cast<const circle::DepthToSpaceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV4Options:
    {
      auto ptr = reinterpret_cast<const circle::NonMaxSuppressionV4Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV5Options:
    {
      auto ptr = reinterpret_cast<const circle::NonMaxSuppressionV5Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ScatterNdOptions:
    {
      auto ptr = reinterpret_cast<const circle::ScatterNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectV2Options:
    {
      auto ptr = reinterpret_cast<const circle::SelectV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DensifyOptions:
    {
      auto ptr = reinterpret_cast<const circle::DensifyOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SegmentSumOptions:
    {
      auto ptr = reinterpret_cast<const circle::SegmentSumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchMatMulOptions:
    {
      auto ptr = reinterpret_cast<const circle::BatchMatMulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CumsumOptions:
    {
      auto ptr = reinterpret_cast<const circle::CumsumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOnceOptions:
    {
      auto ptr = reinterpret_cast<const circle::CallOnceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BroadcastToOptions:
    {
      auto ptr = reinterpret_cast<const circle::BroadcastToOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Rfft2dOptions:
    {
      auto ptr = reinterpret_cast<const circle::Rfft2dOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Conv3DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Conv3DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableFindOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableFindOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableImportOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableImportOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableSizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableSizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_VarHandleOptions:
    {
      auto ptr = reinterpret_cast<const circle::VarHandleOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReadVariableOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReadVariableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AssignVariableOptions:
    {
      auto ptr = reinterpret_cast<const circle::AssignVariableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RandomOptions:
    {
      auto ptr = reinterpret_cast<const circle::RandomOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BucketizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::BucketizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GeluOptions:
    {
      auto ptr = reinterpret_cast<const circle::GeluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DynamicUpdateSliceOptions:
    {
      auto ptr = reinterpret_cast<const circle::DynamicUpdateSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentProdOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnsortedSegmentProdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentMaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnsortedSegmentMaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentMinOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnsortedSegmentMinOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentSumOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnsortedSegmentSumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ATan2Options:
    {
      auto ptr = reinterpret_cast<const circle::ATan2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SignOptions:
    {
      auto ptr = reinterpret_cast<const circle::SignOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BitcastOptions:
    {
      auto ptr = reinterpret_cast<const circle::BitcastOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BitwiseXorOptions:
    {
      auto ptr = reinterpret_cast<const circle::BitwiseXorOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RightShiftOptions:
    {
      auto ptr = reinterpret_cast<const circle::RightShiftOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GRUOptions:
    {
      auto ptr = reinterpret_cast<const circle::GRUOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BCQGatherOptions:
    {
      auto ptr = reinterpret_cast<const circle::BCQGatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BCQFullyConnectedOptions:
    {
      auto ptr = reinterpret_cast<const circle::BCQFullyConnectedOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_InstanceNormOptions:
    {
      auto ptr = reinterpret_cast<const circle::InstanceNormOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool
VerifyBuiltinOptionsVector(::flatbuffers::Verifier &verifier,
                           const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
                           const ::flatbuffers::Vector<uint8_t> *types)
{
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
  {
    if (!VerifyBuiltinOptions(verifier, values->Get(i), types->GetEnum<BuiltinOptions>(i)))
    {
      return false;
    }
  }
  return true;
}

inline bool VerifyBuiltinOptions2(::flatbuffers::Verifier &verifier, const void *obj,
                                  BuiltinOptions2 type)
{
  switch (type)
  {
    case BuiltinOptions2_NONE:
    {
      return true;
    }
    case BuiltinOptions2_StablehloConcatenateOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloConcatenateOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloBroadcastInDimOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloBroadcastInDimOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloSliceOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloConvolutionOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloConvolutionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloCustomCallOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloCustomCallOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloReduceOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloReduceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloScatterOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloScatterOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloCompareOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloCompareOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloDynamicSliceOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloDynamicSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloPadOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloPadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloIotaOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloIotaOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloDotGeneralOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloDotGeneralOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloReduceWindowOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloReduceWindowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloSortOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloSortOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloWhileOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloWhileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloGatherOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloGatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloTransposeOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloTransposeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_DilateOptions:
    {
      auto ptr = reinterpret_cast<const circle::DilateOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloRngBitGeneratorOptions:
    {
      auto ptr = reinterpret_cast<const circle::StablehloRngBitGeneratorOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_ReduceWindowOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReduceWindowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool
VerifyBuiltinOptions2Vector(::flatbuffers::Verifier &verifier,
                            const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
                            const ::flatbuffers::Vector<uint8_t> *types)
{
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
  {
    if (!VerifyBuiltinOptions2(verifier, values->Get(i), types->GetEnum<BuiltinOptions2>(i)))
    {
      return false;
    }
  }
  return true;
}

inline const circle::Model *GetModel(const void *buf)
{
  return ::flatbuffers::GetRoot<circle::Model>(buf);
}

inline const circle::Model *GetSizePrefixedModel(const void *buf)
{
  return ::flatbuffers::GetSizePrefixedRoot<circle::Model>(buf);
}

inline const char *ModelIdentifier() { return "CIR0"; }

inline bool ModelBufferHasIdentifier(const void *buf)
{
  return ::flatbuffers::BufferHasIdentifier(buf, ModelIdentifier());
}

inline bool SizePrefixedModelBufferHasIdentifier(const void *buf)
{
  return ::flatbuffers::BufferHasIdentifier(buf, ModelIdentifier(), true);
}

inline bool VerifyModelBuffer(::flatbuffers::Verifier &verifier)
{
  return verifier.VerifyBuffer<circle::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(::flatbuffers::Verifier &verifier)
{
  return verifier.VerifySizePrefixedBuffer<circle::Model>(ModelIdentifier());
}

inline const char *ModelExtension() { return "circle"; }

inline void FinishModelBuffer(::flatbuffers::FlatBufferBuilder &fbb,
                              ::flatbuffers::Offset<circle::Model> root)
{
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(::flatbuffers::FlatBufferBuilder &fbb,
                                          ::flatbuffers::Offset<circle::Model> root)
{
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

} // namespace circle

#endif // FLATBUFFERS_GENERATED_CIRCLESCHEMA_CIRCLE_H_
