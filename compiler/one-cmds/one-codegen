#!/usr/bin/env bash
''''export SCRIPT_PATH="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)" # '''
''''export PY_PATH=${SCRIPT_PATH}/venv/bin/python                                       # '''
''''test -f ${PY_PATH} && exec ${PY_PATH} "$0" "$@"                                     # '''
''''echo "Error: Virtual environment not found. Please run 'one-prepare-venv' command." # '''
''''exit 255                                                                            # '''

# Copyright (c) 2020 Samsung Electronics Co., Ltd. All Rights Reserved
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import copy
import glob
import itertools
import ntpath
import os
import sys
import shutil
from types import SimpleNamespace

import onelib.backends as backends
import onelib.utils as oneutils

# TODO Find better way to suppress trackback on error
sys.tracebacklimit = 0

COMMAND_KEYS = ['__command', 'command']
BACKEND_KEY = 'BACKEND'


def _get_parser(backends_list):
    codegen_usage = 'one-codegen [-h] [-v] [-C CONFIG] [-b BACKEND | -T TARGET] [--] [COMMANDS FOR BACKEND]'
    parser = argparse.ArgumentParser(description='command line tool for code generation',
                                     usage=codegen_usage)

    oneutils.add_default_arg(parser)

    # get backend list in the directory
    backends_name = [ntpath.basename(f) for f in backends_list]
    if not backends_name:
        backends_name_message = '(There is no available backend drivers)'
    else:
        backends_name_message = '(available backend drivers: ' + ', '.join(
            backends_name) + ')'
    backend_help_message = 'backend name to use ' + backends_name_message
    parser.add_argument('-b', '--backend', type=str, help=backend_help_message)
    parser.add_argument('-T',
                        '--target',
                        type=str,
                        help='run with specific target of the backend')

    return parser


def _verify_arg(parser, cmd_codegen_args, cfg_codegen_args, cfg_backend_args,
                cmd_backend_args):
    """
    Verify given arguments.

      cmd_codegen_args: arguments from command line.
      cfg_codegen_args: arguments from onecc configuration file in [one-codegen] section
      cfg_backend_args: arguments from onecc configuration file in [backend] section
      cmd_backend_args: arguments from command line for backend driver
    
    # one-codegen defines its behavior for below cases.

    [1] one-codegen -h
    [2] one-codegen -v
    [3] one-codegen -C ${cfg} (backend, command key in cfg)
    [4] one-codegen -C ${cfg} (backends key in cfg)
    [5] one-codegen -b ${backend} ${command}
    [6] one-codegen -b ${backend} -- ${command}
    [7] one-codegen -b ${backend} -C {cfg} (backend, command key in cfg)
    [8] one-codegen -b ${backend} -C {cfg} (backends key in cfg) (Only 'backend' is invoked, 
         even though cfg file has multiple backends)
    [9] one-codegen -b ${backend} -C ${cfg} -- ${command} (backend, command key in cfg) 
    [10] one-codegen -b ${backend} -C ${cfg} -- ${command} (backends key in cfg) (Only 'backend' is invoked, 
         even though cfg file has multiple backends)
    [11] one-codegen -C {cfg} (w/ target, w/ command schema)
    [12] one-codegen -C {cfg} (w/ target, w/o command schema)
    [13] one-codegen -C {cfg} -T {target} (w/ command schema)
    [14] one-codegen -C {cfg} -T {target} (w/o command schema)
    [15] one-codegen -T {target} ${command} (ignore command schema)
    [16] one-codegen -T {target} -- ${command} (ignore command schema)

    All other cases are not allowed or an undefined behavior.

    # We allow a few styles in [one-codegen] section.

    [Style 1]
    backend=dummy
    command=${command for 'dummy' backend}

    [Style 2]
    backends=dummy1,dummy2
    dummy1=${command for 'dummy1' backend}
    dummy2=${command for 'dummy2' backend}

    [Style 3]
    option1=${argument for option1}
    option2=${argument for option2}

    NOTE [Style 3] refers to a style that has a command schema.
    """
    cmd_backend_exist = oneutils.is_valid_attr(cmd_codegen_args, 'backend')
    cmd_target_exist = oneutils.is_valid_attr(cmd_codegen_args, 'target')
    cfg_backend_exist = oneutils.is_valid_attr(cfg_codegen_args, 'backend')
    cfg_backends_exist = oneutils.is_valid_attr(cfg_codegen_args, 'backends')
    target_exist = cmd_target_exist or oneutils.is_valid_attr(cfg_backend_args, 'target')
    cmd_key_exist = any(
        oneutils.is_valid_attr(cfg_codegen_args, cmd_key) for cmd_key in COMMAND_KEYS)

    backend = None
    # get backend from target configuration
    if target_exist:
        target = None
        if oneutils.is_valid_attr(cfg_backend_args, 'target'):
            target = getattr(cfg_backend_args, 'target')
        # overwrite the value if it exists in command line option as it has higher priority.
        if oneutils.is_valid_attr(cmd_codegen_args, 'target'):
            target = cmd_codegen_args.target
        assert target
        backend = backends.get_value_from_target_conf(target, BACKEND_KEY)

    # backend information should exist.
    missing = []
    if all(not e
           for e in [backend, cmd_backend_exist, cfg_backend_exist, cfg_backends_exist]):
        missing.append('[-b/--backend | -T/--target]')
    if len(missing):
        parser.error('the following arguments are required: ' + ' '.join(missing))

    ### verify commnad line
    if cmd_backend_exist and cmd_target_exist:
        parser.error(
            '\'backend\' option and \'target\' option cannot be used simultaneously.')
    # if config option is not given, both backend and command option should be given.
    if not oneutils.is_valid_attr(cmd_codegen_args, 'config'):
        if not cmd_backend_args:
            parser.error('Not found the command for given backend')
    # if command for backend driver is given in commnad line, backend option should be given as well.
    if cmd_backend_args:
        if all(not e for e in [backend, cmd_backend_exist]):
            parser.error('[-b/--backend | -T/--target] option is missing.')

    ### verify onecc configuration file
    use_command_schema = False
    if oneutils.is_valid_attr(cmd_codegen_args, 'config'):
        # Style 3
        if target_exist and backend:
            cmd_parser = oneutils.get_arg_parser(backend, cmd="codegen", target=target)
            if not cmd_parser:
                use_command_schema = False
            else:
                # check if given keys in conf file are from the command schema.
                schema_option_names = cmd_parser.get_option_names(flatten=True,
                                                                  without_dash=True)
                if oneutils.is_valid_attr(cfg_codegen_args, 'command'):
                    if 'command' in schema_option_names:
                        use_command_schema = True
                    else:
                        print(
                            "WARNING: 'command' key in the [one-codegen] will be deprecated as of September 1, 2025."
                        )
                        use_command_schema = False
                else:
                    for cfg_codegen_arg in vars(cfg_codegen_args):
                        if cfg_codegen_arg not in schema_option_names:
                            cmd_parser.print_help()
                            parser.error('Invalid option in [one-codegen] section')
                    use_command_schema = True

        if not use_command_schema:
            # both backend and backends keys are in [one-codgen] section
            if cfg_backend_exist and cfg_backends_exist:
                parser.error(
                    '\'backend\' and \'backends\' keys cannot be used simultaneously.')

            # Style 2
            if cfg_backends_exist:
                # backends and [command, __command] key in [one-codegen] section
                if cmd_key_exist:
                    parser.error(
                        '\'backends\' and \'(__)command\' keys cannot be used simultaneously.'
                    )

                # commands for given backends should exist
                cfg_backends = getattr(cfg_codegen_args, 'backends').split(',')
                for b in cfg_backends:
                    if not oneutils.is_valid_attr(cfg_codegen_args, b):
                        parser.error('Not found the command for ' + b)

                # Check if given backend from command line exists in the configuration file
                if cmd_backend_exist:
                    if cmd_codegen_args.backend not in cfg_backends:
                        parser.error('Not found the command for given backend')
            # Style 1
            else:
                # both backend and command should exist.
                assert any(e for e in [backend, cmd_backend_exist, cfg_backend_exist])
                if not cmd_key_exist:
                    parser.error('Not found the command for given backend')


def _parse_arg(parser):
    # args for `one-codegen`
    codegen_args = []
    # args for backend tool
    backend_args = []
    argv = copy.deepcopy(sys.argv)
    # delete file name
    del argv[0]
    # split by '--'
    args = [list(y) for x, y in itertools.groupby(argv, lambda z: z == '--') if not x]
    if len(args) == 0:
        codegen_args = parser.parse_args(codegen_args)
    # one-codegen has two interfaces
    # 1. one-codegen [-h] [-v] [-C CONFIG] [-b BACKEND | -T TARGET] [COMMANDS FOR BACKEND]
    if len(args) == 1:
        codegen_args = args[0]
        codegen_args, backend_args = parser.parse_known_args(codegen_args)
    # 2. one-codegen [-h] [-v] [-C CONFIG] [-b BACKEND | -T TARGET] -- [COMMANDS FOR BACKEND]
    if len(args) == 2:
        codegen_args = args[0]
        backend_args = args[1]
        codegen_args = parser.parse_args(codegen_args)
    # print version
    if len(args) and codegen_args.version:
        oneutils.print_version_and_exit(__file__)

    return codegen_args, backend_args


def main():
    # get backend list
    backends_list = backends.get_list('*-compile')

    # parse arguments
    parser = _get_parser(backends_list)
    cmd_codegen_args, cmd_backend_args = _parse_arg(parser)

    # parse configuration file
    cfg_codegen_args = SimpleNamespace()
    oneutils.parse_cfg(cmd_codegen_args.config, 'one-codegen', cfg_codegen_args)
    cfg_backend_args = SimpleNamespace()
    oneutils.parse_cfg(cmd_codegen_args.config, 'backend', cfg_backend_args, quiet=True)

    # verify arguments
    _verify_arg(parser, cmd_codegen_args, cfg_codegen_args, cfg_backend_args,
                cmd_backend_args)
    """
    get target and backend

    NOTE each retrieval should be processed in order for the priorities. Values that have
         lower priority will be overwritten by those that have higher priority.
    """
    ### get target
    # NOTE each step overwrites existing `backend_to_run` for considering priorities.
    target_to_run = None
    # 1. get target from onecc configuration
    if oneutils.is_valid_attr(cfg_backend_args, 'target'):
        target_to_run = getattr(cfg_backend_args, 'target')
    # 2. get target from command line
    if oneutils.is_valid_attr(cmd_codegen_args, 'target'):
        target_to_run = cmd_codegen_args.target

    ### get backend
    backend_to_run = []
    parser = None
    # 1. get backend from target configuration
    if target_to_run:
        backend = backends.get_value_from_target_conf(target_to_run, BACKEND_KEY)
        backend_to_run.append(backend)
        # check if given backend has command schema
        # NOTE command schema could exist only if target is given.
        parser = oneutils.get_arg_parser(backend, cmd="codegen", target=target_to_run)
    # 2. get backend from onecc configuration
    if oneutils.is_valid_attr(cmd_codegen_args, 'config'):
        if parser:
            # command schema exist (Style 3)
            # "backend" key assumes one of backend options
            # DO NOTHING
            pass
        else:
            assert oneutils.is_valid_attr(cfg_codegen_args,
                                          'backend') or oneutils.is_valid_attr(
                                              cfg_codegen_args, 'backends')
            # Style 1
            if oneutils.is_valid_attr(cfg_codegen_args, 'backend'):
                backend_to_run = [cfg_codegen_args.backend]
            # Style 2
            if oneutils.is_valid_attr(cfg_codegen_args, 'backends'):
                backend_to_run = cfg_codegen_args.backends.split(',')
    # 3. get backend from command line
    if oneutils.is_valid_attr(cmd_codegen_args, 'backend'):
        backend_to_run = [cmd_codegen_args.backend]

    ### make commands
    use_command_schema = False
    if parser:
        schema_option_names = parser.get_option_names(flatten=True, without_dash=True)
        # if reserved keys exist, run without command schema.
        if oneutils.is_valid_attr(cfg_codegen_args, 'command'):
            if 'command' in schema_option_names:
                use_command_schema = True
            else:
                use_command_schema = False
        else:
            use_command_schema = True

    if use_command_schema:
        codegen_cmd = parser.make_cmd(cfg_codegen_args)
        oneutils.run(codegen_cmd, err_prefix=parser.driver)
    else:
        for backend in backend_to_run:
            # get driver for the backend
            codegen_driver = f'{backend}-compile'
            codegen_path = None
            for cand in backends_list:
                if ntpath.basename(cand) == codegen_driver:
                    codegen_path = cand
                    break
            if not codegen_path:
                # find backend from system path
                codegen_path = shutil.which(codegen_driver)
            if not codegen_path:
                raise FileNotFoundError(codegen_driver + ' not found')

            codegen_cmd_base = [codegen_path]
            # "--target" option is intentionally inserted at the beginning of the command.
            # it would match the command of backends' tool.
            if target_to_run:
                codegen_cmd_base += ['--target', target_to_run]

            # Style 2
            if oneutils.is_valid_attr(cfg_codegen_args, backend):
                codegen_cmd = codegen_cmd_base + getattr(cfg_codegen_args,
                                                         backend).split()
            # Style 1, Style 3 (without command schema)
            else:
                if oneutils.is_valid_attr(cfg_codegen_args, 'command'):
                    codegen_cmd = codegen_cmd_base + getattr(cfg_codegen_args,
                                                             'command').split()

            # if backend command exists in command line arguments, overwrite the ones from onecc configuration file.
            if cmd_backend_args:
                codegen_cmd = codegen_cmd_base + cmd_backend_args

            # run backend driver
            oneutils.run(codegen_cmd, err_prefix=codegen_driver)


if __name__ == '__main__':
    oneutils.safemain(main, __file__)
