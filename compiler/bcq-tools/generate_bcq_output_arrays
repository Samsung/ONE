#!/usr/bin/env python3

# Copyright (c) 2020 Samsung Electronics Co., Ltd. All Rights Reserved
# Copyright 2017 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import tensorflow as tf

import argparse
import sys


def _get_parser():
    """
    Returns an ArgumentParser for generating output_arrays.
    """
    parser = argparse.ArgumentParser(
        description=("Command line tool to generated output_arrays of BCQ nodes"))

    # Input and output path.
    parser.add_argument(
        "-i",
        "--input_path",
        type=str,
        help="Full filepath of the input file.",
        required=True)
    parser.add_argument(
        "-m",
        "--output_path_metadata",
        type=str,
        help="Full filepath of the output metadata file.",
        required=True)
    parser.add_argument(
        "-o",
        "--output_path_arrays",
        type=str,
        help="Full filepath of the output arrays file.",
        required=True)

    return parser


# This function is copied from
# https://github.com/tensorflow/tensorflow/blob/r2.3/tensorflow/examples/label_image/label_image.py#L26
def load_graph(model_file):
    graph = tf.Graph()
    graph_def = tf.compat.v1.GraphDef()

    with open(model_file, "rb") as f:
        graph_def.ParseFromString(f.read())
    with graph.as_default():
        tf.import_graph_def(graph_def, name="")

    return graph


def print_bcqinfo_output_arrays_v1(flags):
    graph = load_graph(flags.input_path)
    graph_def = graph.as_graph_def()
    ops = graph.get_operations()

    prefix_set = set()
    has_dequant_weight = False

    for op in ops:
        if op.type == "Const" and "/bcqinfo_" in op.outputs[0].name:
            if "one_compiler/bcqinfo_one_metadata" in op.outputs[0].name:
                continue
            prefix_index = op.outputs[0].name.index("/bcqinfo_")
            prefix = op.outputs[0].name[:prefix_index]
            prefix_set.add(prefix)

            infoname = op.outputs[0].name[prefix_index + 1:-2]
            if infoname == "bcqinfo_dequant_weight":
                has_dequant_weight = True

    queue_prefix = list(prefix_set)
    queue_nodename = []
    for prefix in queue_prefix:
        nodename = prefix + ":0"
        queue_nodename.append(nodename)

    prefix_node_dict = {}
    matmul_node_prefix_dict = {}
    while len(queue_prefix) > 0:
        prefix = queue_prefix.pop(0)
        nodename = queue_nodename.pop(0)
        if prefix not in prefix_node_dict.keys():
            prefix_node_dict[prefix] = []

        for op in ops:
            if (op.type == "MatMul"
                    and (op.inputs[0].name == nodename or op.inputs[1].name == nodename)):
                prefix_node_dict[prefix].append(op.outputs[0].name[:-2])
                matmul_node_prefix_dict[op.outputs[0].name[:-2]] = prefix
            elif op.type == "Einsum" and (op.inputs[0].name == nodename
                                          or op.inputs[1].name == nodename):
                prefix_node_dict[prefix].append(op.outputs[0].name[:-2])
            elif op.type == "GatherV2" and op.inputs[0].name == nodename:
                prefix_node_dict[prefix].append(op.outputs[0].name[:-2])
            elif len(op.outputs) == 1:
                for i in range(len(op.inputs)):
                    if op.inputs[i].name == nodename:
                        queue_prefix.append(prefix)
                        queue_nodename.append(op.outputs[0].name)

    queue_prefix = list(matmul_node_prefix_dict.values())
    queue_nodename = []
    for matmul_node in matmul_node_prefix_dict.keys():
        nodename = matmul_node + ":0"
        queue_nodename.append(nodename)

    fuseop_prefix_dict = {}
    stop_type = ["MatMul", "GatherV2", "Einsum"]
    mark_type = ["Add", "AddV2", "BiasAdd", "Reshape", "Transpose"]
    mark_and_stop_type = ["Relu", "Relu6", "Tanh"]
    pass_type = [
        "BatchToSpaceND", "Cast", "DepthToSpace", "ExpandDims", "ResizeBilinear",
        "ResizeNearestNeighbor", "ScatterNd", "SpaceToBatchND", "SpaceToDepth", "Squeeze",
        "Identity", "Pack", "Unpack", "Stack"
    ]
    visited_nodes = set(queue_nodename)
    while len(queue_prefix) > 0:
        prefix = queue_prefix.pop(0)
        nodename = queue_nodename.pop(0)

        for op in ops:
            for i in range(len(op.inputs)):
                if nodename in op.inputs[i].name:
                    if op.type in mark_type:
                        if op.name not in fuseop_prefix_dict.keys():
                            fuseop_prefix_dict[op.name] = set()
                        fuseop_prefix_dict[op.name].add(prefix)
                        if op.outputs[0].name not in visited_nodes:
                            queue_prefix.append(prefix)
                            queue_nodename.append(op.outputs[0].name)
                            visited_nodes.add(op.outputs[0].name)
                    elif op.type in mark_and_stop_type:
                        if op.name not in fuseop_prefix_dict.keys():
                            fuseop_prefix_dict[op.name] = set()
                        fuseop_prefix_dict[op.name].add(prefix)
                    elif op.type in pass_type and op.outputs[0].name not in visited_nodes:
                        queue_prefix.append(prefix)
                        queue_nodename.append(op.outputs[0].name)
                        visited_nodes.add(op.outputs[0].name)

    f_metadata = open(flags.output_path_metadata, 'w')
    f_arrays = open(flags.output_path_arrays, 'w')

    f_metadata.write("one_compiler/bcqinfo_one_metadata,")

    for prefix in prefix_set:
        for fusable_op in prefix_node_dict[prefix]:
            f_arrays.write("," + prefix + "/bcqinfo_do_w_x")
            f_arrays.write("," + prefix + "/bcqinfo_alpha")
            f_arrays.write("," + prefix + "/bcqinfo_packed_binary_code")
            f_arrays.write("," + prefix + "/bcqinfo_number_of_clusters")
            f_arrays.write("," + prefix + "/bcqinfo_size_of_clusters")
            f_arrays.write("," + prefix + "/bcqinfo_qbits_of_clusters")
            f_arrays.write("," + fusable_op)
            if has_dequant_weight:
                f_arrays.write("," + prefix + "/bcqinfo_dequant_weight")

    for fuseop in fuseop_prefix_dict.keys():
        if len(fuseop_prefix_dict[fuseop]) == 1:
            prefix = fuseop_prefix_dict[fuseop].pop()
            f_arrays.write("," + prefix + "/bcqinfo_do_w_x")
            f_arrays.write("," + prefix + "/bcqinfo_alpha")
            f_arrays.write("," + prefix + "/bcqinfo_packed_binary_code")
            f_arrays.write("," + prefix + "/bcqinfo_number_of_clusters")
            f_arrays.write("," + prefix + "/bcqinfo_size_of_clusters")
            f_arrays.write("," + prefix + "/bcqinfo_qbits_of_clusters")
            f_arrays.write("," + fuseop)
            if has_dequant_weight:
                f_arrays.write("," + prefix + "/bcqinfo_dequant_weight")

    f_metadata.close()
    f_arrays.close()


def find_bcq_version(flags):
    graph = load_graph(flags.input_path)
    graph_def = graph.as_graph_def()

    for node in graph_def.node:
        if node.op == "Const" and "one_compiler/bcqinfo_one_metadata" in node.name:
            original_tensor = tf.make_ndarray(node.attr["value"].tensor)
            return original_tensor[1]
    return -1


def print_bcq_output_arrays(flags):
    version = find_bcq_version(flags)

    if version == 1:
        print_bcqinfo_output_arrays_v1(flags)
    else:
        # When BCQ information not found, print nothing.
        f_metadata = open(flags.output_path_metadata, 'w')
        f_arrays = open(flags.output_path_arrays, 'w')
        f_metadata.close()
        f_arrays.close()


def main():
    # Parse argument.
    parser = _get_parser()
    flags = parser.parse_known_args(args=sys.argv[1:])

    print_bcq_output_arrays(flags[0])


if __name__ == "__main__":
    main()
