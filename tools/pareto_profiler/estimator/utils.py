#! /usr/bin/python
import subprocess
import numpy as np
import sys
import os
import json
"""
  General executor for bash-like shell. Supports multiline results.
"""


def exec_shell(command_str, newline_split=False):
    result = subprocess.Popen(command_str, shell=True, stdout=subprocess.PIPE)
    out, err = result.communicate()
    if (newline_split):
        res = out.decode("utf-8").split('\n')
        res = res[:-1]
        return res
    else:
        return out.decode("utf-8").split("\n")[0]


"""
  Given a number and its base, return its symbol-wise vector representation
"""


def int_to_vec(n, b, n_operations):
    number_arr = np.zeros(n_operations, dtype=int)
    i = n_operations - 1
    while (n != 0):
        number_arr[i] = n % b
        n = n // b
        i -= 1

    return number_arr[::-1]


"""
  Generate onert backend mapping for each graph node, give the encoded information in parameters.
  The details of the parameters are as follows:
  1. oplist     - a vector that maps each graph node to a unique <operation name, data size> id 
                  that was generated by an earlier script (gen_oplist.py)
  2. number     - the encoded backend assignment, typically a very long integer 
  3. base_value - for practical purposes, this is equivalent to the number of backends
"""


def generate_vars_for_indx(oplist, number, base_value):
    ofile = open('/tmp/envvars.sh', 'w')
    backend_map = {0: "=cpu", 1: "=acl_cl", 2: "=acl_neon"}

    if (base_value == 2):
        ofile.write("export BACKENDS=\"acl_cl;cpu\"")
    elif (base_value == 3):
        ofile.write("export BACKENDS=\"acl_cl;acl_neon;cpu\"")
    ofile.write("\n")
    number_arr = int_to_vec(number, base_value, len(oplist))
    cnt = 0
    op_backend_map_str = "export OP_BACKEND_MAP=\""
    for cnt in range(len(oplist)):
        backend_str = backend_map[int(number_arr[oplist[cnt]])]
        op_backend_map_str += ''.join([str(cnt), backend_str])

        if (cnt < (len(oplist) - 1)):
            op_backend_map_str += ";"
        else:
            op_backend_map_str += "\""
    ofile.write(op_backend_map_str)
    ofile.write("\n")
    ofile.close()


"""
  Print onert backend mapping for each graph node, give the encoded information in parameters.
  The details of the parameters are as follows:
  1. oplist     - a vector that maps each graph node to a unique <operation name, data size> id 
                  that was generated by an earlier script (gen_oplist.py)
  2. number     - the encoded backend assignment, typically a very long integer 
  3. base_value - for practical purposes, this is equivalent to the number of backends
"""


def fetch_config_by_indx(oplist, number, base_value):
    var_str = ""
    backend_map = {0: "=cpu", 1: "=acl_cl", 2: "=acl_neon"}

    if (base_value == 2):
        var_str += "BACKENDS=\"acl_cl;cpu\""
    elif (base_value == 3):
        var_str += "BACKENDS=\"acl_cl;acl_neon;cpu\""
    var_str += " "
    number_arr = int_to_vec(number, base_value, len(oplist))
    cnt = 0
    var_str += "OP_BACKEND_MAP=\""
    op_backend_map_str = ""
    for cnt in range(len(oplist)):
        backend_str = backend_map[int(number_arr[oplist[cnt]])]
        op_backend_map_str += ''.join([str(cnt), backend_str])

        if (cnt < (len(oplist) - 1)):
            op_backend_map_str += ";"
        else:
            op_backend_map_str += "\""
    var_str += op_backend_map_str
    return var_str


"""
  Generate onert backend mapping for each graph operation name, give the encoded information in parameters.
  The details of the parameters are as follows:
  1. oplist     - a vector that maps each graph node to a unique operation name. 
                  The list is generated by an earlier script (gen_oplist.py)
  2. number     - the encoded backend assignment, typically a long integer 
  3. base_value - for practical purposes, this is equivalent to the number of backends
"""


def generate_vars(oplist, number, base_value):
    ofile = open('/tmp/envvars.sh', 'w')
    backend_map = {0: "=cpu", 1: "=acl_cl", 2: "=acl_neon"}
    if (base_value == 2):
        ofile.write("export BACKENDS=\"acl_cl;cpu\"")
    elif (base_value == 3):
        ofile.write("export BACKENDS=\"acl_cl;acl_neon;cpu\"")
    ofile.write("\n")
    number_str = int_to_vec(number, base_value, len(oplist))

    cnt = 0
    for n in number_str:
        op_backend_map_str = ''.join(
            ["export OP_BACKEND_", oplist[cnt], backend_map[int(n)]])
        ofile.write(op_backend_map_str)
        ofile.write("\n")
        cnt += 1
    ofile.close()


"""
  Print onert backend mapping for each graph operation name, give the encoded information in parameters.
  The details of the parameters are as follows:
  1. oplist     - a vector that maps each graph node to a unique operation name. 
                  The list is generated by an earlier script (gen_oplist.py)
  2. number     - the encoded backend assignment, typically a long integer 
  3. base_value - for practical purposes, this is equivalent to the number of backends
"""


def fetch_config_by_name(oplist, number, base_value):
    var_str = ""
    backend_map = {0: "=cpu", 1: "=acl_cl", 2: "=acl_neon"}
    if (base_value == 2):
        var_str += "BACKENDS=\"acl_cl;cpu\""
    elif (base_value == 3):
        var_str += "BACKENDS=\"acl_cl;acl_neon;cpu\""
    var_str += " "

    number_str = int_to_vec(number, base_value, len(oplist))

    cnt = 0
    for n in number_str:
        var_str += ''.join(["OP_BACKEND_", oplist[cnt], backend_map[int(n)]])
        var_str += " "
        cnt += 1
    return var_str


"""
  Import operation list, map and relevant information for profiling. Note: These information should have been
  dumped under /tmp/oplist.json using the gen_oplist.py script.
"""


def import_configs(mode):
    if not os.path.isfile('/tmp/oplist.json'):
        print("No oplist")
        sys.exit(-1)
    with open('/tmp/oplist.json', 'r') as ifile:
        data = json.load(ifile)
    oplist = data['oplist']
    if mode == "name":
        nbits = len(oplist)
        return oplist, None, None
    elif mode == "index":
        opmap = data['opmap']
        opname_by_indx = data['opname_by_indx']
        return oplist, opmap, opname_by_indx

    print("mode is incorrect")
    sys.exit(-1)


"""
  Generic Progress bar display
"""


def progressbar(current_cnt, max_cnt, prefix="", file=sys.stdout):
    x = int(current_cnt * 100.0 / max_cnt)
    file.write("%s[%s%s] %i/%i\r" % (prefix, "#" * x, "." * (100 - x), x, 100))
    file.flush()
